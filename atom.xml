<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术成长之路</title>
  
  <subtitle>Simple technology</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-02T09:59:05.188Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨旭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android架构组件官方文档03——ViewModel</title>
    <link href="http://yoursite.com/2018/07/02/android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A303%E2%80%94%E2%80%94ViewModel/"/>
    <id>http://yoursite.com/2018/07/02/android/Android架构组件官方文档03——ViewModel/</id>
    <published>2018-07-02T09:58:17.000Z</published>
    <updated>2018-07-02T09:59:05.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ViewModel概述"><a href="#ViewModel概述" class="headerlink" title="ViewModel概述"></a>ViewModel概述</h3><p><a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>类旨在以一种有生命周期意识的方式存储和管理与UI相关的数据。<br><a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>类允许数据在配置变化（例如屏幕旋转）后存活。<br><strong>注意：要将ViewModel导入到Android项目中，请参阅<a href="https://developer.android.google.cn/topic/libraries/architecture/adding-components.html#lifecycle" target="_blank" rel="noopener">向项目添加组件</a></strong></p><p>Android framework管理UI控制器的生命周期，例如Activity和Fragment。<br>framework可能会决定销毁或重新创建UI控制器，以响应完全不受您控制的特定用户操作或设备事件。</p><p>如果系统销毁或重新创建UI控制器，则存储在其中的任何临时UI相关的数据都将丢失。例如，您的应用可能包含其中一项活动中的用户列表。当为配置更改重新创建活动时，新活动必须重新获取用户列表。<br>对于简单的数据，Activity可以使用<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onSaveInstanceState%28android.os.Bundle%29" target="_blank" rel="noopener">onSaveInstanceState()</a>方法并从<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onCreate%28android.os.Bundle%29" target="_blank" rel="noopener">onCreate()</a>中的bundle中恢复其数据，但此方法仅适用于可以序列化然后反序列化的少量数据，可能不适合像用户或位图的列表这样的大量数据。</p><p>另一个问题是UI控制器经常需要进行异步调用，这可能需要一些时间才能返回。UI控制器需要管理这些调用，并确保系统在销毁后清理它们以避免潜在的内存泄漏。这种管理需要大量的维护，并且在为配置更改而重新创建对象的情况下，由于对象可能不得不重新发出已经做出的请求，所以浪费资源。</p><p>UI控制器（如Activity和Fragment）主要用于显示UI数据，对用户操作做出反应或处理操作系统通信（如权限请求）。如果要求UI控制器也负责从数据库或网络加载数据，就会使改类变得臃肿。为UI控制器分配过多的责任可能会导致一个类尝试单独处理应用程序的所有工作，而不是将工作委托给其他类。通过这种方式给UI控制器分配过多的责任也使测试变得更加困难。</p><p>将视图数据所有权从UI控制器逻辑中分离出来更简单，更高效。</p><h3 id="实现一个ViewModel"><a href="#实现一个ViewModel" class="headerlink" title="实现一个ViewModel"></a>实现一个ViewModel</h3><p>架构组件为UI控制器提供<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>助手类。<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>对象在配置更改期间会自动保留，以便它们保存的数据立即可用于下一个Activity或fragment实例。例如，如果您需要在应用中显示用户列表，请明确分配职责来获取数据并将用户列表保存到ViewModel，而不是Activity或fragment，如以下示例代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MutableLiveData</span>&lt;<span class="type">List</span>&lt;<span class="type">User</span>&gt;&gt; users;</span><br><span class="line">    public <span class="type">LiveData</span>&lt;<span class="type">List</span>&lt;<span class="type">User</span>&gt;&gt; getUsers() &#123;</span><br><span class="line">        <span class="keyword">if</span> (users == <span class="literal">null</span>) &#123;</span><br><span class="line">            users = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="type">List</span>&lt;<span class="type">User</span>&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void loadUsers() &#123;</span><br><span class="line">        <span class="comment">// Do an asynchronous operation to fetch users.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以从一个Activity中访问列表，如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">        <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyViewModel</span> model = <span class="type">ViewModelProviders</span>.of(<span class="keyword">this</span>).get(<span class="type">MyViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line">        model.getUsers().observe(<span class="keyword">this</span>, users -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Activity重新创建，它将接收由第一个Activity创建的相同的MyViewModel实例。当持有ViewModel的Activity finish后，框架将调用ViewModel对象的onCleared()方法，以便它可以清理资源。</p><p><strong>警告：ViewModel绝不能引用视图，生命周期或可能持有对活动上下文的引用的任何类。</strong></p><p><a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>对象被设计为脱离视图或LifecycleOwners的特定实例。这种设计还意味着您可以更轻松地编写测试来覆盖ViewModel，因为它不知道视图和生命周期对象。ViewModel对象可以包含LifecycleObservers，例如LiveData对象。但是，ViewModel对象绝不能观察对生命周期感知的可观察对象（如LiveData对象）的更改。如果ViewModel需要应用程序上下文（例如查找系统服务），那么它可以扩展AndroidViewModel类并具有构造函数，该构造函数在构造函数中接收Application，因为Application类扩展了Context。</p><h3 id="ViewMode的生命周期"><a href="#ViewMode的生命周期" class="headerlink" title="ViewMode的生命周期"></a>ViewMode的生命周期</h3><p>ViewModel对象的范围是在获取ViewModel时传递给<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModelProvider.html" target="_blank" rel="noopener">ViewModelProvider</a>的生命周期。ViewModel保留在内存中，直到生命周期的范围永久消失：在一个Activity的情况下，finish()时，在一个Fragment的情况下，当它被detached(分离)时。</p><p>图1说明了一个Activity在进行一次旋转然后finish后的各种生命周期状态。该图还显示了相关Activity生命周期旁边ViewModel的生命周期。这个特定的图表说明了一个Activity的状态。这些相同的基本状态同样适用于Fragment的生命周期。<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180702/KjKH5m6E8m.png?imageslim" alt="mark"></p><p>系统首次调用Activity对象的onCreate()方法时，通常会请求<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>。系统可能会在整个Activity的生命周期中多次调用onCreate()，例如当设备屏幕旋转时。<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>从第一次请求<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>直到Activity finished 和销毁时一直存在。</p><h3 id="在片段之间共享数据"><a href="#在片段之间共享数据" class="headerlink" title="在片段之间共享数据"></a>在片段之间共享数据</h3><p>Activity中的两个或更多fragment需要彼此进行通信是很常见的。想象一下，主-从关系的F让给met的一种常见情况，其中有一个Fragment，用户从列表中选择一个项目，另一个fragment显示所选项目的内容。这种情况有些麻烦，因为这两个片段都需要定义一些接口描述，并且所有者Activity必须将两者绑定在一起。此外，这两个fragment必须处理其他fragment尚未创建或可见的场景。</p><p>可以使用ViewModel对象解决这个常见的痛点。这些fragment可以使用其Activity范围共享ViewModel来处理此通信，如以下示例代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MutableLiveData</span>&lt;<span class="type">Item</span>&gt; selected = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="type">Item</span>&gt;();</span><br><span class="line"></span><br><span class="line">    public void select(<span class="type">Item</span> item) &#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">LiveData</span>&lt;<span class="type">Item</span>&gt; getSelected() &#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SharedViewModel</span> model;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        model = <span class="type">ViewModelProviders</span>.of(getActivity()).get(<span class="type">SharedViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="type">SharedViewModel</span> model = <span class="type">ViewModelProviders</span>.of(getActivity()).get(<span class="type">SharedViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line">        model.getSelected().observe(<span class="keyword">this</span>, item -&gt; &#123;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在获取ViewModelProvider时，这两个Fragment都使用getActivity()。因此，两个Fragment 都接收相同的SharedViewModel实例，该实例的范围限定为Activity。<br>这种方法具有以下优点：</p><ul><li><p>Activity不需要做任何事情，也不需要了解这种沟通。</p></li><li><p>除了SharedViewModel约定之外，fragment不需要彼此了解。如果其中一个fragment消失，另一个fragment继续照常工作。</p></li><li><p>每个片fragment都有其自己的生命周期，并且不受其他生命周期的影响。如果一个fragment替换另一个fragment，UI将继续工作而不会出现任何问题。</p></li></ul><h3 id="用ViewModel替换Loaders"><a href="#用ViewModel替换Loaders" class="headerlink" title="用ViewModel替换Loaders"></a>用ViewModel替换Loaders</h3><p>像<a href="https://developer.android.google.cn/reference/android/content/CursorLoader.html" target="_blank" rel="noopener">CursorLoader</a>这样的Loader类经常用于保持应用程序UI中的数据与数据库同步。您可以使用ViewModel和其他几个类来替换Loaders。使用ViewModel将您的UI控制器与数据加载操作分开，这意味着您在类之间的强引用减少了。</p><p>在使用loaders的一种常见方法中，应用程序可能使用CursorLoader来观察数据库的内容。当数据库中的值发生更改时，加载程序会自动触发重新加载数据并更新UI：<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180702/akE7BEdHC6.png?imageslim" alt="mark"><br><strong>图2.使用加载器加载数据</strong></p><p>ViewModel与Room和LiveData一起使用来替换Loaders。ViewModel可确保数据在设备配置更改后仍然存在。当数据库发生更改时，Room会通知您的LiveData，而LiveData则会用修改的数据更新您的UI。<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180702/aIAdcEJ71B.png?imageslim" alt="mark"><br><strong>图3.使用ViewModel加载数据</strong></p><p><a href="https://medium.com/google-developers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4" target="_blank" rel="noopener">此博客文章</a>描述了如何将ViewModel与LiveData一起使用来替换<a href="https://developer.android.google.cn/reference/android/content/AsyncTaskLoader.html" target="_blank" rel="noopener">AsyncTaskLoader</a>。</p><p>随着你的数据变得越来越复杂，你可能会选择一个单独的类来加载数据。ViewModel的目的是封装UI控制器的数据，以使数据不受配置更改的影响。有关如何跨配置更改加载，保留和管理数据的信息，请参阅<a href="https://developer.android.google.cn/topic/libraries/architecture/saving-states.html" target="_blank" rel="noopener">保存UI状态</a>。</p><p><a href="https://developer.android.google.cn/topic/libraries/architecture/guide.html#fetching_data" target="_blank" rel="noopener">Android App Architecture指南</a>建议构建一个存储库类来处理这些功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ViewModel概述&quot;&gt;&lt;a href=&quot;#ViewModel概述&quot; class=&quot;headerlink&quot; title=&quot;ViewModel概述&quot;&gt;&lt;/a&gt;ViewModel概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>架构组件——Lifecycle详解</title>
    <link href="http://yoursite.com/2018/06/27/android/%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Lifecycle%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/06/27/android/架构组件——Lifecycle详解/</id>
    <published>2018-06-27T08:58:43.000Z</published>
    <updated>2018-06-27T09:09:15.881Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、Lifecycle介绍"><a href="#1、Lifecycle介绍" class="headerlink" title="1、Lifecycle介绍"></a>1、Lifecycle介绍</h4><p>lifecycle官方文档地址：<br><a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">https://developer.android.com/topic/libraries/architecture/lifecycle</a></p><h5 id="为什么要使用lifecycle？"><a href="#为什么要使用lifecycle？" class="headerlink" title="为什么要使用lifecycle？"></a>为什么要使用lifecycle？</h5><blockquote><p>activity 和fragment 是有声明周期的，有时候，我们的很多操作需要写在声明周期的方法中，比如，下载，文件操作等，这样很多情况下回导致，我们在activity中的声明周期方法中写越来越多的代码，activity或者fragment 越来越臃肿，代码维护越来越困难。 使用lifecycle就可以很好的解决这类问题。<br>lifecycle代码简洁，我们可以通过实现LifecycleObserver 接口，来监听声明周期，然后我们在activity和fragment中去注册监听。</p></blockquote><h4 id="2、几个重要的类和接口"><a href="#2、几个重要的类和接口" class="headerlink" title="2、几个重要的类和接口"></a>2、几个重要的类和接口</h4><ul><li><p><strong>Lifecycle</strong><br> Lifecycle是一个持有组件生命周期状态（如Activity或Fragment）的信息的类，并允许其他对象观察此状态。</p></li><li><p><strong>Event</strong> ：从框架和Lifecycle类派发的生命周期事件。这些事件映射到活动和片段中的回调事件。</p></li><li><p><strong>State</strong> ：由Lifecycle对象跟踪的组件的当前状态。</p></li><li><strong>LifecycleOwner</strong> （重要）Lifecycle持有者</li><li><p>实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</p></li><li><p><strong>LifecycleObserver</strong>（重要）Lifecycle观察者</p></li><li>实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。</li></ul><h4 id="3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver-的使用"><a href="#3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver-的使用" class="headerlink" title="3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver 的使用"></a>3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver 的使用</h4><h5 id="（1）LifecycleOwner（生命周期持有者接口）"><a href="#（1）LifecycleOwner（生命周期持有者接口）" class="headerlink" title="（1）LifecycleOwner（生命周期持有者接口）"></a>（1）LifecycleOwner（生命周期持有者接口）</h5><blockquote><p>官网介绍：<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>是一个单一的方法接口，表示该类有一个 <a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>。它有一个方法，<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner#getLifecycle%28%29" target="_blank" rel="noopener">getLifecycle()</a>这个方法 必须由这个类来实现。如果您试图管理整个应用程序进程的生命周期，请参阅 <a href="https://developer.android.com/reference/android/arch/lifecycle/ProcessLifecycleOwner" target="_blank" rel="noopener">ProcessLifecycleOwner</a>。该接口从各个类（如Fragment和AppCompatActivity）抽象生命周期的所有权，并允许编写与它们一起工作的组件。<br>任何自定义应用程序类都可以实现LifecycleOwner接口<br>实现LifecycleObserver的组件与实现LifecycleOwner的组件无缝协作，因为所有者可以提供生命周期，观察者可以注册以观看</p></blockquote><p>简单来说，LifecycleOwner就是一个接口，谁继承了它，就持有了lifecycle对象。然后就可以调用getLifecycle()方法获取继承了抽象类Lifecycle的LifecycleRegistry，然后调用 addObserver(@NonNull LifecycleObserver observer) 方法来注册监听。<br>这样，<strong>该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</strong></p><p><strong>注意：Support Library 26.1.0 及其以后的版本，Activity 和Fragment 已经实现了LifecycleOwner 接口，所以，我们可以直接在Activity 和Fragment中使用getLifecycle()方法来获取lifecycle对象，来添加观察者监听。</strong></p><h5 id="（2）LifecycleObserver（生命周期观察者接口）"><a href="#（2）LifecycleObserver（生命周期观察者接口）" class="headerlink" title="（2）LifecycleObserver（生命周期观察者接口）"></a>（2）LifecycleObserver（生命周期观察者接口）</h5><blockquote><p>LifecycleObserver 是一个观察者接口，实现了它，可以通过注解或者继承的方式，来管理声明周期的监听。只要在持有lifecycle的类中注册了它，当声明周期发生变化时，它就能收到，进行我们自定义的操作。</p></blockquote><p>两种实现方式：</p><pre><code>1. 实现DefultLifecyceObserver接口，然后重写里面生命周期方法；2. 直接实现LifecycleObserver接口，然后通过注解的方式来接收生命周期的变化；</code></pre><p><strong>Lifecycle.java文档中是建议使用第一种方式，因为文档中说明了，随着Java8成为主流，注解的方式会被弃用。DefaultLifecycleObserver是需要另外声明的java8 比如下面</strong><br>GenericLifecycleObserver，FullLifecycleObserver，DefaultLifecycleObserver 这三个接口都是直接或者间接继承的LifecycleObserver</p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 如果使用的是java 8要显示声明如下的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lifecycle_version</span> </span>= <span class="string">"1.1.1"</span></span><br><span class="line">implementation <span class="string">"android.arch.lifecycle:common-java8:$lifecycle_version"</span></span><br></pre></td></tr></table></figure><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180626/DJk2i4fhm9.png" alt="mark"> </p><h4 id="3、开始使用Lifecycle"><a href="#3、开始使用Lifecycle" class="headerlink" title="3、开始使用Lifecycle"></a>3、开始使用Lifecycle</h4><p>我们写个测试代码，首先，我们要测试一下，到底LifecycleObserver到底能不能监听到声明周期的变化。并且实验下上图中的声明周期状态<br>先写两个简单的Activity，FirstActivity 和SecondActivity, 单纯的一个跳转。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Button</span> firstBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> <span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.first_activity_layout);</span><br><span class="line">        initView();</span><br><span class="line">        initListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initView() &#123;</span><br><span class="line">        firstBtn = findViewById(<span class="type">R</span>.id.first_btn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initListener() &#123;</span><br><span class="line">        firstBtn.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onClick(<span class="type">View</span> v) &#123;</span><br><span class="line">                <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="type">FirstActivity</span>.<span class="keyword">this</span>, <span class="type">SecondActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们要做的是要写一个需要拥有声明周期的类，正常我们自定义控件啊，或者做其他逻辑的类，是没有声明周期的，现在有了LifecycleObserver,我们可以让一个普通的类拥有感知声明周期变化的能力。比如，现在自定义一个，MyObserver类。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class MyObserver implements DefaultLifecycleObserver&#123;</span><br><span class="line">   <span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"MyListener"</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onCreate(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onCreate()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onStart(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onStart()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onResume(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onResume()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onPause(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onPause()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onStop(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onStop()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onDestroy(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onDestroy() "</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们采取的是，直接继承DefaultLifecycleObserver接口，来实现它所有的方法。我们在里面做了log,来查看，是否这个类，收到了activity声明周期的变化。<br>然后，要做的就是<strong>注册监听</strong><br>在Activity 的OnCreate方法中，调用getLifecycle();</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Button</span> firstBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> <span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.first_activity_layout);</span><br><span class="line">        initView();</span><br><span class="line">        initListener();</span><br><span class="line">        <span class="comment">//添加了这一行代码</span></span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="type">MyObserver</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initView() &#123;</span><br><span class="line">        firstBtn = findViewById(<span class="type">R</span>.id.first_btn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initListener() &#123;</span><br><span class="line">        firstBtn.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onClick(<span class="type">View</span> v) &#123;</span><br><span class="line">                <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="type">FirstActivity</span>.<span class="keyword">this</span>, <span class="type">SecondActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，api26,.1以后，Activity中可以直接 getLifecycle().addObserver(new MyObserver()); 这样，就已经注册了声明周期观察者的监听。运行查看log<br>启动FirstActivity后，MyObserver类已经监听到了Activity的声明周期方法<br>并且，和图中表示一致，各个声明周期方法对应相应的节点。一定要清楚，后面会用到。比如，onResume()方法执行后，Activity处于RESUME状态，我们可以通过判断这个状态来做一些事情<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/cD74jCJ522.png?imageslim" alt="mark"><br>点击跳转到SecondActivity<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/7A8Ia38Kb2.png?imageslim" alt="mark"><br>可以看到，FirstActivity声明周期走了onPause  onStop，MyObserver也成功监听到了，继续返回FirstActivity<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/dB5fkImjbE.png?imageslim" alt="mark"><br>最后，点击返回键，退出FirstActivity，<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/8lIlKAejLF.png?imageslim" alt="mark"></p><p>通过这个简单的小例子，我们看到了 我们的类，只要实现了 LifecycleObserver接口，然后，在Activity 或者Fragment中 通过getLifecycle().addObserver()方法，把这个类的对象传入，就可以实现声明周期的感应监听。</p><p>当然，我们可以再初始化这个类的时候，把Lifecycle对象传入，那我们自定义的类就可以自己去管理声明周期，而不依赖activity或者fragment。 这样，activity在使用此类的时候就不必关系声明周期的问题，因为，在这个类里面我们已经处理了。比如： 给MyObserver类 添加一个构造方法，传入一个Lifecycle对象。</p><p><strong>要注意的是：</strong><br>生命周期状态为<strong>RESUMED</strong>时表示，当前activity 是在前台，并且可交互也就是onResume()执行后</p><p>生命周期状态为<strong>STARTED</strong>时，表示当前activity处于可见但是不可交互，也就是onStart()方法刚执行完或者onPause()方法刚执行完的状态</p><p>生命周期状态为<strong>CREATED</strong>,表示onCreate()方法刚刚执行完或者onStop()方法刚刚执行完，也就是当前activity不在前台，但是也没有处于销毁状态。</p><p>生命周期状态为<strong>DESTORYED</strong>,表示当前Activity还不存在，没有被创建或者已经销毁，我们通常考虑比较多的就是，onDestory()方法执行后，当前Activity已经销毁。</p><p>所以，如果我们要保证在Activity或者Fragment的有效生命周期内进行的操作，必须判断，<strong>当前lifecycle的状态是否至少是CREATED状态</strong>，避免Activity或者fragment销毁了以后，回调或者网络请求才回来，此时做一些操作会导致异常。</p><p>添加以下代码，就是我们把lifecycle对象传给观察者，让它自己去判断回调后的代码，保证至少是CREATED状态<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Lifecycle lifecycle;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Lifecycle lifecycle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//然后再相应的回调方法中使用下面代码判断，保证数据回调回来，当前activity是存在的</span></span><br><span class="line">    <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(CREATED)) &#123;</span><br><span class="line">            <span class="comment">//这里只是示例，不一定是CREATED</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里用到了Lifecycle类的方法，下面我们看一下Lifecycle的源码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> &#123;</span></span><br><span class="line">    <span class="meta">@MainThread</span>  <span class="comment">//添加将在LifecycleOwner更改状态时通知的LifecycleObserver。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> addObserver(<span class="meta">@NonNull</span> LifecycleObserver observer);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span> <span class="comment">//从观察者列表中删除给定的观察者。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> removeObserver(<span class="meta">@NonNull</span> LifecycleObserver observer);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span> <span class="comment">//返回生命周期的当前状态。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> State getCurrentState();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        ON_CREATE,<span class="comment">//用于onCreate事件的常量LifecycleOwner。</span></span><br><span class="line"></span><br><span class="line">        ON_START,</span><br><span class="line"></span><br><span class="line">        ON_RESUME,</span><br><span class="line"></span><br><span class="line">        ON_PAUSE,</span><br><span class="line"></span><br><span class="line">        ON_STOP,</span><br><span class="line"></span><br><span class="line">        ON_DESTROY,</span><br><span class="line"></span><br><span class="line">        ON_ANY <span class="comment">//一个Event可以用来匹配所有事件的常数。 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED, <span class="comment">//LifecycleOwner的初始化状态。 </span></span><br><span class="line">        CREATED, </span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line"><span class="comment">//比较此状态是否大于或等于给定值state。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isAtLeast(<span class="meta">@NonNull</span> State state) &#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marks a class as a LifecycleObserver. It does not have any methods, instead, relies on</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> OnLifecycleEvent&#125; annotated methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Lifecycle Lifecycle - for samples and usage patterns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleObserver</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个抽象类，注释已经很详细了，应该不用解释了</p><p>最后借用下官网的-生命周期感知组件的最佳实战</p><pre><code>1. 尽可能保持您的UI控制器（活动和片段）尽可能精简。他们不应该试图获取他们自己的数据;相反，使用[ViewModel](https://developer.android.com/reference/android/arch/lifecycle/ViewModel)来做到这一点，并观察一个LiveData对象来反映更改回视图。2. 尝试编写数据驱动的用户界面，其中您的用户界面控制器的职责是在数据更改时更新视图，或将用户操作通知给ViewModel。3. 把你的数据逻辑放在[ViewModel](https://developer.android.com/reference/android/arch/lifecycle/ViewModel)类中。ViewModel应作为您的UI控制器和其他应用程序之间的连接器。但要小心，ViewModel不负责提取数据（例如，来自网络）。相反，ViewModel应调用相应的组件来获取数据，然后将结果提供给UI控制器。4. 使用[dataBinding](https://developer.android.com/topic/libraries/data-binding/)在视图和UI控制器之间保持干净的界面。这使您可以使您的视图更具说明性，并最大限度地减少需要在活动和片段中编写的更新代码。   如果你喜欢用Java编程语言来做到这一点，可以使用像Butter Knife这样的库来避免样板代码并且有更好的抽象。5. 如果您的UI很复杂，请考虑创建一个演示者类（[presenter](http://www.gwtproject.org/articles/mvp-architecture.html#presenter)）来处理UI修改。这可能是一项艰巨的任务，但它可以使您的UI组件更易于测试。6. 避免在ViewModel中引用View或Activity上下文。   如果ViewModel超出活动（在配置更改的情况下），则活动会泄漏并且垃圾收集器无法正确处理。</code></pre><p>借用下<a href="https://blog.csdn.net/zhuzp_blog/article/details/78871374" target="_blank" rel="noopener">https://blog.csdn.net/zhuzp_blog/article/details/78871374</a>  作者的两张图，更清晰，对于相信信息，可到作者博客去查看相关讲解<br><img src="https://img-blog.csdn.net/20180531152720780?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180531152910152?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、Lifecycle介绍&quot;&gt;&lt;a href=&quot;#1、Lifecycle介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Lifecycle介绍&quot;&gt;&lt;/a&gt;1、Lifecycle介绍&lt;/h4&gt;&lt;p&gt;lifecycle官方文档地址：&lt;br&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件官方文档02——LiveData</title>
    <link href="http://yoursite.com/2018/06/27/android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A302%E2%80%94%E2%80%94LiveData/"/>
    <id>http://yoursite.com/2018/06/27/android/Android架构组件官方文档02——LiveData/</id>
    <published>2018-06-27T03:33:09.000Z</published>
    <updated>2018-06-27T03:38:02.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LiveData概述"><a href="#LiveData概述" class="headerlink" title="LiveData概述"></a>LiveData概述</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>是一个可观察的数据持有者类。<br>与常规可观察性不同，LiveData具有生命周期感知能力，这意味着它尊重其他应用程序组件（例如活动，片段或服务）的生命周期。<br>这种感知确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。<br>注意：要将LiveData组件导入到Android项目中，请参阅向项目<a href="https://developer.android.com/topic/libraries/architecture/adding-components.html#lifecycle" target="_blank" rel="noopener">添加组件</a>。<br>如果观察者的生命周期处于<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#STARTED" target="_blank" rel="noopener">STARTED</a>或<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#RESUMED" target="_blank" rel="noopener">RESUMED</a>状态，则LiveData会将<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html" target="_blank" rel="noopener">Observer</a>类表示的观察者视为活动状态。<br><a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>仅通知处于活跃状态的观察者更新。<br>未注册观看<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>对象的非活跃期的观察者不会收到有关更改的通知。</p><p>您可以注册与实现LifecycleOwner接口的对象配对的观察者。此关系允许在相应生命周期对象的状态更改为DESTROYED时删除观察者。<br>这对于活动和片段尤其有用，因为它们可以安全地观察LiveData对象，而不必担心泄漏 - 在其生命周期被破坏时，活动和片段会立即取消订阅。</p><p>有关如何使用LiveData的更多信息，请参阅使用LiveData对象</p><h3 id="使用LiveData的优点"><a href="#使用LiveData的优点" class="headerlink" title="使用LiveData的优点"></a>使用LiveData的优点</h3><p>使用LiveData提供以下优点：<br><strong>确保您的UI界面符合您UI数据状态</strong></p><blockquote><p>LiveData遵循观察者模式。<br>当生命周期状态改变时，LiveData会通知Observer对象。<br>您可以合并代码以更新这些Observer对象中的UI。<br>每次应用程序数据更改时，您的观察者都可以在每次更改时更新UI，而不是每次更新UI。<br><strong>没有内存泄漏</strong><br>观察者绑定到<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.html" target="_blank" rel="noopener">Lifecycle</a>对象，并在其相关生命周期被破坏后自行清理。</p></blockquote><p><strong>不会因为活动停止而崩溃</strong></p><blockquote><p>如果观察者的生命周期处于非活动状态，例如在后退堆栈中的活动，则它不会收到任何LiveData事件。</p></blockquote><p><strong>没有更多的手动声明周期处理</strong><br>UI组件只是观察相关数据，不停止或恢复观察。<br>LiveData自动管理所有这些，因为它在观察时意识到相关的生命周期状态更改。<br><strong>始终保持最新的数据</strong><br>如果生命周期变为非活动状态，它将在再次变为活动状态时收到最新数据。例如，后台活动在返回到前台后立即收到最新数据。<br><strong>正确的配置更改</strong><br>如果由于配置更改（如设备旋转）而重新创建活动或片段，它会立即收到最新的可用数据。<br><strong>共享资源</strong><br>您可以使用单例模式扩展LiveData对象以包装系统服务，以便它们可以在应用程序中共享。<br>LiveData对象连接到系统服务一次，然后任何需要该资源的观察者都可以观看LiveData对象。<br>有关更多信息，请参阅扩展LiveData。</p><h3 id="使用LiveData对象"><a href="#使用LiveData对象" class="headerlink" title="使用LiveData对象"></a>使用LiveData对象</h3><p>按照以下步骤操作LiveData对象：</p><ol><li>创建一个LiveData实例来保存某种类型的数据。这通常在您的<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>类中完成。</li><li>创建一个<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html" target="_blank" rel="noopener">Observer</a>对象，该对象定义<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html#onChanged%28T%29" target="_blank" rel="noopener">onChanged</a>()方法，该方法控制LiveData对象保存的数据更改时发生的情况。您通常在UI控制器中创建Observer对象，如活动或片段。</li><li>使用observe()方法将Observer对象附加到LiveData对象。observe()方法使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner.html" target="_blank" rel="noopener">LifecycleOwner</a>对象。这将Observer对象订阅到LiveData对象，以便通知其更改。您通常将Observer对象附加到UI控制器中，例如Activity或Fragment。</li></ol><blockquote><p><strong>注意：您可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#observeForever%28android.arch.lifecycle.Observer%3CT%3E%29" target="_blank" rel="noopener">observeForever（Observer）</a>方法注册一个没有关联的LifecycleOwner对象的观察器。在这种情况下，观察者被认为始终处于活动状态，因此总是通知修改。您可以删除这些观察者调用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#removeObserver%28android.arch.lifecycle.Observer%3CT%3E%29" target="_blank" rel="noopener">removeObserver（Observer）</a>方法。</strong></p></blockquote><p>当您更新存储在LiveData对象中的值时，只要附加的LifecycleOwner处于活动状态，它就会触发所有已注册的观察者。<br>LiveData允许UI控制器观察者订阅更新。当LiveData对象持有的数据更改时，UI会自动更新以作为响应。</p><h4 id="创建LiveData对象"><a href="#创建LiveData对象" class="headerlink" title="创建LiveData对象"></a>创建LiveData对象</h4><p>LiveData是一个可用于任何数据的包装器，包括实现集合的对象（如List）。LiveData对象通常存储在ViewModel对象中，并通过getter方法访问，如以下示例所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NameViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a LiveData with a String</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">MutableLiveData</span>&lt;<span class="type">String</span>&gt; mCurrentName;</span><br><span class="line"></span><br><span class="line">    public <span class="type">MutableLiveData</span>&lt;<span class="type">String</span>&gt; getCurrentName() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurrentName == <span class="literal">null</span>) &#123;</span><br><span class="line">            mCurrentName = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="type">String</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mCurrentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rest of the ViewModel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初，LiveData对象中的数据未设置。</p><blockquote><p>注意：由于以下原因，请确保存储更新<strong>ViewModel</strong>对象中的UI的<strong>LiveData</strong>对象，而不是活动或片段：</p><ul><li>避免臃肿的活动和碎片。现在这些UI控制器负责显示数据但不保存数据状态。</li><li>将<strong>LiveData</strong>实例与特定活动或片段实例分离，并允许<strong>LiveData</strong>对象保留配置更改。</li></ul></blockquote><p>您可以在<strong><a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank" rel="noopener">ViewModel指南</a></strong>中了解更多关于ViewModel类的好处和用法。</p><h4 id="观察LiveData对象"><a href="#观察LiveData对象" class="headerlink" title="观察LiveData对象"></a>观察LiveData对象</h4><p>在大多数情况下，出于以下原因，应用程序组件的onCreate()方法是开始观察LiveData对象的正确位置：</p><ol><li>确保系统不会从Activity或fragment的onResume（）方法进行多余的调用。</li><li>确保Activity或Fragment<strong>具有</strong>一旦它变为活动状态即可显示的<strong>数据</strong>。只要应用程序组件处于<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#STARTED" target="_blank" rel="noopener">STARTED</a>状态，它就会从它所观察的LiveData对象中接收最新的值。这只会在设置要观察的LiveData对象时才会发生。</li></ol><p>通常，LiveData仅在数据更改时传递更新，并且仅传递给活动观察者。此行为的一个例外是，观察者在从非活动状态变为活动状态时也会收到更新。此外，如果观察者第二次从非激活状态变为激活状态，则只有在自上一次变为活动状态以来该值发生变化时才会收到更新。</p><p>以下示例代码说明了如何开始观察LiveData对象：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NameActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">NameViewModel</span> mModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Other code to setup the activity...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the ViewModel.</span></span><br><span class="line">        mModel = <span class="type">ViewModelProviders</span>.of(<span class="keyword">this</span>).get(<span class="type">NameViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the observer which updates the UI.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Observer</span>&lt;<span class="type">String</span>&gt; nameObserver = <span class="keyword">new</span> <span class="type">Observer</span>&lt;<span class="type">String</span>&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onChanged(<span class="meta">@Nullable</span> <span class="keyword">final</span> <span class="type">String</span> newName) &#123;</span><br><span class="line">                <span class="comment">// Update the UI, in this case, a TextView.</span></span><br><span class="line">                mNameTextView.setText(newName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.</span></span><br><span class="line">        mModel.getCurrentName().observe(<span class="keyword">this</span>, nameObserver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用nameObserver作为参数传递<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#observe%28android.arch.lifecycle.LifecycleOwner,android.arch.lifecycle.Observer%3CT%3E%29" target="_blank" rel="noopener">observe()</a>后，立即调用<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html#onChanged%28T%29" target="_blank" rel="noopener">onChanged()</a>，以提供存储在mCurrentName中的最新值。如果LiveData对象未在mCurrentName中设置值，则不调用onChanged()。</p><h4 id="更新LiveData对象"><a href="#更新LiveData对象" class="headerlink" title="更新LiveData对象"></a>更新LiveData对象</h4><p>LiveData没有公开可用的方法来更新存储的数据。<a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html" target="_blank" rel="noopener">MutableLiveData</a>类公开公开<a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#setValue%28T%29" target="_blank" rel="noopener">setValue(T)</a>和<a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#postValue%28T%29" target="_blank" rel="noopener">postValue(T)</a>方法，如果需要编辑存储在LiveData对象中的值，则必须使用这些方法。通常在ViewModel中使用MutableLiveData，然后ViewModel只向观察者公开不可变的LiveData对象。<br>在建立观察者关系后，可以更新LiveData对象的值，如以下示例所示，当用户点击按钮时触发所有观察者：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String anotherName = <span class="string">"John Doe"</span>;</span><br><span class="line">        mModel.getCurrentName().setValue(anotherName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在示例中调用setValue（T）会导致观察者用值John Doe调用它们的onChanged（）方法。该示例显示按钮按下，但setValue（）或postValue（）可能因多种原因被调用来更新mName，包括响应网络请求或数据库加载完成;在所有情况下，调用setValue（）或postValue（）都会触发观察者并更新UI。</p><blockquote><p>注意：您必须调用setValue（T）方法来更新主线程中的LiveData对象。如果代码在工作线程中执行，则可以使用postValue（T）方法更新LiveData对象。</p></blockquote><h4 id="与Room一起使用LiveData"><a href="#与Room一起使用LiveData" class="headerlink" title="与Room一起使用LiveData"></a>与Room一起使用LiveData</h4><p><a href="https://developer.android.com/training/data-storage/room/index.html" target="_blank" rel="noopener">Room</a>持久性库支持返回<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>对象的可观察查询。可观察查询是作为数据库访问对象（DAO）的一部分写入的。</p><p>当更新数据库时，会生成所有必要的代码以更新LiveData对象。生成的代码在需要时在后台线程上异步运行查询。这种模式对于保持UI中显示的数据与存储在数据库中的数据保持同步很有用。您可以在<a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank" rel="noopener">Room持久库指南</a>中阅读关于Room和DAO的更多信息。</p><h3 id="扩展LiveData"><a href="#扩展LiveData" class="headerlink" title="扩展LiveData"></a>扩展LiveData</h3><p>如果观察者的生命周期处于<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#STARTED" target="_blank" rel="noopener">STARTED</a>或<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#RESUMED" target="_blank" rel="noopener">RESUMED</a>状态，则<strong>LiveData</strong>将认为观察者处于活动状态。以下示例代码说明了如何扩展<strong>LiveData</strong>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StockManager mStockManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePriceListener mListener = <span class="keyword">new</span> SimplePriceListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPriceChanged</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">            setValue(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockLiveData</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        mStockManager = <span class="keyword">new</span> StockManager(symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.requestPriceUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.removeUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本示例中的价格监听器的实现包括以下重要方法：</p><ul><li><p>当LiveData对象具有处于活跃期的观察者时，将调用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#onActive%28%29" target="_blank" rel="noopener">onActive（）</a>方法。这意味着您需要开始观察此方法的价格更新。</p></li><li><p>当LiveData对象没有任何active期间的观察者时，将调用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#onInactive%28%29" target="_blank" rel="noopener">onInactive（）</a>方法。由于没有观察员在监听，因此没有理由保持连接到StockManager服务。</p></li><li><a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#setValue%28T%29" target="_blank" rel="noopener">setValue（T）</a>方法更新LiveData实例的值并通知任何活跃的观察者有关更改。</li></ul><p>您可以使用StockLiveData类如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void onActivityCreated(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        <span class="type">LiveData</span>&lt;<span class="type">BigDecimal</span>&gt; myPriceListener = ...;</span><br><span class="line">        myPriceListener.observe(<span class="keyword">this</span>, price -&gt; &#123;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>observe（）方法将把实现了LifecycleOwner实例的Fragment作为第一个参数传递。这样做表示此观察者被绑定到与所有者关联的生命周期对象，这意味着：</p><ul><li>如果生命周期对象不处于活跃状态，则即使值发生更改，也不会调用观察者。</li><li>生命周期对象被销毁后，观察者被自动删除。t<br>LiveData对象支持生命周期意味着您可以在多个Activity，Fragment和Service之间共享它们。为了保持示例简单，您可以按如下方式将LiveData类实现为单例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StockLiveData sInstance;</span><br><span class="line">    <span class="keyword">private</span> StockManager mStockManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePriceListener mListener = <span class="keyword">new</span> SimplePriceListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPriceChanged</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">            setValue(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StockLiveData <span class="title">get</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> StockLiveData(symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StockLiveData</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        mStockManager = <span class="keyword">new</span> StockManager(symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.requestPriceUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.removeUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以再Fragment中使用它，如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void onActivityCreated(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="type">StockLiveData</span>.get(getActivity()).observe(<span class="keyword">this</span>, price -&gt; &#123;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个Fragment和Activity可以观察MyPriceListener实例。如果LiveData只有一个或多个可见并处于活动状态，则LiveData仅连接到系统服务。</p><h3 id="转换LiveData"><a href="#转换LiveData" class="headerlink" title="转换LiveData"></a>转换LiveData</h3><p>您可能希望在LiveData更改为观察者之前更改存储在LiveData对象中的，或者您可能需要基于另一个LiveData实例的值返回不同的LiveData实例。Lifecycle软件包提供Transformations类，其中包括支持这些场景的帮助方法。<br><strong><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#map%28android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20Y%3E%29" target="_blank" rel="noopener">Transformations.map()</a></strong><br>在存储在LiveData对象中的值上使用函数，并向下游传播结果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LiveData&lt;User&gt; userLiveData = <span class="built_in">..</span>.;</span><br><span class="line">LiveData&lt;String&gt; userName = Transformations.map(userLiveData,<span class="built_in"> user </span>-&gt; &#123;</span><br><span class="line">    user.name + <span class="string">" "</span> + user.lastName</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations#switchMap%28android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20android.arch.lifecycle.LiveData%3CY%3E%3E%29" target="_blank" rel="noopener">Transformations.switchMap()</a></strong></p><p>与map（）类似，将函数应用于存储在LiveData对象中的值，并展开并向下游分派结果。传递给switchMap（）的函数必须返回一个LiveData对象，如下例所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private LiveData&lt;User&gt; getUser(String id) &#123;</span><br><span class="line">  <span class="built_in">..</span>.;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveData&lt;String&gt; userId = <span class="built_in">..</span>.;</span><br><span class="line">LiveData&lt;User&gt;<span class="built_in"> user </span>= Transformations.switchMap(userId, id -&gt; getUser(id) );</span><br></pre></td></tr></table></figure><p>您可以使用转换方法在观察者的生命周期中传递信息。除非观察者正在观察返回的LiveData对象，否则不会计算转换。由于转换是懒加载的，因此与生命周期相关的行为会隐式传递，而不需要额外的显式调用或依赖关系。</p><p>如果您认为您需要ViewModel对象中的Lifecycle对象，则转换可能是更好的解决方案。例如，假设您有一个接受地址并返回该地址的邮政编码的UI组件。您可以为此组件实现native的ViewModel，如以下示例代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PostalCodeRepository</span> repository;</span><br><span class="line">    public <span class="type">MyViewModel</span>(<span class="type">PostalCodeRepository</span> repository) &#123;</span><br><span class="line">       <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">LiveData</span>&lt;<span class="type">String</span>&gt; getPostalCode(<span class="type">String</span> address) &#123;</span><br><span class="line">       <span class="comment">// DON'T DO THIS</span></span><br><span class="line">       <span class="keyword">return</span> repository.getPostCode(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，postalCode是public的和fina的，因为该字段永远不会改变。postalCode字段定义为addressInput的转换，这意味着addressInput发生更改时将调用repository.getPostCode（）方法。如果存在活动观察者，那么这是真实的，如果在repository.getPostCode（）被调用时没有活跃的观察者，则在添加观察者之前不进行计算。</p><p>该机制允许版本较低的应用程序创建按需延迟计算的LiveData对象。ViewModel对象可以轻松获得对LiveData对象的引用，然后在其上定义转换规则。</p><h4 id="创建新的转换"><a href="#创建新的转换" class="headerlink" title="创建新的转换"></a>创建新的转换</h4><p>有十几种不同的特定转换可能在您的应用中很有用，但它们不是默认提供的。要实现自己的转换，您可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData.html" target="_blank" rel="noopener">MediatorLiveData</a>类，它监听其他<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>对象并处理它们发出的事件。<strong>MediatorLiveData</strong>将其状态正确传播到源<strong>LiveData</strong>对象。要了解有关此模式的更多信息，请参阅<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html" target="_blank" rel="noopener">Transformations</a>类的参考文档。</p><h3 id="合并多个LiveData源"><a href="#合并多个LiveData源" class="headerlink" title="合并多个LiveData源"></a>合并多个LiveData源</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData.html" target="_blank" rel="noopener">MediatorLiveData</a>是<strong>LiveData</strong>的一个子类，允许您合并多个LiveData源。<strong>MediatorLiveData</strong>对象的观察者随后会在任何原始<strong>LiveData</strong>源对象更改时触发。</p><p>例如，如果您的UI中有一个可从本地数据库或网络更新的LiveData对象，则可以将以下资源添加到MediatorLiveData对象：</p><ul><li>与存储在数据库中的数据关联的LiveData对象。</li><li>与从网络访问的数据关联的LiveData对象。<br>您的活动只需观察<strong>MediatorLiveData</strong>对象即可从两个来源接收更新。有关详细示例，请参阅<a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank" rel="noopener">应用程序体系结构指南</a>的附录：<a href="https://developer.android.com/topic/libraries/architecture/guide.html#addendum" target="_blank" rel="noopener">展示网络状态部分</a>。<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3>有关在<a href="https://developer.android.com/training/snackbar" target="_blank" rel="noopener">Snackbar</a>消息，导航事件和其他事件中使用LiveData的其他信息，请<a href="https://medium.com/google-developers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150" target="_blank" rel="noopener">阅读此文章</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LiveData概述&quot;&gt;&lt;a href=&quot;#LiveData概述&quot; class=&quot;headerlink&quot; title=&quot;LiveData概述&quot;&gt;&lt;/a&gt;LiveData概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件官方文档01——Lifecycle</title>
    <link href="http://yoursite.com/2018/06/26/android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A301%E2%80%94%E2%80%94Lifecycle/"/>
    <id>http://yoursite.com/2018/06/26/android/Android架构组件官方文档01——Lifecycle/</id>
    <published>2018-06-26T09:14:34.000Z</published>
    <updated>2018-06-27T03:37:55.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用生命周期感知组件处理生命周期"><a href="#使用生命周期感知组件处理生命周期" class="headerlink" title="使用生命周期感知组件处理生命周期"></a>使用生命周期感知组件处理生命周期</h2><blockquote><p>支持生命周期的组件执行操作以响应另一个组件（例如Activity和fragment）的生命周期状态更改。这些组件可帮助您生成组织性更好，并且通常更轻量的代码，这些代码更易于维护。</p></blockquote><blockquote><p>常见的模式是在Activity和fragment的生命周期方法中实现依赖组件的操作。<br>但是，这种模式导致代码的组织不良以及错误泛滥。通过使用生命周期感知组件，您可以将相关组件的代码从生命周期方法中移出并移入组件本身。</p></blockquote><blockquote><p>android.arch.lifecycle包提供了类和接口，可让您构建支持生命周期的组件，这些组件可根据活动或片段的当前生命周期状态自动调整其行为<br><strong> 注意：要将<a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener">android.arch.lifecycle</a>导入到Android项目中，请参阅<a href="https://developer.android.com/topic/libraries/architecture/adding-components#lifecycle" target="_blank" rel="noopener">向项目添加组件</a>。 </strong></p></blockquote><blockquote><p>Android框架中定义的大多数应用程序组件都附带有生命周期。生命周期由操作系统或您的流程中运行的框架代码管理。它们是Android如何工作和应用程序必须尊重它们的核心。不这样做可能会触发内存泄漏甚至应用程序崩溃。</p></blockquote><p>想象一下，我们有一个在屏幕上显示设备位置的Activity。<br>常见的实现可能如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// connect to system location service</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect from system location service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, (location) -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   尽管这个示例看起来很好，但在实际的应用程序中，您最终会有太多的调用来管理UI和其他组件，以响应当前的生命周期状态。<br>管理多个组件会在生命周期方法中放置大量代码，例如onStart（）和onStop（），这使得它们很难维护。</p><p>此外，无法保证组件在活动或片段停止之前启动。<br>如果我们需要执行一个长时间运行的操作，比如onStart（）中的一些配置检查，情况尤其如此。<br>这可能会导致onStop（）方法在onStart（）之前完成的争用条件，从而使组件的存活时间超过所需的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// what if this callback is invoked AFTER activity is stopped?</span></span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener">android.arch.lifecycle</a>包提供的类和接口可帮助您以弹性和独立的方式解决这些问题。</p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>是一个持有组件生命周期状态（如Activity或Fragment）的信息的类，并允许其他对象观察此状态。<br><a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>使用两个主要枚举来跟踪其关联组件的生命周期状态：</p><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>&emsp;&emsp;从框架和Lifecycle类派发的生命周期事件。<br>&emsp;&emsp;这些事件映射到Activities和fragments中的回调事件。</p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>&emsp;&emsp;由Lifecycle对象跟踪的组件的当前状态。</p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180626/DJk2i4fhm9.png?imageslim" alt="mark"></p><p>将状态视为图中的节点，将事件视为这些节点之间的边界。</p><p>一个类可以通过向其方法添加注解来监视组件的生命周期状态。<br>然后，您可以通过调用Lifecycle类的<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle#addObserver%28android.arch.lifecycle.LifecycleObserver%29" target="_blank" rel="noopener">addObserver（）</a>方法并传递观察者的实例来添加观察者，如下例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">MyObserver</span> <span class="selector-tag">implements</span> <span class="selector-tag">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="variable">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    public void connectListener() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    public void disconnectListener() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">myLifecycleOwner</span><span class="selector-class">.getLifecycle</span>()<span class="selector-class">.addObserver</span>(new MyObserver());</span><br></pre></td></tr></table></figure><p>在上面的例子中，myLifecycleOwner对象实现了<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>接口，这将在下一节中介绍。</p><h3 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>是一个单一的方法接口，表示该类有一个<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>。<br>它有一个方法<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner#getLifecycle%28%29" target="_blank" rel="noopener">getLifecycle（）</a>，它必须由class实现。<br>如果您试图管理整个应用程序进程的生命周期，请参阅<a href="https://developer.android.com/reference/android/arch/lifecycle/ProcessLifecycleOwner" target="_blank" rel="noopener">ProcessLifecycleOwner</a>。</p><p>该接口从各个类（如Fragment和AppCompatActivity）抽象生命周期的所有权，并允许编写与它们一起工作的组件。<br>任何自定义应用程序类都可以实现LifecycleOwner接口</p><p>实现<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleObserver" target="_blank" rel="noopener">LifecycleObserver</a>的组件可以与实现<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>的组件无缝协作，因为所有者可以提供生命周期，观察者可以注册观察。</p><p>对于位置跟踪示例，我们可以使MyLocationListener类实现LifecycleObserver，然后使用onCreate()方法中的活动生命周期对其进行初始化。<br>这允许MyLocationListener类是自给自足的，这意味着对生命周期状态变化作出反应的逻辑在MyLocationListener中声明，而不是在活动中声明。<br>让各个组件存储自己的逻辑使得活动和片段逻辑更容易管理。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyLocationListener</span> myLocationListener;</span><br><span class="line"></span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> <span class="type">MyLocationListener</span>(<span class="keyword">this</span>, getLifecycle(), location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Util</span>.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.enable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个常见的用例就是避免在生命周期状处于不好的状态时调用某些回调。<br>例如，如果回调在保存活动状态后运行fragment事务，则会触发崩溃，因此我们绝不希望调用该回调。</p><p>为了简化这个用例，生命周期类允许其他对象查询当前状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Lifecycle lifecycle, Callback callback)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">           <span class="comment">// connect</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        enabled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123;</span><br><span class="line">            <span class="comment">// connect if not connected</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect if connected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个实现，我们的LocationListener类完全是生命周期感知的。<br>如果我们需要使用来自其他Activity或Fragment的LocationListener，我们只需要初始化它。<br>所有的启动和销毁操作都由该类本身进行管理。</p><p>如果Library提供需要与Android生命周期配合使用的类，我们建议您使用支持生命周期的组件。<br>您的Library客户端可以在客户端无需手动生命周期管理即可轻松集成这些组件。</p><h4 id="实施自定义LifecycleOwner"><a href="#实施自定义LifecycleOwner" class="headerlink" title="实施自定义LifecycleOwner"></a>实施自定义LifecycleOwner</h4><p><strong>Support Library 26.1.0中的Fragment和Activity以及更高版本已经实现LifecycleOwner接口。</strong></p><p>如果您想要创建LifecycleOwner的自定义类，则可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleRegistry" target="_blank" rel="noopener">LifecycleRegistry</a>类，但需要将事件转发到该类中，如以下代码示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生命周期感知组件的最佳实践"><a href="#生命周期感知组件的最佳实践" class="headerlink" title="生命周期感知组件的最佳实践"></a>生命周期感知组件的最佳实践</h3><ul><li>尽可能保持您的UI控制器（Activities和Fragments）尽可能精简。他们不应该试图获取他们自己的数据;相反，使用<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>来做到这一点，并观察一个<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" target="_blank" rel="noopener">LiveData</a>对象来反映更改回视图。</li><li>尝试编写数据驱动UI的界面，其中您的UI控制器的职责是在数据更改时更新视图，或将用户操作通知给<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>。</li><li>把你的数据逻辑放在<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>类中。<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>应作为您的UI控制器和其他应用程序之间的连接器。但要小心，<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>不负责提取数据（例如，来自网络）。相反，<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>应调用相应的组件来获取数据，然后将结果提供给UI控制器。</li><li>使用<a href="https://developer.android.com/topic/libraries/data-binding/" target="_blank" rel="noopener">Data Binding</a>在视图和UI控制器之间保持干净的界面。这使您可以使您的视图更具说明性，并最大限度地减少需要在活动和片段中编写的更新代码。如果你喜欢用Java编程语言来做到这一点，可以使用像Butter Knife这样的库来避免样板代码并且有更好的抽象</li><li>如果您的UI很复杂，请考虑创建一个presenter类来处理UI修改。这可能是一项艰巨的任务，但它可以使您的UI组件更易于测试。</li><li>避免在<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>中引用View或Activity上下文。如果<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>超出活动（在配置更改的情况下），则活动会泄漏并且垃圾收集器无法正确处理。</li></ul><h3 id="支持生命周期感知组件的用例"><a href="#支持生命周期感知组件的用例" class="headerlink" title="支持生命周期感知组件的用例"></a>支持生命周期感知组件的用例</h3><p>支持生命周期的组件可以让您在各种情况下更容易地管理生命周期。<br>一些例子是：</p><ul><li>在粗粒度和细粒度 位置更新之间切换。使用生命周期感知组件在位置应用可见时启用细粒度位置更新，并在应用处于后台时切换到粗粒度更新。LiveData是一种生命周期感知型组件，允许您的应用在用户更改位置时自动更新用户界面。</li><li>停止并开始视频缓冲。尽可能使用支持生命周期的组件来启动视频缓冲，但延迟播放直到应用程序完全启动。您还可以使用生命周期感知组件在应用程序销毁时终止缓冲。</li><li>启动和停止网络连接。使用支持生命周期的组件可以在应用程序处于前台时实时更新（流式传输）网络数据，并在应用程序进入后台时自动暂停。</li><li>暂停和恢复动画可绘制。使用生命周期感知组件处理在应用程序处于后台时暂停动画的可绘制画面，并在应用程序处于前景时恢复可绘制画面。</li></ul><h3 id="处理停止事件"><a href="#处理停止事件" class="headerlink" title="处理停止事件"></a>处理停止事件</h3><p>当Lifecycle属于AppCompatActivity或Fragment时，Lifecycle的状态将更改为<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#CREATED" target="_blank" rel="noopener">CREATED</a>，并在调用AppCompatActivity或Fragment的onSaveInstanceState()时调度<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.Event#ON_STOP" target="_blank" rel="noopener">ON_STOP</a>事件。</p><p>当Fragment或AppCompatActivity的状态通过onSaveInstanceState（）保存时，UI被认为是不可变的，直到<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.Event#ON_START" target="_blank" rel="noopener">ON_START</a>被调用。尝试在保存状态后修改UI界面可能会导致应用程序的导航状态不一致，这就是为什么如果应用程序在状态保存后运行FragmentTransaction时FragmentManager会抛出异常。<br>有关详细信息，详情请参阅 <a href="https://developer.android.com/reference/android/support/v4/app/FragmentTransaction#commit%28%29" target="_blank" rel="noopener">commit()</a>。</p><p>如果观察者的关联Lifecycle在<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#STARTED" target="_blank" rel="noopener">STARTED</a>之前，则<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" target="_blank" rel="noopener">LiveData</a>通过避免调用其观察者来防止这种边缘情况出现。<br>在幕后，它决定调用观察者之前调用<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#isAtLeast%28android.arch.lifecycle.Lifecycle.State%29" target="_blank" rel="noopener">isAtLeast()</a>。</p><p>不幸的是，AppCompatActivity的onStop()方法会在onSaveInstanceState()之后调用，这会在不允许UI状态更改但生命周期尚未移至<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#CREATED" target="_blank" rel="noopener">CREATED</a>状态的情况下留下空隙。</p><p>为了防止出现这个问题，beta2版本中的Lifecycle类将lower状态标记为CREATED而不分派事件，即使事件直到<a href="https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html#onStop%28%29" target="_blank" rel="noopener">onStop()</a>被调用也未被分派，任何检查当前状态的代码也都会获得真实值。</p><p>不幸的是，这个解决方案有两个主要问题：</p><ul><li>在API等级23或更低的情况下，Android系统实际上保存活动的状态，即使它被另一活动部分覆盖。换句话说，Android系统调用onSaveInstanceState()，但不一定调用onStop()。这会创建一个潜在的长时间间隔，即使其UI状态无​​法修改，观察者仍认为生命周期处于活动状态。</li><li>任何想要向LiveData类公开类似行为的类都必须实现Lifecycle beta2和更低版本提供的解决方法</li></ul><p><strong>注意：为了使此流程更简单，并提供与旧版本的更好兼容性，从版本1.0.0-rc1开始，在调用onSaveInstanceState()而无需等待对onStop()的调用时，将Lifecycle对象标记为CREATED，并调度onStop()方法。这不太可能影响您的代码，但您需要注意这一点，因为它与API级别26及更低级别的Activity类中的调用顺序不匹配。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用生命周期感知组件处理生命周期&quot;&gt;&lt;a href=&quot;#使用生命周期感知组件处理生命周期&quot; class=&quot;headerlink&quot; title=&quot;使用生命周期感知组件处理生命周期&quot;&gt;&lt;/a&gt;使用生命周期感知组件处理生命周期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;支
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Dart语言之旅</title>
    <link href="http://yoursite.com/2018/06/26/dart/Dart%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2018/06/26/dart/Dart语言之旅/</id>
    <published>2018-06-26T05:15:01.000Z</published>
    <updated>2018-06-26T05:28:38.095Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本页向您展示了如何使用每个主要的Dart特性，从变量和运算符到类和库，假定您已经知道如何用另一种语言编程。要了解有关Dart核心库的更多信息，请参阅<a href="https://www.dartlang.org/guides/libraries/library-tour" target="_blank" rel="noopener">Dart  Library之旅</a>。无论何时您想了解有关语言功能的更多详细信息，请参阅<a href="https://www.dartlang.org/guides/language/spec" target="_blank" rel="noopener">Dart语言规范</a>。</p></blockquote><h2 id="Dart基础特性"><a href="#Dart基础特性" class="headerlink" title="Dart基础特性"></a>Dart基础特性</h2><h3 id="一个基本的dart程序"><a href="#一个基本的dart程序" class="headerlink" title="一个基本的dart程序"></a>一个基本的dart程序</h3><p> 以下代码使用了Dart最基本的许多功能:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数.</span></span><br><span class="line">printInteger(<span class="built_in">int</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'The number is $aNumber.'</span>); <span class="comment">// 打印到工作台</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是应用程序开始执行的地方.</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>; <span class="comment">// 声明并初始化一个变量</span></span><br><span class="line">  printInteger(number); <span class="comment">// 调用一个函数.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是适用于所有（或几乎所有）Dart应用程序的写法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 单行注释</span><br><span class="line"><span class="regexp">//</span>此外dart还支持多行注释和文档注释，详情见后面</span><br><span class="line"></span><br><span class="line">int  <span class="regexp">//i</span>nt类型，其他一些内置类型是String，List bool</span><br><span class="line"></span><br><span class="line"><span class="number">42</span> <span class="regexp">//</span>数字，数字是一种编译时常量</span><br><span class="line"></span><br><span class="line">print() <span class="regexp">//</span>一种很方便的打印方法</span><br><span class="line"></span><br><span class="line"><span class="string">'......'</span> o<span class="string">r"......"</span> <span class="regexp">//</span>这两种都是表示字符串</span><br><span class="line"></span><br><span class="line"><span class="variable">$variableName</span> (or <span class="variable">$&#123;expression&#125;</span>)</span><br><span class="line"><span class="regexp">//</span>字符串插值：在字符串文字中包含一个变量或表达式的字符串。有关更多信息，请参阅字符串。</span><br><span class="line">main()  <span class="regexp">//</span>一个应用程序执行开始的特殊的、必须的函数，详情查看main函数</span><br><span class="line">var <span class="regexp">//</span>声明变量但不指定类型</span><br></pre></td></tr></table></figure><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>当你了解Dart语言时，要牢记这些事实和概念：</p><ul><li>你可以放在变量中的所有东西都是一个对象，每个对象都是一个类的实例。即使是数字，功能， null也是对象。所有对象都从Object类继承。</li><li>虽然Dart是强类型的，但类型注释是可选的，因为Dart可以推断类型。在上面的代码中，number 被推断为是类型的int。当你想明确地说没有类型时， 使用特殊类型dynamic。</li><li>Dart支持泛型类型，如List<int>（整数列表）或List<dynamic>（任何类型的对象列表）。</dynamic></int></li><li>Dart支持顶层函数（如main()），以及与类或对象绑定的函数（分别为静态方法和实例方法）。你也可以在函数中创建函数（嵌套函数或局部函数）。</li><li>同样，Dart支持顶级变量以及绑定到类或对象（静态变量和实例变量）的变量。实例变量有时称为字段或属性。</li><li>与Java，dart不具备关键字public，protected和private。如果标识符以下划线（_）开头，则它的库是私有的。有关详细信息，请参阅 库和可见性。</li><li>标识符可以以字母或下划线（_）开头，然后是这些字符和数字的任意组合。</li><li>有时候，重要的是某件事是一种<strong>表达式</strong>还是一种 <strong>声明</strong>，所以这两个词的确切含义很有帮助。</li><li>Dart工具可以报告两种问题：warnings 和errors。警告只是表明您的代码可能无法正常工作，但它们不会阻止您的程序执行。错误可以是编译时或运行时。编译时错误导致代码无法执行; 运行时错误导致 代码执行时引发异常。</li></ul><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>下表列出了Dart语言特别处理的关键词。</p><table><thead><tr><th>abstract</th><th style="text-align:left">do</th><th>import</th><th>super</th></tr></thead><tbody><tr><td>abstract1</td><td style="text-align:left">do</td><td>import 1</td><td>super</td></tr><tr><td>as 1</td><td style="text-align:left">dynamic 1</td><td>in</td><td>switch</td></tr><tr><td>assert</td><td style="text-align:left">else</td><td>interface 1</td><td>sync* 2</td></tr><tr><td>async 2</td><td style="text-align:left">enum</td><td>is</td><td>this</td></tr><tr><td>async* 2</td><td style="text-align:left">export 1</td><td>library 1</td><td>throw</td></tr><tr><td>await 2</td><td style="text-align:left">external 1</td><td>mixin 1</td><td>true</td></tr><tr><td>break</td><td style="text-align:left">extends</td><td>new</td><td>try</td></tr><tr><td>case</td><td style="text-align:left">factory 1</td><td>null</td><td>typedef 1</td></tr><tr><td>catch</td><td style="text-align:left">false</td><td>operator 1</td><td>var</td></tr><tr><td>class</td><td style="text-align:left">final</td><td>part 1</td><td>void</td></tr><tr><td>const</td><td style="text-align:left">finally</td><td>rethrow</td><td>while</td></tr><tr><td>continue</td><td style="text-align:left">for</td><td>return</td><td>with</td></tr><tr><td>covariant 1</td><td style="text-align:left">get 1</td><td>set 1</td><td>yield 2</td></tr><tr><td>default</td><td style="text-align:left">if</td><td>static 1</td><td>yield* 2</td></tr><tr><td>deferred 1</td><td style="text-align:left">implements1</td><td></td></tr></tbody></table><p>1<strong>带上标1</strong>的单词是内置标识符。<br>避免使用内置标识符作为标识符。<br>如果您尝试为类或类型名称使用内置标识符，则会发生编译时错误。<br>2<strong>带上标2</strong>的单词是较新的，与Dart 1.0版本发布后添加的异步支持相关的有限保留字。<br>您不能使用async，await或yield作为用async，async <em>或sync </em>标记的任何函数体中的标识符。<br>有关更多信息，请参见<a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">异步支持</a></p><p><strong>关键字表中的所有其他字都是保留字。</strong><br>您不能使用保留字作为标识符**</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>以下是创建变量并初始化变量的示例：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> =<span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>变量存储的是引用，命名为name的变量存储的是 值为”Bob”的字符创的一个引用<br>name变量的类型被推断为String，但您可以通过指定它来更改该类型。<br>如果对象不限于单一类型，请遵循<a href="https://www.dartlang.org/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed" target="_blank" rel="noopener">设计指南</a>指定对象或动态类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">name</span> =<span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>另一种选择是显式声明将被推断的类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="keyword">name</span> = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>未初始化的变量的初始值为<strong>null</strong>。即使数字类型的变量最初为<strong>null</strong>，因为数字 - 和Dart中的其他所有数据一样 - <strong>都是对象</strong>。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lineCount;</span><br><span class="line"><span class="keyword">assert</span>(lineCount == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：assert()产品代码中 的调用被忽略。在开发过程中， 除非条件为真，否则会引发异常。有关详细信息，请参阅Assert。assert(condition)</strong></p></blockquote><h3 id="Final和const"><a href="#Final和const" class="headerlink" title="Final和const"></a>Final和const</h3><p>如果你从不打算改变一个变量，使用final或者const，而不是var或者其他类型。最终的变量只能设置一次; 一个const变量是一个编译时常量。（Const变量<strong>隐式final</strong> 。）final的顶层或者class变量在它第一次被使用时被初始化。</p><blockquote><p><strong>注意： 实例变量可以final但不是const。</strong></p></blockquote><p> 以下是创建和设置最终变量的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>; <span class="comment">// 没有类型声明</span></span><br><span class="line"><span class="comment">// name = 'Alice';  // 取消注释会导致UC哦呜</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">'Bobby'</span>;</span><br></pre></td></tr></table></figure><p>将const用于想要成为编译时常量的变量。<br>如果const变量处于类级别，则将其标记为静态常量。<br>在声明该变量的位置，将该值设置为编译时常量，例如数字或字符串文字，常量变量或常数上算术运算的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="number">1000000</span>; <span class="comment">// 压力单位(dynes/cm2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> atm = <span class="number">1.01325</span> * bar; <span class="comment">// 标准大气压</span></span><br></pre></td></tr></table></figure><p>该const关键字不只是声明常数变量。您也可以使用它来创建常量值，以及声明创建常量值的构造函数。任何变量都可以有一个常量值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">Note:</span> [] 创建一个空的list</span></span><br><span class="line"><span class="comment">// const [] 创建一个空的， 一成不变的list (简写为EIL).</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> []; <span class="comment">// foo 当前是一个 EIL(empty immutabe list).</span></span><br><span class="line"><span class="keyword">final</span> bar = <span class="keyword">const</span> []; <span class="comment">// bar 将永远是 EIL.</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="keyword">const</span> []; <span class="comment">// baz 是一个编译时常量 EIL.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can change the value of a non-final, non-const variable,</span></span><br><span class="line"><span class="comment">// even if it used to have a const value.</span></span><br><span class="line">foo = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can't change the value of a final or const variable.</span></span><br><span class="line"><span class="comment">// bar = []; // Unhandled exception.</span></span><br><span class="line"><span class="comment">// baz = []; // Unhandled exception.</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本页向您展示了如何使用每个主要的Dart特性，从变量和运算符到类和库，假定您已经知道如何用另一种语言编程。要了解有关Dart核心库的更多信息，请参阅&lt;a href=&quot;https://www.dartlang.org/guides/libraries
      
    
    </summary>
    
      <category term="Dart学习" scheme="http://yoursite.com/categories/Dart%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Dart学习" scheme="http://yoursite.com/tags/Dart%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android权限列表</title>
    <link href="http://yoursite.com/2018/06/22/android/Android%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/22/android/Android权限列表/</id>
    <published>2018-06-22T05:16:32.000Z</published>
    <updated>2018-06-22T05:17:44.664Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.csdn.net/ufo00001/article/details/69397256" target="_blank" rel="noopener">http://blog.csdn.net/ufo00001/article/details/69397256</a></p><table><thead><tr><th>1.android.permission.WRITE_USER_DICTIONARY</th><th>允许应用程序向用户词典中写入新词 </th></tr></thead><tbody><tr><td>2.android.permission.WRITE_SYNC_SETTINGS</td><td>写入Google在线同步设置 </td></tr><tr><td>3.android.permission.WRITE_SOCIAL_STREAM</td><td>读取用户的社交信息流 </td></tr><tr><td>4.android.permission.WRITE_SMS</td><td>允许程序写短信 </td></tr><tr><td>5.android.permission.WRITE_SETTINGS</td><td>允许程序读取或写入系统设置 </td></tr><tr><td>6.android.permission.WRITE_SECURE_SETTINGS</td><td>允许应用程序读取或写入安全系统设置 </td></tr><tr><td>7.android.permission.WRITE_PROFILE</td><td>允许程序写入个人资料数据 </td></tr><tr><td>8.com.android.browser.permission.WRITE_HISTORY_BOOKMARKS</td><td>允许一个应用程序写（但不可读）用户的浏览历史和书签 </td></tr><tr><td>9.android.permission.WRITE_GSERVICES</td><td>允许程序修改Google服务地图 </td></tr><tr><td>10.android.permission.WRITE_EXTERNAL_STORAGE</td><td>允许程序写入外部存储，如SD卡上写文件 </td></tr><tr><td>11.android.permission.WRITE_CONTACTS</td><td>写入联系人，但不可读取 </td></tr><tr><td>12.android.permission.WRITE_CALL_LOG</td><td>允许程序写入（但是不能读）用户的联系人数据 </td></tr><tr><td>13.android.permission.WRITE_CALENDAR</td><td>允许程序写入日程，但不可读取 </td></tr><tr><td>14.android.permission.WRITE_APN_SETTINGS</td><td>允许程序写入网络GPRS接入点设置 </td></tr><tr><td>15.android.permission.WAKE_LOCK</td><td>允许程序在手机屏幕关闭后后台进程仍然运行 </td></tr><tr><td>16.android.permission.VIBRATE</td><td>允许程序振动 </td></tr><tr><td>17.android.permission.USE_SIP</td><td>允许程序使用SIP视频服务 </td></tr><tr><td>18.android.permission.USE_CREDENTIALS</td><td>允许程序请求验证从AccountManager </td></tr><tr><td>19.android.permission.UPDATE_DEVICE_STATS</td><td>允许程序更新设备状态 </td></tr><tr><td>20.com.android.launcher.permission.UNINSTALL_SHORTCUT</td><td>删除快捷方式 </td></tr><tr><td>21.android.permission.TRANSMIT_IR</td><td>允许使用设备的红外发射器，如果可用 </td></tr><tr><td>22.android.permission.SYSTEM_ALERT_WINDOW</td><td>允许程序显示系统窗口 </td></tr><tr><td>23.android.permission.SUBSCRIBED_FEEDS_WRITE</td><td>允许程序写入或修改订阅内容的数据库 </td></tr><tr><td>24.android.permission.SUBSCRIBED_FEEDS_READ</td><td>允许程序访问订阅信息的数据库 </td></tr><tr><td>22.android.permission.STATUS_BAR</td><td>允许程序打开、关闭、禁用状态栏 </td></tr><tr><td>23.android.permission.SIGNAL_PERSISTENT_PROCESSES</td><td>允许程序发送一个永久的进程信号 </td></tr><tr><td>24.android.permission.SET_WALLPAPER_HINTS</td><td>允许程序设置壁纸建议 </td></tr><tr><td>25.android.permission.SET_WALLPAPER</td><td>允许程序设置桌面壁纸 </td></tr><tr><td>26.android.permission.SET_TIME_ZONE</td><td>允许程序设置系统时区 </td></tr><tr><td>27.android.permission.SET_TIME</td><td>允许程序设置系统时间 </td></tr><tr><td>28.android.permission.SET_PROCESS_LIMIT</td><td>允许程序设置最大的进程数量的限制 </td></tr><tr><td>29.android.permission.SET_PREFERRED_APPLICATIONS</td><td>允许程序设置应用的参数，<br>已不再工作具体查看addPackageToPreferred（String） 介绍 </td></tr><tr><td>30.android.permission.SET_POINTER_SPEED</td><td>无法被第三方应用获得，系统权限 </td></tr><tr><td>31.android.permission.SET_ORIENTATION</td><td>允许程序设置屏幕方向为横屏或标准方式显示，不用于普通应用 </td></tr><tr><td>32.android.permission.SET_DEBUG_APP</td><td>允许程序设置调试程序，一般用于开发 </td></tr><tr><td>33.android.permission.SET_ANIMATION_SCALE</td><td>允许程序设置全局动画缩放 </td></tr><tr><td>34.android.permission.SET_ALWAYS_FINISH</td><td>允许程序设置程序在后台是否总是退出 </td></tr><tr><td>36.com.android.alarm.permission.SET_ALARM</td><td>允许程序设置闹铃提醒 </td></tr><tr><td>37.android.permission.SET_ACTIVITY_WATCHER</td><td>允许程序设置Activity观察器<br>一般用于monkey测试 </td></tr><tr><td>38.android.permission.SEND_SMS</td><td>允许程序发送短信 </td></tr><tr><td>39.android.permission.SEND_RESPOND_VIA_MESSAGE</td><td>允许用户在来电的时候用你的应用进行即时的短信息回复。 </td></tr><tr><td>40.android.permission.RESTART_PACKAGES</td><td>允许程序结束任务通过<br>restartPackage（String）方法，该方式将在外来放弃</td></tr><tr><td>41.android.permission.REORDER_TASKS</td><td>允许程序重新排序系统Z轴运行中的任务 </td></tr><tr><td>42.android.permission.RECORD_AUDIO</td><td>允许程序录制声音通过手机或耳机的麦克 </td></tr><tr><td>43.android.permission.RECEIVE_WAP_PUSH</td><td>允许程序接收WAP PUSH信息 </td></tr><tr><td>44.android.permission.RECEIVE_SMS</td><td>允许程序接收短信 </td></tr><tr><td>45.android.permission.RECEIVE_MMS</td><td>允许程序接收彩信 </td></tr><tr><td>46.android.permission.RECEIVE_BOOT_COMPLETED</td><td>允许程序开机自动运行 </td></tr><tr><td>47.android.permission.REBOOT</td><td>允许程序重新启动设备 </td></tr><tr><td>48.android.permission.READ_USER_DICTIONARY</td><td>从一个提供器中获取数据，针对对应的提供器，应用程序需要“读访问权限” </td></tr><tr><td>49.android.permission.READ_SYNC_STATS</td><td>允许程序读取同步状态，获得Google在线同步状态 </td></tr><tr><td>50.android.permission.READ_SYNC_SETTINGS</td><td>允许程序读取同步设置，读取Google在线同步设置 </td></tr><tr><td>51.android.permission.READ_SOCIAL_STREAM</td><td>读取用户的社交信息流 </td></tr><tr><td>52.android.permission.READ_SMS</td><td>允许程序读取短信内容 </td></tr><tr><td>53.android.permission.READ_PROFILE</td><td>访问用户个人资料 </td></tr><tr><td>54.android.permission.READ_PHONE_STATE</td><td>允许程序访问电话状态 </td></tr><tr><td>55.android.permission.READ_LOGS</td><td>允许程序读取系统底层日志 </td></tr><tr><td>56.android.permission.READ_INPUT_STATE</td><td>允许程序读取当前键的输入状态，仅用于系统 </td></tr><tr><td>57.com.android.browser.permission.READ_HISTORY_BOOKMARKS</td><td>允许程序读取浏览器收藏夹和历史记录 </td></tr><tr><td>58.android.permission.READ_FRAME_BUFFER</td><td>允许程序读取帧缓存用于屏幕截图 </td></tr><tr><td>59.android.permission.READ_EXTERNAL_STORAGE</td><td>程序可以读取设备外部存储空间（内置SDcard和外置SDCard）的文件，如果您的App已经添加<br>了“WRITE_EXTERNAL_STORAGE ”权限 ，则就没必要添加读的权限了，写权限已经包含了读权限了。 </td></tr><tr><td>60.android.permission.READ_CONTACTS</td><td>允许程序访问联系人通讯录信息 </td></tr><tr><td>61.android.permission.READ_CALL_LOG</td><td>读取通话记录 </td></tr><tr><td>62.android.permission.READ_CALENDAR</td><td>允许程序读取用户的日程信息 </td></tr><tr><td>63.android.permission.PROCESS_OUTGOING_CALLS</td><td>允许程序监视，修改或放弃播出电话 </td></tr><tr><td>64.android.permission.PERSISTENT_ACTIVITY</td><td>允许程序创建一个永久的Activity，该功能标记为将来将被移除 </td></tr><tr><td>65.android.permission.NFC</td><td>允许程序执行NFC近距离通讯操作，用于移动支持 </td></tr><tr><td>66.android.permission.MOUNT_UNMOUNT_FILESYSTEMS</td><td>允许程序挂载、反挂载外部文件系统 </td></tr><tr><td>67.android.permission.MOUNT_FORMAT_FILESYSTEMS</td><td>允许程序格式化可移动文件系统，比如格式化清空SD卡 </td></tr><tr><td>68.android.permission.MODIFY_PHONE_STATE</td><td>允许程序修改电话状态，如飞行模式，但不包含替换系统拨号器界面 </td></tr><tr><td>69.android.permission.MODIFY_AUDIO_SETTINGS</td><td>允许程序修改声音设置信息 </td></tr><tr><td>70.android.permission.MEDIA_CONTENT_CONTROL</td><td>允许一个应用程序知道什么是播放和控制其内容。不被第三方应用使用。 </td></tr><tr><td>71.android.permission.MASTER_CLEAR</td><td>允许程序执行软格式化，删除系统配置信息 </td></tr><tr><td>72.android.permission.MANAGE_DOCUMENTS</td><td>允许一个应用程序来管理文档的访问，通常是一个文档选择器部分 </td></tr><tr><td>73.android.permission.MANAGE_APP_TOKENS</td><td>管理创建、摧毁、Z轴顺序，仅用于系统 </td></tr><tr><td>74.android.permission.MANAGE_ACCOUNTS</td><td>允许程序管理AccountManager中的账户列表 </td></tr><tr><td>75.android.permission.LOCATION_HARDWARE</td><td>允许一个应用程序中使用定位功能的硬件，不使用第三方应用 </td></tr><tr><td>76.android.permission.KILL_BACKGROUND_PROCESSES</td><td>允许程序调用killBackgroundProcesses（String）。方法结束后台进程 </td></tr><tr><td>77.android.permission.INTERNET</td><td>允许程序访问网络连接，可能产生GPRS流量 </td></tr><tr><td>78.android.permission.INTERNAL_SYSTEM_WINDOW</td><td>允许程序打开内部窗口，不对第三方应用程序开放此权限 </td></tr><tr><td>79.com.android.launcher.permission.INSTALL_SHORTCUT</td><td>创建快捷方式 </td></tr><tr><td>80.android.permission.INSTALL_PACKAGES</td><td></td></tr><tr><td>81.android.permission.INSTALL_LOCATION_PROVIDER</td><td>允许程序安装定位提供 </td></tr><tr><td>82.android.permission.INJECT_EVENTS</td><td>允许程序访问本程序的底层事件，获取按键、轨迹球的事件流 </td></tr><tr><td>83.android.permission.HARDWARE_TEST</td><td>允许程序访问硬件辅助设备，用于硬件测试 </td></tr><tr><td>84.android.permission.GLOBAL_SEARCH</td><td>允许程序允许全局搜索 </td></tr><tr><td>85.android.permission.GET_TOP_ACTIVITY_INFO</td><td>允许一个应用程序检索私有信息是当前最顶级的活动，不被第三方应用使用 </td></tr><tr><td>86.android.permission.GET_TASKS</td><td>允许程序获取任务信息 </td></tr><tr><td>87.android.permission.GET_PACKAGE_SIZE</td><td>允许程序获取应用的文件大小 </td></tr><tr><td>88.android.permission.GET_ACCOUNTS</td><td>允许程序访问账户Gmail列表 </td></tr><tr><td>89.android.permission.FORCE_BACK</td><td>允许程序强制使用back后退按键，无论Activity是否在顶层 </td></tr><tr><td>90.android.permission.FLASHLIGHT</td><td>允许访问闪光灯 </td></tr><tr><td>91.android.permission.FACTORY_TEST</td><td>允许程序运行工厂测试模式 </td></tr><tr><td>92.android.permission.EXPAND_STATUS_BAR</td><td>允许程序扩展或收缩状态栏 </td></tr><tr><td>93.android.permission.DUMP</td><td>允许程序获取系统dump信息从系统服务 </td></tr><tr><td>94.android.permission.DISABLE_KEYGUARD</td><td>允许程序禁用键盘锁 </td></tr><tr><td>95.android.permission.DIAGNOSTIC</td><td>允许程序到RW到诊断资源 </td></tr><tr><td>96.android.permission.DEVICE_POWER</td><td>允许程序访问底层电源管理 </td></tr><tr><td>97.android.permission.DELETE_PACKAGES</td><td>允许程序删除应用 </td></tr><tr><td>98.android.permission.DELETE_CACHE_FILES</td><td>允许程序删除缓存文件 </td></tr><tr><td>99.android.permission.CONTROL_LOCATION_UPDATES</td><td>允许程序获得移动网络定位信息改变 </td></tr><tr><td>100.android.permission.CLEAR_APP_USER_DATA</td><td>允许程序清除用户数据 </td></tr><tr><td>101.android.permission.CLEAR_APP_CACHE</td><td>允许程序清除应用缓存 </td></tr><tr><td>102.android.permission.CHANGE_WIFI_STATE</td><td>允许程序改变WiFi状态 </td></tr><tr><td>103.android.permission.CHANGE_WIFI_MULTICAST_STATE</td><td>允许程序改变WiFi多播状态 </td></tr><tr><td>104.android.permission.CHANGE_NETWORK_STATE</td><td>允许程序改变网络状态，如是否联网 </td></tr><tr><td>105.android.permission.CHANGE_CONFIGURATION</td><td>允许当前应用改变配置，如定位 </td></tr><tr><td>106.android.permission.CHANGE_COMPONENT_ENABLED_STATE</td><td>改变组件是否启用状态 </td></tr><tr><td>107.android.permission.CAPTURE_VIDEO_OUTPUT</td><td>允许一个应用程序捕获视频输出，不被第三方应用使用 </td></tr><tr><td>108.android.permission.CAPTURE_SECURE_VIDEO_OUTPUT</td><td>允许一个应用程序捕获视频输出。不被第三方应用使用 </td></tr><tr><td>109.android.permission.CAPTURE_AUDIO_OUTPUT</td><td>允许一个应用程序捕获音频输出。不被第三方应用使用 </td></tr><tr><td>110.android.permission.CAMERA</td><td>允许程序访问摄像头进行拍照 </td></tr><tr><td>111.android.permission.CALL_PRIVILEGED</td><td>允许程序拨打电话，替换系统的拨号器界面 </td></tr><tr><td>112.android.permission.CALL_PHONE</td><td>允许程序从非系统拨号器里拨打电话 </td></tr><tr><td>113.android.permission.BROADCAST_WAP_PUSH</td><td>WAP PUSH服务收到后触发一个广播 </td></tr><tr><td>114.android.permission.BROADCAST_STICKY</td><td>允许程序收到广播后快速收到下一个广播 </td></tr><tr><td>115.android.permission.BROADCAST_SMS</td><td>允许程序当收到短信时触发一个广播 </td></tr><tr><td>116.android.permission.BROADCAST_PACKAGE_REMOVED</td><td>允许程序删除时广播 </td></tr><tr><td>117.android.permission.BRICK</td><td>能够禁用手机，非常危险，顾名思义就是让手机变成砖头 </td></tr><tr><td>118.android.permission.BLUETOOTH_PRIVILEGED</td><td>允许应用程序配对蓝牙设备，而无需用户交互。这不是第三方应用程序可用。 </td></tr><tr><td>119.android.permission.BLUETOOTH_ADMIN</td><td>允许程序进行发现和配对新的蓝牙设备 </td></tr><tr><td>120.android.permission.BLUETOOTH</td><td>允许程序连接配对过的蓝牙设备 </td></tr><tr><td>121.android.permission.BIND_WALLPAPER</td><td>必须通过WallpaperService服务来请求，只有系统才能用 </td></tr><tr><td>122.android.permission.BIND_VPN_SERVICE</td><td>绑定VPN服务必须通过VpnService服务来请求，只有系统才能用 </td></tr><tr><td>123.android.permission.BIND_TEXT_SERVICE</td><td>必须要求textservice（例如吗 spellcheckerservice），以确保只有系统可以绑定到它。 </td></tr><tr><td>124.android.permission.BIND_REMOTEVIEWS</td><td>必须通过RemoteViewsService服务来请求，只有系统才能用 </td></tr><tr><td>125.android.permission.BIND_PRINT_SERVICE</td><td>必须要求由printservice，以确保只有系统可以绑定到它。 </td></tr><tr><td>126.android.permission.BIND_NOTIFICATION_LISTENER_SERVICE</td><td>必须要求由notificationlistenerservice，以确保只有系统可以绑定到它。 </td></tr><tr><td>127.android.permission.BIND_NFC_SERVICE</td><td>由hostapduservice或offhostapduservice必须确保只有系统可以绑定到它。 </td></tr><tr><td>128.android.permission.BIND_INPUT_METHOD</td><td>请求InputMethodService服务，只有系统才能使用 </td></tr><tr><td>129.android.permission.BIND_DEVICE_ADMIN</td><td>请求系统管理员接收者receiver，只有系统才能使用 </td></tr><tr><td>130.android.permission.BIND_APPWIDGET</td><td>允许程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 </td></tr><tr><td>131.android.permission.BIND_ACCESSIBILITY_SERVICE</td><td>请求accessibilityservice服务，以确保只有系统可以绑定到它。 </td></tr><tr><td>132.android.permission.AUTHENTICATE_ACCOUNTS</td><td>允许程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 </td></tr><tr><td>133.com.android.voicemail.permission.ADD_VOICEMAIL</td><td>允许一个应用程序添加语音邮件系统 </td></tr><tr><td>134.android.permission.ACCOUNT_MANAGER</td><td>允许程序获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 </td></tr><tr><td>135.android.permission.ACCESS_WIFI_STATE</td><td>允许程序获取当前WiFi接入的状态以及WLAN热点的信息 </td></tr><tr><td>136.android.permission.ACCESS_SURFACE_FLINGER</td><td>Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 </td></tr><tr><td>137.android.permission.ACCESS_NETWORK_STATE</td><td>允许程序获取网络信息状态，如当前的网络连接是否有效 </td></tr><tr><td>138.android.permission.ACCESS_MOCK_LOCATION</td><td>允许程序获取模拟定位信息，一般用于帮助开发者调试应用 </td></tr><tr><td>139.android.permission.ACCESS_LOCATION_EXTRA_COMMANDS</td><td>允许程序访问额外的定位提供者指令 </td></tr><tr><td>140.android.permission.ACCESS_FINE_LOCATION</td><td>允许程序通过GPS芯片接收卫星的定位信息 </td></tr><tr><td>141.android.permission.ACCESS_COARSE_LOCATION</td><td>允许程序通过WiFi或移动基站的方式获取用户错略的经纬度信息 </td></tr><tr><td>142.android.permission.ACCESS_CHECKIN_PROPERTIES</td><td>允许程序读取或写入登记check-in数据库属性表的权限</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;http://blog.csdn.net/ufo00001/article/details/69397256&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/ufo00001/articl
      
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android运行时权限总结</title>
    <link href="http://yoursite.com/2018/06/22/android/Android%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/22/android/Android运行时权限总结/</id>
    <published>2018-06-22T02:50:27.000Z</published>
    <updated>2018-06-22T03:50:52.271Z</updated>
    
    <content type="html"><![CDATA[<p>###1、android6.0以后的危险权限介绍<br>（注意：Android O  8.0对于权限更加严格，下面会说一下8.0）<br>android6.0以后有些危险权限需要手动去授权，就有了运行时权限的处理。下面的表格就是危险权限组：</p><table><thead><tr><th>权限组名</th><th>权限名</th></tr></thead><tbody><tr><td>CALENDAR  日历</td><td>READ_CALENDAR<br>WRITE_CALENDER</td></tr><tr><td>CAMERA      相机</td><td>CAMERA</td></tr><tr><td>CONTACTS 联系人</td><td>READ_CONTACTS<br>WRITE_CONTACTS<br>GET_ACCOUNTS</td></tr><tr><td>LOCATION  定位</td><td>ACCESS_FINE_LOCATION<br>ACCESS_COARSE_LOCATION</td></tr><tr><td>MICROPHONE 麦克风</td><td>RECORD_AUDIO</td></tr><tr><td>PHONE 电话</td><td>READ_PHONE_STATE<br>CALL_PHONE<br>READ_CALL_LOG<br>WRITE_CALL_LOG<br>ADD_VOICEMAIL<br>USE_SIP<br>PROCESS_OUTGOING_CALLS</td></tr><tr><td>SENSORS 传感器</td><td>BODY_SENSORS</td></tr><tr><td>SMS  短信</td><td>Short Message Service<br>SEND_SMS<br>RECEIVE_SMS<br>READ_SMS<br>RECEIVE_WAP_PUSH<br>RECEIVE_MMS</td></tr><tr><td>STORAGE 数据存储</td><td>READ_EXTRAL_STRORAGE<br>WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><p>申请权限时：<br>1、在清单文件中声明权限（如果不在这张表中，声明完就可以了）<br>2、如果在这张表中的权限需要手动来申请</p><p>这些权限6.0以后需要手动申请，，每一个权限组中的权限只要有一个权限同意授权了，整个权限组中的权限就不用重复申请了。<br><strong>如果如果查看所有的权限，请参考：<a href="https://segmentfault.com/a/1190000012259370" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012259370</a></strong></p><p>###2、运行时权限申请过程：<br>传统的申请过程是：<br>1、在AndroidManifest文件中添加需要的权限。<br>2、检查权限是否授权<br>3、申请权限<br>4、处理授权的结果</p><p>一步步来：<br><strong>1、首先在请单文件中声明，这个不用说</strong><br><strong>2、检查权限是否授权</strong></p><pre><code>if (ContextCompat.checkSelfPermission(thisActivity,            Manifest.permission.READ_CONTACTS)    != PackageManager.PERMISSION_GRANTED) {    //没有授权，编写申请权限代码}else{//已经授权，执行操作代码}    </code></pre><p>   基本上调用checkSelfPermission()函数传入权限参数，返回的结果又两个：<br>如果是已授权的权限，该方法返回结果是 PackageManager.PERMISSION_GRANTED 常量为 0，<br>如果是未授权的权限，该方法返回结果是 PackageManager.PERMISSION_DENIED 常量为 -1。<br>这样就可以判断是否已经授权，来进行下一步的操作。</p><p><strong>3、如果没有授权，需要申请权限</strong><br>    ActivityCompat.requestPermissions(thisActivity,<br>                new String[]{Manifest.permission.READ_CONTACTS},<br>                MY_PERMISSIONS_REQUEST_READ_CONTACTS);<br>  这是一个异步的方法，第一个参数是Context；第二个参数是需要申请的权限的字符串数组（这个是支持同时申请多个权限，系统会逐个询问是否授权）；第三个参数为请求码requestCode，主要用于回调的时候检测。</p><p><strong>4、处理权限申请的回调结果</strong><br>重写Activity或者fragment的 onRequestPermissionsResul()方法<br>      //权限回调方法<br>    @Override<br>    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</p><pre><code>    switch (requestCode){        case 0:            //grantResults数组存储的申请的返回结果，            //PERMISSION_GRANTED 表示申请成功            if (grantResults.length&gt;0&amp;&amp;grantResults[0]== PackageManager.PERMISSION_GRANTED){                //授权成功，                //这里写相应的 操作代码            }else{                //授权失败，可以简单提示用户                Toast.makeText(this, &quot;没有授权继续操作&quot;, Toast.LENGTH_SHORT).show();            }            break;        case 1:            //同上            break;        default:            break;    }}这里稍微说一下，申请的时候是一个一个的申请的话，每次申请都有一个请求码，这里的grantResults数组就只有一个值，所以都是grantResults[0]来和PERMISSION_GRANTED来进行比较如果是一次申请多个权限，grantResults数组返回的值就不止一个，但是，直接遍历它就行，只要全部满足条件才算申请成功，才能进行相应的操作一般的写法是：通过if判断权限是否申请，没有申请，把它加到一个集合里面，把所有的权限都判断一遍以后，去遍历这个集合，只要有一个没有申请的，就需、要去申请权限，    把这个集合转为数组，传到requestPermissions的第二个参数，然后就处理相应 结果就可以了，遍历grantResults数组，判断是不是全部满足条件</code></pre><p>###3、EasyPermissions的使用<br>GitHub地址：<a href="https://github.com/googlesamples/easypermissions" target="_blank" rel="noopener">https://github.com/googlesamples/easypermissions</a><br>   EasyPermissions是谷歌封装的一个运行时权限申请的库，简化了操作的过程。<br>使用过程： 没有什么先后顺序，下面没有按这个顺序。这么做是可以的，当然还有其他的使用方法</p><blockquote><p>1、builde gradle中依赖<br>2、清单文件中声明权限<br>3、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions来<br>4、通过hasPermissions检查权限，或者原生的也行，然后去申请权限<br>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法，成功或失败<br>6、在成功或者失败方法中编写要具体做的事。</p></blockquote><p>GitHub地址：<br><strong>(1)依赖库</strong><br>    dependencies {<br>        compile ‘pub.devrel:easypermissions:1.0.1’<br>    }</p><p><strong>(2)再在清单文件中声明要申请的危险权限</strong><br>如果不声明的话，直接在代码中写也能申请成功，但是好想不会弹出询问框，直接就申请了</p><p><strong>(3)申请权限</strong><br>可以直接申请<br>    EasyPermissions.requestPermissions(<br>                        MainActivity.this,<br>                        “申请权限”,<br>                        0,<br>                        Manifest.permission.WRITE_EXTERNAL_STORAGE,<br>                        Manifest.permission.RECORD_AUDIO);<br>最好还是检查一下权限是否申请：<br><strong>EasyPermissions.hasPermissions(Context context, @NonNull String… perms)</strong>方法来检测一个或者多个权限是否被允许，第二个参数是个可变数组，可以申请多个<br>    String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};<br>    if (EasyPermissions.hasPermissions(this, perms)) {</p><pre><code>    // 已经申请过权限，做想做的事} else {    // 没有申请过权限，现在去申请    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),            RC_CAMERA_AND_LOCATION, perms);}</code></pre><p>下面来说一个申请权限这个方法：<br>EasyPermissions.requestPermissions():<img src="/img/bVZBii" alt="图片描述"></p><p>requestPermissions() 一般用这个四个参数的就可以<br>第一个参数：Context对象<br>第二个参数：权限弹窗上的文字提示语。告诉用户，这个权限用途。<br>第三个参数：这次请求权限的唯一标识请求码，code。<br>第四个参数 : 一些系列的权限。<br>   这里说一下第二个参数，不是第一次申请系统默认弹出的提示语，而是，我们拒绝后，再次点击申请弹出的对话框，，显示我们设置的提示语，下面有两个按钮，确认和取消，我就不贴图了。</p><p>还有六个参数的，多了两个参数就是，修改我们上面那个确认和取消的字样，你可以干成yes 和no. </p><p><strong>4、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions    </strong><br>一行代码就搞定了<br>     @Override<br>    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>        super.onRequestPermissionsResult(requestCode, permissions, grantResults);<br>        EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);<br>    }</p><p><strong>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法</strong><br>    public class MainActivity extends AppCompatActivity implements EasyPermissions.PermissionCallbacks {</p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);}@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {    super.onRequestPermissionsResult(requestCode, permissions, grantResults);    // 把执行结果的操作给EasyPermissions    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);}@Override //申请成功时调用public void onPermissionsGranted(int requestCode, List&lt;String&gt; list) {    //请求成功执行相应的操作    比如，举个例子    switch (requestCode){        case 0:            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();            break;        case 1:            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();            break;    }}@Override //申请失败时调用public void onPermissionsDenied(int requestCode, List&lt;String&gt; list) {    // 请求失败，执行相应操作}}</code></pre><p>接下来就要说一下成功或者失败后的操作了： 申请成功就直接做该做的事就行了，没啥。<br>申请如果失败了，这时候有个方法出现了EasyPermissions.somePermissionPermanentlyDenied(this, perms)<br>这个方法是谷歌建议的。就是在我们点了不在询问并拒绝，会弹出对话框，告诉用户这个权限时干嘛的，很重要，建议不要拒绝哈哈<br>比如这样：  </p><pre><code>@Overridepublic void onPermissionsDenied(int requestCode, List&lt;String&gt; perms) {if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {    new AppSettingsDialog.Builder(this).build().show();    //弹出个对话框}</code></pre><p>}                 </p><p>当然我们可以定制一下这个对话框：<br>    @Override<br>    public void onPermissionsDenied(int requestCode, List<string> perms) {<br>        //处理权限名字字符串<br>        StringBuffer sb = new StringBuffer();<br>        for (String str : perms){<br>            sb.append(str);<br>            sb.append(“\n”);<br>        }<br>        sb.replace(sb.length() - 2,sb.length(),””);</string></p><pre><code>    switch (requestCode){        case 0:            Toast.makeText(this, &quot;已拒绝权限&quot; + perms.get(0), Toast.LENGTH_SHORT).show();            break;        case 1:            Toast.makeText(this, &quot;已拒绝WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;+ perms.get(0), Toast.LENGTH_SHORT).show();            break;    }    if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {        Toast.makeText(this, &quot;已拒绝权限&quot; + sb + &quot;并不再询问&quot; , Toast.LENGTH_SHORT).show();        new AppSettingsDialog                .Builder(this)                .setRationale(&quot;此功能需要&quot; + sb + &quot;权限，否则无法正常使用，是否打开设置&quot;)                .setPositiveButton(&quot;是&quot;)                .setNegativeButton(&quot;否&quot;)                .build()                .show();    }}</code></pre><p><strong>6、(可选)@AfterPermissionGranted()注解</strong></p><p>使用 AfterPermissioonGranted 注解。这是可选的，但是提供出来是为了方便。如果所有的请求的权限都被授予了，被注解的方法将会被执行，这样做是为了简化通常的请求权限成功之后再调用方法的流程。同时也可以在onPermissionsGranted 的回调中添加逻辑操作：<br>比如官网上的这个实例代码：<br>这里的方法名可以自己取，主要是权限都申请完，就调用这个方法，执行里面的操作。<br>其实就相当于在onPermissionsGranted()调用这个方法而已:</p><pre><code>@AfterPermissionGranted(RC_CAMERA_AND_LOCATION)private void methodRequiresTwoPermission() {String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};if (EasyPermissions.hasPermissions(this, perms)) {    // Already have permission, do the thing    // ...} else {    // Do not have permissions, request them now    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),            RC_CAMERA_AND_LOCATION, perms);}}</code></pre><p>基本上介绍完了</p><p>###4、android 8.0运行时权限<br>对于针对Android O的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p><p>例如，假设某个应用在其清单中列出READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE。应用请求READ_EXTERNAL_STORAGE，并且用户授予了该权限，如果该应用针对的是API级别24或更低级别，系统还会同时授予WRITE_EXTERNAL_STORAGE，因为该权限也属于STORAGE权限组并且也在清单中注册过。如果该应用针对的是Android O，则系统此时仅会授予READ_EXTERNAL_STORAGE，不过在该应用以后申请WRITE_EXTERNAL_STORAGE权限时，系统会立即授予该权限，而不会提示用户。<br><strong>注意：如果使用了没有授权的权限，会崩溃的</strong></p><p>所以对于8.0权限，我们要做的处理，是尽量把所用到的危险权限全部申请。但是有的权限在不同版本出现，所以要兼容不同的版本，所以要加一个版本的判断。</p><blockquote><p>归根结底：android M (6.0)以后，申请权限组一个，即表示整个权限组可以用，所以我们干脆，只要api 版本大于23（6.0）,我们申请的权限就是申请整个权限组。这样就兼容了android8.0——————-为了省事的话可以用AndPermission这个第三方框架，或者自己封装一个。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###1、android6.0以后的危险权限介绍&lt;br&gt;（注意：Android O  8.0对于权限更加严格，下面会说一下8.0）&lt;br&gt;android6.0以后有些危险权限需要手动去授权，就有了运行时权限的处理。下面的表格就是危险权限组：&lt;/p&gt;
&lt;table&gt;
&lt;the
      
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
</feed>
