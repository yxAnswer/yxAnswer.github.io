<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术成长之路</title>
  
  <subtitle>Simple technology</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-26T05:19:36.199Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨旭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dart语言之旅</title>
    <link href="http://yoursite.com/2018/06/26/dart/Dart%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2018/06/26/dart/Dart语言之旅/</id>
    <published>2018-06-26T05:15:01.000Z</published>
    <updated>2018-06-26T05:19:36.199Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本页向您展示了如何使用每个主要的Dart特性，从变量和运算符到类和库，假定您已经知道如何用另一种语言编程。要了解有关Dart核心库的更多信息，请参阅<a href="https://www.dartlang.org/guides/libraries/library-tour" target="_blank" rel="noopener">Dart  Library之旅</a>。无论何时您想了解有关语言功能的更多详细信息，请参阅<a href="https://www.dartlang.org/guides/language/spec" target="_blank" rel="noopener">Dart语言规范</a>。</p></blockquote><h2 id="Dart基础特性"><a href="#Dart基础特性" class="headerlink" title="Dart基础特性"></a>Dart基础特性</h2><h3 id="一个基本的dart程序"><a href="#一个基本的dart程序" class="headerlink" title="一个基本的dart程序"></a>一个基本的dart程序</h3><p> 以下代码使用了Dart最基本的许多功能:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数.</span></span><br><span class="line">printInteger(<span class="built_in">int</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'The number is $aNumber.'</span>); <span class="comment">// 打印到工作台</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是应用程序开始执行的地方.</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>; <span class="comment">// 声明并初始化一个变量</span></span><br><span class="line">  printInteger(number); <span class="comment">// 调用一个函数.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是适用于所有（或几乎所有）Dart应用程序的写法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 单行注释</span><br><span class="line"><span class="regexp">//</span>此外dart还支持多行注释和文档注释，详情见后面</span><br><span class="line"></span><br><span class="line">int  <span class="regexp">//i</span>nt类型，其他一些内置类型是String，List bool</span><br><span class="line"></span><br><span class="line"><span class="number">42</span> <span class="regexp">//</span>数字，数字是一种编译时常量</span><br><span class="line"></span><br><span class="line">print() <span class="regexp">//</span>一种很方便的打印方法</span><br><span class="line"></span><br><span class="line"><span class="string">'......'</span> o<span class="string">r"......"</span> <span class="regexp">//</span>这两种都是表示字符串</span><br><span class="line"></span><br><span class="line"><span class="variable">$variableName</span> (or <span class="variable">$&#123;expression&#125;</span>)</span><br><span class="line"><span class="regexp">//</span>字符串插值：在字符串文字中包含一个变量或表达式的字符串。有关更多信息，请参阅字符串。</span><br><span class="line">main()  <span class="regexp">//</span>一个应用程序执行开始的特殊的、必须的函数，详情查看main函数</span><br><span class="line">var <span class="regexp">//</span>声明变量但不指定类型</span><br></pre></td></tr></table></figure><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>当你了解Dart语言时，要牢记这些事实和概念：</p><ul><li>你可以放在变量中的所有东西都是一个对象，每个对象都是一个类的实例。即使是数字，功能， null也是对象。所有对象都从Object类继承。</li><li>虽然Dart是强类型的，但类型注释是可选的，因为Dart可以推断类型。在上面的代码中，number 被推断为是类型的int。当你想明确地说没有类型时， 使用特殊类型dynamic。</li><li>Dart支持泛型类型，如List<int>（整数列表）或List<dynamic>（任何类型的对象列表）。</dynamic></int></li><li>Dart支持顶层函数（如main()），以及与类或对象绑定的函数（分别为静态方法和实例方法）。你也可以在函数中创建函数（嵌套函数或局部函数）。</li><li>同样，Dart支持顶级变量以及绑定到类或对象（静态变量和实例变量）的变量。实例变量有时称为字段或属性。</li><li>与Java，dart不具备关键字public，protected和private。如果标识符以下划线（_）开头，则它的库是私有的。有关详细信息，请参阅 库和可见性。</li><li>标识符可以以字母或下划线（_）开头，然后是这些字符和数字的任意组合。</li><li>有时候，重要的是某件事是一种<strong>表达式</strong>还是一种 <strong>声明</strong>，所以这两个词的确切含义很有帮助。</li><li>Dart工具可以报告两种问题：warnings 和errors。警告只是表明您的代码可能无法正常工作，但它们不会阻止您的程序执行。错误可以是编译时或运行时。编译时错误导致代码无法执行; 运行时错误导致 代码执行时引发异常。</li></ul><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>下表列出了Dart语言特别处理的关键词。<br>| abstract    | do           | import      | super     |<br>| ———– | :———– | ———– | ——— |<br>| abstract1   | do           | import 1    | super     |<br>| as 1        | dynamic 1    | in          | switch    |<br>| assert      | else         | interface 1 | sync<em> 2   |<br>| async 2     | enum         | is          | this      |<br>| async</em> 2    | export 1     | library 1   | throw     |<br>| await 2     | external 1   | mixin 1     | true      |<br>| break       | extends      | new         | try       |<br>| case        | factory 1    | null        | typedef 1 |<br>| catch       | false        | operator 1  | var       |<br>| class       | final        | part 1      | void      |<br>| const       | finally      | rethrow     | while     |<br>| continue    | for          | return      | with      |<br>| covariant 1 | get 1        | set 1       | yield 2   |<br>| default     | if           | static 1    | yield* 2  |<br>| deferred 1  | implements 1 |             |           |</p><p>1<strong>带上标1</strong>的单词是内置标识符。<br>避免使用内置标识符作为标识符。<br>如果您尝试为类或类型名称使用内置标识符，则会发生编译时错误。<br>2<strong>带上标2</strong>的单词是较新的，与Dart 1.0版本发布后添加的异步支持相关的有限保留字。<br>您不能使用async，await或yield作为用async，async <em>或sync </em>标记的任何函数体中的标识符。<br>有关更多信息，请参见<a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">异步支持</a></p><p><strong>关键字表中的所有其他字都是保留字。</strong><br>您不能使用保留字作为标识符**</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>以下是创建变量并初始化变量的示例：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> =<span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>变量存储的是引用，命名为name的变量存储的是 值为”Bob”的字符创的一个引用<br>name变量的类型被推断为String，但您可以通过指定它来更改该类型。<br>如果对象不限于单一类型，请遵循<a href="https://www.dartlang.org/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed" target="_blank" rel="noopener">设计指南</a>指定对象或动态类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">name</span> =<span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>另一种选择是显式声明将被推断的类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="keyword">name</span> = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>未初始化的变量的初始值为<strong>null</strong>。即使数字类型的变量最初为<strong>null</strong>，因为数字 - 和Dart中的其他所有数据一样 - <strong>都是对象</strong>。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lineCount;</span><br><span class="line"><span class="keyword">assert</span>(lineCount == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：assert()产品代码中 的调用被忽略。在开发过程中， 除非条件为真，否则会引发异常。有关详细信息，请参阅Assert。assert(condition)</strong></p></blockquote><h3 id="Final和const"><a href="#Final和const" class="headerlink" title="Final和const"></a>Final和const</h3><p>如果你从不打算改变一个变量，使用final或者const，而不是var或者其他类型。最终的变量只能设置一次; 一个const变量是一个编译时常量。（Const变量<strong>隐式final</strong> 。）final的顶层或者class变量在它第一次被使用时被初始化。</p><blockquote><p><strong>注意： 实例变量可以final但不是const。</strong></p></blockquote><p> 以下是创建和设置最终变量的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>; <span class="comment">// 没有类型声明</span></span><br><span class="line"><span class="comment">// name = 'Alice';  // 取消注释会导致UC哦呜</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">'Bobby'</span>;</span><br></pre></td></tr></table></figure><p>将const用于想要成为编译时常量的变量。<br>如果const变量处于类级别，则将其标记为静态常量。<br>在声明该变量的位置，将该值设置为编译时常量，例如数字或字符串文字，常量变量或常数上算术运算的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="number">1000000</span>; <span class="comment">// 压力单位(dynes/cm2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> atm = <span class="number">1.01325</span> * bar; <span class="comment">// 标准大气压</span></span><br></pre></td></tr></table></figure><p>该const关键字不只是声明常数变量。您也可以使用它来创建常量值，以及声明创建常量值的构造函数。任何变量都可以有一个常量值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">Note:</span> [] 创建一个空的list</span></span><br><span class="line"><span class="comment">// const [] 创建一个空的， 一成不变的list (简写为EIL).</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> []; <span class="comment">// foo 当前是一个 EIL(empty immutabe list).</span></span><br><span class="line"><span class="keyword">final</span> bar = <span class="keyword">const</span> []; <span class="comment">// bar 将永远是 EIL.</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="keyword">const</span> []; <span class="comment">// baz 是一个编译时常量 EIL.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can change the value of a non-final, non-const variable,</span></span><br><span class="line"><span class="comment">// even if it used to have a const value.</span></span><br><span class="line">foo = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can't change the value of a final or const variable.</span></span><br><span class="line"><span class="comment">// bar = []; // Unhandled exception.</span></span><br><span class="line"><span class="comment">// baz = []; // Unhandled exception.</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本页向您展示了如何使用每个主要的Dart特性，从变量和运算符到类和库，假定您已经知道如何用另一种语言编程。要了解有关Dart核心库的更多信息，请参阅&lt;a href=&quot;https://www.dartlang.org/guides/libraries
      
    
    </summary>
    
      <category term="Dart学习" scheme="http://yoursite.com/categories/Dart%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Dart学习" scheme="http://yoursite.com/tags/Dart%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android权限列表</title>
    <link href="http://yoursite.com/2018/06/22/android/Android%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/22/android/Android权限列表/</id>
    <published>2018-06-22T05:16:32.000Z</published>
    <updated>2018-06-22T05:17:44.664Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.csdn.net/ufo00001/article/details/69397256" target="_blank" rel="noopener">http://blog.csdn.net/ufo00001/article/details/69397256</a></p><table><thead><tr><th>1.android.permission.WRITE_USER_DICTIONARY</th><th>允许应用程序向用户词典中写入新词 </th></tr></thead><tbody><tr><td>2.android.permission.WRITE_SYNC_SETTINGS</td><td>写入Google在线同步设置 </td></tr><tr><td>3.android.permission.WRITE_SOCIAL_STREAM</td><td>读取用户的社交信息流 </td></tr><tr><td>4.android.permission.WRITE_SMS</td><td>允许程序写短信 </td></tr><tr><td>5.android.permission.WRITE_SETTINGS</td><td>允许程序读取或写入系统设置 </td></tr><tr><td>6.android.permission.WRITE_SECURE_SETTINGS</td><td>允许应用程序读取或写入安全系统设置 </td></tr><tr><td>7.android.permission.WRITE_PROFILE</td><td>允许程序写入个人资料数据 </td></tr><tr><td>8.com.android.browser.permission.WRITE_HISTORY_BOOKMARKS</td><td>允许一个应用程序写（但不可读）用户的浏览历史和书签 </td></tr><tr><td>9.android.permission.WRITE_GSERVICES</td><td>允许程序修改Google服务地图 </td></tr><tr><td>10.android.permission.WRITE_EXTERNAL_STORAGE</td><td>允许程序写入外部存储，如SD卡上写文件 </td></tr><tr><td>11.android.permission.WRITE_CONTACTS</td><td>写入联系人，但不可读取 </td></tr><tr><td>12.android.permission.WRITE_CALL_LOG</td><td>允许程序写入（但是不能读）用户的联系人数据 </td></tr><tr><td>13.android.permission.WRITE_CALENDAR</td><td>允许程序写入日程，但不可读取 </td></tr><tr><td>14.android.permission.WRITE_APN_SETTINGS</td><td>允许程序写入网络GPRS接入点设置 </td></tr><tr><td>15.android.permission.WAKE_LOCK</td><td>允许程序在手机屏幕关闭后后台进程仍然运行 </td></tr><tr><td>16.android.permission.VIBRATE</td><td>允许程序振动 </td></tr><tr><td>17.android.permission.USE_SIP</td><td>允许程序使用SIP视频服务 </td></tr><tr><td>18.android.permission.USE_CREDENTIALS</td><td>允许程序请求验证从AccountManager </td></tr><tr><td>19.android.permission.UPDATE_DEVICE_STATS</td><td>允许程序更新设备状态 </td></tr><tr><td>20.com.android.launcher.permission.UNINSTALL_SHORTCUT</td><td>删除快捷方式 </td></tr><tr><td>21.android.permission.TRANSMIT_IR</td><td>允许使用设备的红外发射器，如果可用 </td></tr><tr><td>22.android.permission.SYSTEM_ALERT_WINDOW</td><td>允许程序显示系统窗口 </td></tr><tr><td>23.android.permission.SUBSCRIBED_FEEDS_WRITE</td><td>允许程序写入或修改订阅内容的数据库 </td></tr><tr><td>24.android.permission.SUBSCRIBED_FEEDS_READ</td><td>允许程序访问订阅信息的数据库 </td></tr><tr><td>22.android.permission.STATUS_BAR</td><td>允许程序打开、关闭、禁用状态栏 </td></tr><tr><td>23.android.permission.SIGNAL_PERSISTENT_PROCESSES</td><td>允许程序发送一个永久的进程信号 </td></tr><tr><td>24.android.permission.SET_WALLPAPER_HINTS</td><td>允许程序设置壁纸建议 </td></tr><tr><td>25.android.permission.SET_WALLPAPER</td><td>允许程序设置桌面壁纸 </td></tr><tr><td>26.android.permission.SET_TIME_ZONE</td><td>允许程序设置系统时区 </td></tr><tr><td>27.android.permission.SET_TIME</td><td>允许程序设置系统时间 </td></tr><tr><td>28.android.permission.SET_PROCESS_LIMIT</td><td>允许程序设置最大的进程数量的限制 </td></tr><tr><td>29.android.permission.SET_PREFERRED_APPLICATIONS</td><td>允许程序设置应用的参数，<br>已不再工作具体查看addPackageToPreferred（String） 介绍 </td></tr><tr><td>30.android.permission.SET_POINTER_SPEED</td><td>无法被第三方应用获得，系统权限 </td></tr><tr><td>31.android.permission.SET_ORIENTATION</td><td>允许程序设置屏幕方向为横屏或标准方式显示，不用于普通应用 </td></tr><tr><td>32.android.permission.SET_DEBUG_APP</td><td>允许程序设置调试程序，一般用于开发 </td></tr><tr><td>33.android.permission.SET_ANIMATION_SCALE</td><td>允许程序设置全局动画缩放 </td></tr><tr><td>34.android.permission.SET_ALWAYS_FINISH</td><td>允许程序设置程序在后台是否总是退出 </td></tr><tr><td>36.com.android.alarm.permission.SET_ALARM</td><td>允许程序设置闹铃提醒 </td></tr><tr><td>37.android.permission.SET_ACTIVITY_WATCHER</td><td>允许程序设置Activity观察器<br>一般用于monkey测试 </td></tr><tr><td>38.android.permission.SEND_SMS</td><td>允许程序发送短信 </td></tr><tr><td>39.android.permission.SEND_RESPOND_VIA_MESSAGE</td><td>允许用户在来电的时候用你的应用进行即时的短信息回复。 </td></tr><tr><td>40.android.permission.RESTART_PACKAGES</td><td>允许程序结束任务通过<br>restartPackage（String）方法，该方式将在外来放弃</td></tr><tr><td>41.android.permission.REORDER_TASKS</td><td>允许程序重新排序系统Z轴运行中的任务 </td></tr><tr><td>42.android.permission.RECORD_AUDIO</td><td>允许程序录制声音通过手机或耳机的麦克 </td></tr><tr><td>43.android.permission.RECEIVE_WAP_PUSH</td><td>允许程序接收WAP PUSH信息 </td></tr><tr><td>44.android.permission.RECEIVE_SMS</td><td>允许程序接收短信 </td></tr><tr><td>45.android.permission.RECEIVE_MMS</td><td>允许程序接收彩信 </td></tr><tr><td>46.android.permission.RECEIVE_BOOT_COMPLETED</td><td>允许程序开机自动运行 </td></tr><tr><td>47.android.permission.REBOOT</td><td>允许程序重新启动设备 </td></tr><tr><td>48.android.permission.READ_USER_DICTIONARY</td><td>从一个提供器中获取数据，针对对应的提供器，应用程序需要“读访问权限” </td></tr><tr><td>49.android.permission.READ_SYNC_STATS</td><td>允许程序读取同步状态，获得Google在线同步状态 </td></tr><tr><td>50.android.permission.READ_SYNC_SETTINGS</td><td>允许程序读取同步设置，读取Google在线同步设置 </td></tr><tr><td>51.android.permission.READ_SOCIAL_STREAM</td><td>读取用户的社交信息流 </td></tr><tr><td>52.android.permission.READ_SMS</td><td>允许程序读取短信内容 </td></tr><tr><td>53.android.permission.READ_PROFILE</td><td>访问用户个人资料 </td></tr><tr><td>54.android.permission.READ_PHONE_STATE</td><td>允许程序访问电话状态 </td></tr><tr><td>55.android.permission.READ_LOGS</td><td>允许程序读取系统底层日志 </td></tr><tr><td>56.android.permission.READ_INPUT_STATE</td><td>允许程序读取当前键的输入状态，仅用于系统 </td></tr><tr><td>57.com.android.browser.permission.READ_HISTORY_BOOKMARKS</td><td>允许程序读取浏览器收藏夹和历史记录 </td></tr><tr><td>58.android.permission.READ_FRAME_BUFFER</td><td>允许程序读取帧缓存用于屏幕截图 </td></tr><tr><td>59.android.permission.READ_EXTERNAL_STORAGE</td><td>程序可以读取设备外部存储空间（内置SDcard和外置SDCard）的文件，如果您的App已经添加<br>了“WRITE_EXTERNAL_STORAGE ”权限 ，则就没必要添加读的权限了，写权限已经包含了读权限了。 </td></tr><tr><td>60.android.permission.READ_CONTACTS</td><td>允许程序访问联系人通讯录信息 </td></tr><tr><td>61.android.permission.READ_CALL_LOG</td><td>读取通话记录 </td></tr><tr><td>62.android.permission.READ_CALENDAR</td><td>允许程序读取用户的日程信息 </td></tr><tr><td>63.android.permission.PROCESS_OUTGOING_CALLS</td><td>允许程序监视，修改或放弃播出电话 </td></tr><tr><td>64.android.permission.PERSISTENT_ACTIVITY</td><td>允许程序创建一个永久的Activity，该功能标记为将来将被移除 </td></tr><tr><td>65.android.permission.NFC</td><td>允许程序执行NFC近距离通讯操作，用于移动支持 </td></tr><tr><td>66.android.permission.MOUNT_UNMOUNT_FILESYSTEMS</td><td>允许程序挂载、反挂载外部文件系统 </td></tr><tr><td>67.android.permission.MOUNT_FORMAT_FILESYSTEMS</td><td>允许程序格式化可移动文件系统，比如格式化清空SD卡 </td></tr><tr><td>68.android.permission.MODIFY_PHONE_STATE</td><td>允许程序修改电话状态，如飞行模式，但不包含替换系统拨号器界面 </td></tr><tr><td>69.android.permission.MODIFY_AUDIO_SETTINGS</td><td>允许程序修改声音设置信息 </td></tr><tr><td>70.android.permission.MEDIA_CONTENT_CONTROL</td><td>允许一个应用程序知道什么是播放和控制其内容。不被第三方应用使用。 </td></tr><tr><td>71.android.permission.MASTER_CLEAR</td><td>允许程序执行软格式化，删除系统配置信息 </td></tr><tr><td>72.android.permission.MANAGE_DOCUMENTS</td><td>允许一个应用程序来管理文档的访问，通常是一个文档选择器部分 </td></tr><tr><td>73.android.permission.MANAGE_APP_TOKENS</td><td>管理创建、摧毁、Z轴顺序，仅用于系统 </td></tr><tr><td>74.android.permission.MANAGE_ACCOUNTS</td><td>允许程序管理AccountManager中的账户列表 </td></tr><tr><td>75.android.permission.LOCATION_HARDWARE</td><td>允许一个应用程序中使用定位功能的硬件，不使用第三方应用 </td></tr><tr><td>76.android.permission.KILL_BACKGROUND_PROCESSES</td><td>允许程序调用killBackgroundProcesses（String）。方法结束后台进程 </td></tr><tr><td>77.android.permission.INTERNET</td><td>允许程序访问网络连接，可能产生GPRS流量 </td></tr><tr><td>78.android.permission.INTERNAL_SYSTEM_WINDOW</td><td>允许程序打开内部窗口，不对第三方应用程序开放此权限 </td></tr><tr><td>79.com.android.launcher.permission.INSTALL_SHORTCUT</td><td>创建快捷方式 </td></tr><tr><td>80.android.permission.INSTALL_PACKAGES</td><td></td></tr><tr><td>81.android.permission.INSTALL_LOCATION_PROVIDER</td><td>允许程序安装定位提供 </td></tr><tr><td>82.android.permission.INJECT_EVENTS</td><td>允许程序访问本程序的底层事件，获取按键、轨迹球的事件流 </td></tr><tr><td>83.android.permission.HARDWARE_TEST</td><td>允许程序访问硬件辅助设备，用于硬件测试 </td></tr><tr><td>84.android.permission.GLOBAL_SEARCH</td><td>允许程序允许全局搜索 </td></tr><tr><td>85.android.permission.GET_TOP_ACTIVITY_INFO</td><td>允许一个应用程序检索私有信息是当前最顶级的活动，不被第三方应用使用 </td></tr><tr><td>86.android.permission.GET_TASKS</td><td>允许程序获取任务信息 </td></tr><tr><td>87.android.permission.GET_PACKAGE_SIZE</td><td>允许程序获取应用的文件大小 </td></tr><tr><td>88.android.permission.GET_ACCOUNTS</td><td>允许程序访问账户Gmail列表 </td></tr><tr><td>89.android.permission.FORCE_BACK</td><td>允许程序强制使用back后退按键，无论Activity是否在顶层 </td></tr><tr><td>90.android.permission.FLASHLIGHT</td><td>允许访问闪光灯 </td></tr><tr><td>91.android.permission.FACTORY_TEST</td><td>允许程序运行工厂测试模式 </td></tr><tr><td>92.android.permission.EXPAND_STATUS_BAR</td><td>允许程序扩展或收缩状态栏 </td></tr><tr><td>93.android.permission.DUMP</td><td>允许程序获取系统dump信息从系统服务 </td></tr><tr><td>94.android.permission.DISABLE_KEYGUARD</td><td>允许程序禁用键盘锁 </td></tr><tr><td>95.android.permission.DIAGNOSTIC</td><td>允许程序到RW到诊断资源 </td></tr><tr><td>96.android.permission.DEVICE_POWER</td><td>允许程序访问底层电源管理 </td></tr><tr><td>97.android.permission.DELETE_PACKAGES</td><td>允许程序删除应用 </td></tr><tr><td>98.android.permission.DELETE_CACHE_FILES</td><td>允许程序删除缓存文件 </td></tr><tr><td>99.android.permission.CONTROL_LOCATION_UPDATES</td><td>允许程序获得移动网络定位信息改变 </td></tr><tr><td>100.android.permission.CLEAR_APP_USER_DATA</td><td>允许程序清除用户数据 </td></tr><tr><td>101.android.permission.CLEAR_APP_CACHE</td><td>允许程序清除应用缓存 </td></tr><tr><td>102.android.permission.CHANGE_WIFI_STATE</td><td>允许程序改变WiFi状态 </td></tr><tr><td>103.android.permission.CHANGE_WIFI_MULTICAST_STATE</td><td>允许程序改变WiFi多播状态 </td></tr><tr><td>104.android.permission.CHANGE_NETWORK_STATE</td><td>允许程序改变网络状态，如是否联网 </td></tr><tr><td>105.android.permission.CHANGE_CONFIGURATION</td><td>允许当前应用改变配置，如定位 </td></tr><tr><td>106.android.permission.CHANGE_COMPONENT_ENABLED_STATE</td><td>改变组件是否启用状态 </td></tr><tr><td>107.android.permission.CAPTURE_VIDEO_OUTPUT</td><td>允许一个应用程序捕获视频输出，不被第三方应用使用 </td></tr><tr><td>108.android.permission.CAPTURE_SECURE_VIDEO_OUTPUT</td><td>允许一个应用程序捕获视频输出。不被第三方应用使用 </td></tr><tr><td>109.android.permission.CAPTURE_AUDIO_OUTPUT</td><td>允许一个应用程序捕获音频输出。不被第三方应用使用 </td></tr><tr><td>110.android.permission.CAMERA</td><td>允许程序访问摄像头进行拍照 </td></tr><tr><td>111.android.permission.CALL_PRIVILEGED</td><td>允许程序拨打电话，替换系统的拨号器界面 </td></tr><tr><td>112.android.permission.CALL_PHONE</td><td>允许程序从非系统拨号器里拨打电话 </td></tr><tr><td>113.android.permission.BROADCAST_WAP_PUSH</td><td>WAP PUSH服务收到后触发一个广播 </td></tr><tr><td>114.android.permission.BROADCAST_STICKY</td><td>允许程序收到广播后快速收到下一个广播 </td></tr><tr><td>115.android.permission.BROADCAST_SMS</td><td>允许程序当收到短信时触发一个广播 </td></tr><tr><td>116.android.permission.BROADCAST_PACKAGE_REMOVED</td><td>允许程序删除时广播 </td></tr><tr><td>117.android.permission.BRICK</td><td>能够禁用手机，非常危险，顾名思义就是让手机变成砖头 </td></tr><tr><td>118.android.permission.BLUETOOTH_PRIVILEGED</td><td>允许应用程序配对蓝牙设备，而无需用户交互。这不是第三方应用程序可用。 </td></tr><tr><td>119.android.permission.BLUETOOTH_ADMIN</td><td>允许程序进行发现和配对新的蓝牙设备 </td></tr><tr><td>120.android.permission.BLUETOOTH</td><td>允许程序连接配对过的蓝牙设备 </td></tr><tr><td>121.android.permission.BIND_WALLPAPER</td><td>必须通过WallpaperService服务来请求，只有系统才能用 </td></tr><tr><td>122.android.permission.BIND_VPN_SERVICE</td><td>绑定VPN服务必须通过VpnService服务来请求，只有系统才能用 </td></tr><tr><td>123.android.permission.BIND_TEXT_SERVICE</td><td>必须要求textservice（例如吗 spellcheckerservice），以确保只有系统可以绑定到它。 </td></tr><tr><td>124.android.permission.BIND_REMOTEVIEWS</td><td>必须通过RemoteViewsService服务来请求，只有系统才能用 </td></tr><tr><td>125.android.permission.BIND_PRINT_SERVICE</td><td>必须要求由printservice，以确保只有系统可以绑定到它。 </td></tr><tr><td>126.android.permission.BIND_NOTIFICATION_LISTENER_SERVICE</td><td>必须要求由notificationlistenerservice，以确保只有系统可以绑定到它。 </td></tr><tr><td>127.android.permission.BIND_NFC_SERVICE</td><td>由hostapduservice或offhostapduservice必须确保只有系统可以绑定到它。 </td></tr><tr><td>128.android.permission.BIND_INPUT_METHOD</td><td>请求InputMethodService服务，只有系统才能使用 </td></tr><tr><td>129.android.permission.BIND_DEVICE_ADMIN</td><td>请求系统管理员接收者receiver，只有系统才能使用 </td></tr><tr><td>130.android.permission.BIND_APPWIDGET</td><td>允许程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 </td></tr><tr><td>131.android.permission.BIND_ACCESSIBILITY_SERVICE</td><td>请求accessibilityservice服务，以确保只有系统可以绑定到它。 </td></tr><tr><td>132.android.permission.AUTHENTICATE_ACCOUNTS</td><td>允许程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 </td></tr><tr><td>133.com.android.voicemail.permission.ADD_VOICEMAIL</td><td>允许一个应用程序添加语音邮件系统 </td></tr><tr><td>134.android.permission.ACCOUNT_MANAGER</td><td>允许程序获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 </td></tr><tr><td>135.android.permission.ACCESS_WIFI_STATE</td><td>允许程序获取当前WiFi接入的状态以及WLAN热点的信息 </td></tr><tr><td>136.android.permission.ACCESS_SURFACE_FLINGER</td><td>Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 </td></tr><tr><td>137.android.permission.ACCESS_NETWORK_STATE</td><td>允许程序获取网络信息状态，如当前的网络连接是否有效 </td></tr><tr><td>138.android.permission.ACCESS_MOCK_LOCATION</td><td>允许程序获取模拟定位信息，一般用于帮助开发者调试应用 </td></tr><tr><td>139.android.permission.ACCESS_LOCATION_EXTRA_COMMANDS</td><td>允许程序访问额外的定位提供者指令 </td></tr><tr><td>140.android.permission.ACCESS_FINE_LOCATION</td><td>允许程序通过GPS芯片接收卫星的定位信息 </td></tr><tr><td>141.android.permission.ACCESS_COARSE_LOCATION</td><td>允许程序通过WiFi或移动基站的方式获取用户错略的经纬度信息 </td></tr><tr><td>142.android.permission.ACCESS_CHECKIN_PROPERTIES</td><td>允许程序读取或写入登记check-in数据库属性表的权限</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;http://blog.csdn.net/ufo00001/article/details/69397256&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/ufo00001/articl
      
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android运行时权限总结</title>
    <link href="http://yoursite.com/2018/06/22/android/Android%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/22/android/Android运行时权限总结/</id>
    <published>2018-06-22T02:50:27.000Z</published>
    <updated>2018-06-22T03:50:52.271Z</updated>
    
    <content type="html"><![CDATA[<p>###1、android6.0以后的危险权限介绍<br>（注意：Android O  8.0对于权限更加严格，下面会说一下8.0）<br>android6.0以后有些危险权限需要手动去授权，就有了运行时权限的处理。下面的表格就是危险权限组：</p><table><thead><tr><th>权限组名</th><th>权限名</th></tr></thead><tbody><tr><td>CALENDAR  日历</td><td>READ_CALENDAR<br>WRITE_CALENDER</td></tr><tr><td>CAMERA      相机</td><td>CAMERA</td></tr><tr><td>CONTACTS 联系人</td><td>READ_CONTACTS<br>WRITE_CONTACTS<br>GET_ACCOUNTS</td></tr><tr><td>LOCATION  定位</td><td>ACCESS_FINE_LOCATION<br>ACCESS_COARSE_LOCATION</td></tr><tr><td>MICROPHONE 麦克风</td><td>RECORD_AUDIO</td></tr><tr><td>PHONE 电话</td><td>READ_PHONE_STATE<br>CALL_PHONE<br>READ_CALL_LOG<br>WRITE_CALL_LOG<br>ADD_VOICEMAIL<br>USE_SIP<br>PROCESS_OUTGOING_CALLS</td></tr><tr><td>SENSORS 传感器</td><td>BODY_SENSORS</td></tr><tr><td>SMS  短信</td><td>Short Message Service<br>SEND_SMS<br>RECEIVE_SMS<br>READ_SMS<br>RECEIVE_WAP_PUSH<br>RECEIVE_MMS</td></tr><tr><td>STORAGE 数据存储</td><td>READ_EXTRAL_STRORAGE<br>WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><p>申请权限时：<br>1、在清单文件中声明权限（如果不在这张表中，声明完就可以了）<br>2、如果在这张表中的权限需要手动来申请</p><p>这些权限6.0以后需要手动申请，，每一个权限组中的权限只要有一个权限同意授权了，整个权限组中的权限就不用重复申请了。<br><strong>如果如果查看所有的权限，请参考：<a href="https://segmentfault.com/a/1190000012259370" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012259370</a></strong></p><p>###2、运行时权限申请过程：<br>传统的申请过程是：<br>1、在AndroidManifest文件中添加需要的权限。<br>2、检查权限是否授权<br>3、申请权限<br>4、处理授权的结果</p><p>一步步来：<br><strong>1、首先在请单文件中声明，这个不用说</strong><br><strong>2、检查权限是否授权</strong></p><pre><code>if (ContextCompat.checkSelfPermission(thisActivity,            Manifest.permission.READ_CONTACTS)    != PackageManager.PERMISSION_GRANTED) {    //没有授权，编写申请权限代码}else{//已经授权，执行操作代码}    </code></pre><p>   基本上调用checkSelfPermission()函数传入权限参数，返回的结果又两个：<br>如果是已授权的权限，该方法返回结果是 PackageManager.PERMISSION_GRANTED 常量为 0，<br>如果是未授权的权限，该方法返回结果是 PackageManager.PERMISSION_DENIED 常量为 -1。<br>这样就可以判断是否已经授权，来进行下一步的操作。</p><p><strong>3、如果没有授权，需要申请权限</strong><br>    ActivityCompat.requestPermissions(thisActivity,<br>                new String[]{Manifest.permission.READ_CONTACTS},<br>                MY_PERMISSIONS_REQUEST_READ_CONTACTS);<br>  这是一个异步的方法，第一个参数是Context；第二个参数是需要申请的权限的字符串数组（这个是支持同时申请多个权限，系统会逐个询问是否授权）；第三个参数为请求码requestCode，主要用于回调的时候检测。</p><p><strong>4、处理权限申请的回调结果</strong><br>重写Activity或者fragment的 onRequestPermissionsResul()方法<br>      //权限回调方法<br>    @Override<br>    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</p><pre><code>    switch (requestCode){        case 0:            //grantResults数组存储的申请的返回结果，            //PERMISSION_GRANTED 表示申请成功            if (grantResults.length&gt;0&amp;&amp;grantResults[0]== PackageManager.PERMISSION_GRANTED){                //授权成功，                //这里写相应的 操作代码            }else{                //授权失败，可以简单提示用户                Toast.makeText(this, &quot;没有授权继续操作&quot;, Toast.LENGTH_SHORT).show();            }            break;        case 1:            //同上            break;        default:            break;    }}这里稍微说一下，申请的时候是一个一个的申请的话，每次申请都有一个请求码，这里的grantResults数组就只有一个值，所以都是grantResults[0]来和PERMISSION_GRANTED来进行比较如果是一次申请多个权限，grantResults数组返回的值就不止一个，但是，直接遍历它就行，只要全部满足条件才算申请成功，才能进行相应的操作一般的写法是：通过if判断权限是否申请，没有申请，把它加到一个集合里面，把所有的权限都判断一遍以后，去遍历这个集合，只要有一个没有申请的，就需、要去申请权限，    把这个集合转为数组，传到requestPermissions的第二个参数，然后就处理相应 结果就可以了，遍历grantResults数组，判断是不是全部满足条件</code></pre><p>###3、EasyPermissions的使用<br>GitHub地址：<a href="https://github.com/googlesamples/easypermissions" target="_blank" rel="noopener">https://github.com/googlesamples/easypermissions</a><br>   EasyPermissions是谷歌封装的一个运行时权限申请的库，简化了操作的过程。<br>使用过程： 没有什么先后顺序，下面没有按这个顺序。这么做是可以的，当然还有其他的使用方法</p><blockquote><p>1、builde gradle中依赖<br>2、清单文件中声明权限<br>3、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions来<br>4、通过hasPermissions检查权限，或者原生的也行，然后去申请权限<br>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法，成功或失败<br>6、在成功或者失败方法中编写要具体做的事。</p></blockquote><p>GitHub地址：<br><strong>(1)依赖库</strong><br>    dependencies {<br>        compile ‘pub.devrel:easypermissions:1.0.1’<br>    }</p><p><strong>(2)再在清单文件中声明要申请的危险权限</strong><br>如果不声明的话，直接在代码中写也能申请成功，但是好想不会弹出询问框，直接就申请了</p><p><strong>(3)申请权限</strong><br>可以直接申请<br>    EasyPermissions.requestPermissions(<br>                        MainActivity.this,<br>                        “申请权限”,<br>                        0,<br>                        Manifest.permission.WRITE_EXTERNAL_STORAGE,<br>                        Manifest.permission.RECORD_AUDIO);<br>最好还是检查一下权限是否申请：<br><strong>EasyPermissions.hasPermissions(Context context, @NonNull String… perms)</strong>方法来检测一个或者多个权限是否被允许，第二个参数是个可变数组，可以申请多个<br>    String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};<br>    if (EasyPermissions.hasPermissions(this, perms)) {</p><pre><code>    // 已经申请过权限，做想做的事} else {    // 没有申请过权限，现在去申请    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),            RC_CAMERA_AND_LOCATION, perms);}</code></pre><p>下面来说一个申请权限这个方法：<br>EasyPermissions.requestPermissions():<img src="/img/bVZBii" alt="图片描述"></p><p>requestPermissions() 一般用这个四个参数的就可以<br>第一个参数：Context对象<br>第二个参数：权限弹窗上的文字提示语。告诉用户，这个权限用途。<br>第三个参数：这次请求权限的唯一标识请求码，code。<br>第四个参数 : 一些系列的权限。<br>   这里说一下第二个参数，不是第一次申请系统默认弹出的提示语，而是，我们拒绝后，再次点击申请弹出的对话框，，显示我们设置的提示语，下面有两个按钮，确认和取消，我就不贴图了。</p><p>还有六个参数的，多了两个参数就是，修改我们上面那个确认和取消的字样，你可以干成yes 和no. </p><p><strong>4、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions    </strong><br>一行代码就搞定了<br>     @Override<br>    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>        super.onRequestPermissionsResult(requestCode, permissions, grantResults);<br>        EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);<br>    }</p><p><strong>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法</strong><br>    public class MainActivity extends AppCompatActivity implements EasyPermissions.PermissionCallbacks {</p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);}@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {    super.onRequestPermissionsResult(requestCode, permissions, grantResults);    // 把执行结果的操作给EasyPermissions    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);}@Override //申请成功时调用public void onPermissionsGranted(int requestCode, List&lt;String&gt; list) {    //请求成功执行相应的操作    比如，举个例子    switch (requestCode){        case 0:            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();            break;        case 1:            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();            break;    }}@Override //申请失败时调用public void onPermissionsDenied(int requestCode, List&lt;String&gt; list) {    // 请求失败，执行相应操作}}</code></pre><p>接下来就要说一下成功或者失败后的操作了： 申请成功就直接做该做的事就行了，没啥。<br>申请如果失败了，这时候有个方法出现了EasyPermissions.somePermissionPermanentlyDenied(this, perms)<br>这个方法是谷歌建议的。就是在我们点了不在询问并拒绝，会弹出对话框，告诉用户这个权限时干嘛的，很重要，建议不要拒绝哈哈<br>比如这样：  </p><pre><code>@Overridepublic void onPermissionsDenied(int requestCode, List&lt;String&gt; perms) {if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {    new AppSettingsDialog.Builder(this).build().show();    //弹出个对话框}</code></pre><p>}                 </p><p>当然我们可以定制一下这个对话框：<br>    @Override<br>    public void onPermissionsDenied(int requestCode, List<string> perms) {<br>        //处理权限名字字符串<br>        StringBuffer sb = new StringBuffer();<br>        for (String str : perms){<br>            sb.append(str);<br>            sb.append(“\n”);<br>        }<br>        sb.replace(sb.length() - 2,sb.length(),””);</string></p><pre><code>    switch (requestCode){        case 0:            Toast.makeText(this, &quot;已拒绝权限&quot; + perms.get(0), Toast.LENGTH_SHORT).show();            break;        case 1:            Toast.makeText(this, &quot;已拒绝WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;+ perms.get(0), Toast.LENGTH_SHORT).show();            break;    }    if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {        Toast.makeText(this, &quot;已拒绝权限&quot; + sb + &quot;并不再询问&quot; , Toast.LENGTH_SHORT).show();        new AppSettingsDialog                .Builder(this)                .setRationale(&quot;此功能需要&quot; + sb + &quot;权限，否则无法正常使用，是否打开设置&quot;)                .setPositiveButton(&quot;是&quot;)                .setNegativeButton(&quot;否&quot;)                .build()                .show();    }}</code></pre><p><strong>6、(可选)@AfterPermissionGranted()注解</strong></p><p>使用 AfterPermissioonGranted 注解。这是可选的，但是提供出来是为了方便。如果所有的请求的权限都被授予了，被注解的方法将会被执行，这样做是为了简化通常的请求权限成功之后再调用方法的流程。同时也可以在onPermissionsGranted 的回调中添加逻辑操作：<br>比如官网上的这个实例代码：<br>这里的方法名可以自己取，主要是权限都申请完，就调用这个方法，执行里面的操作。<br>其实就相当于在onPermissionsGranted()调用这个方法而已:</p><pre><code>@AfterPermissionGranted(RC_CAMERA_AND_LOCATION)private void methodRequiresTwoPermission() {String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};if (EasyPermissions.hasPermissions(this, perms)) {    // Already have permission, do the thing    // ...} else {    // Do not have permissions, request them now    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),            RC_CAMERA_AND_LOCATION, perms);}}</code></pre><p>基本上介绍完了</p><p>###4、android 8.0运行时权限<br>对于针对Android O的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p><p>例如，假设某个应用在其清单中列出READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE。应用请求READ_EXTERNAL_STORAGE，并且用户授予了该权限，如果该应用针对的是API级别24或更低级别，系统还会同时授予WRITE_EXTERNAL_STORAGE，因为该权限也属于STORAGE权限组并且也在清单中注册过。如果该应用针对的是Android O，则系统此时仅会授予READ_EXTERNAL_STORAGE，不过在该应用以后申请WRITE_EXTERNAL_STORAGE权限时，系统会立即授予该权限，而不会提示用户。<br><strong>注意：如果使用了没有授权的权限，会崩溃的</strong></p><p>所以对于8.0权限，我们要做的处理，是尽量把所用到的危险权限全部申请。但是有的权限在不同版本出现，所以要兼容不同的版本，所以要加一个版本的判断。</p><blockquote><p>归根结底：android M (6.0)以后，申请权限组一个，即表示整个权限组可以用，所以我们干脆，只要api 版本大于23（6.0）,我们申请的权限就是申请整个权限组。这样就兼容了android8.0——————-为了省事的话可以用AndPermission这个第三方框架，或者自己封装一个。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###1、android6.0以后的危险权限介绍&lt;br&gt;（注意：Android O  8.0对于权限更加严格，下面会说一下8.0）&lt;br&gt;android6.0以后有些危险权限需要手动去授权，就有了运行时权限的处理。下面的表格就是危险权限组：&lt;/p&gt;
&lt;table&gt;
&lt;the
      
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
</feed>
