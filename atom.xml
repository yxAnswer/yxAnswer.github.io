<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术成长之路</title>
  
  <subtitle>Simple technology</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-05T16:31:09.296Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨旭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Jackson快速入门——转载</title>
    <link href="http://yoursite.com/2018/10/06/springboot/Jackson%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E8%BD%AC%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/10/06/springboot/Jackson快速入门——转载/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:31:09.296Z</updated>
    
    <content type="html"><![CDATA[<p>Java生态圈中有很多处理JSON和XML格式化的类库，Jackson是其中比较著名的一个。虽然JDK自带了XML处理类库，但是相对来说比较低级，使用本文介绍的Jackson等高级类库处理起来会方便很多。</p><h3 id="引入类库"><a href="#引入类库" class="headerlink" title="引入类库"></a>引入类库</h3><p>由于Jackson相关类库按照功能分为几个相对独立的，所以需要同时引入多个类库，为了方便我将版本号单独提取出来设置，相关Gradle配置如下。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    jacksonVersion = <span class="string">'2.9.5'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.core'</span>, <span class="string">name:</span> <span class="string">'jackson-core'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.core'</span>, <span class="string">name:</span> <span class="string">'jackson-databind'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.core'</span>, <span class="string">name:</span> <span class="string">'jackson-annotations'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    <span class="comment">// 引入XML功能</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.dataformat'</span>, <span class="string">name:</span> <span class="string">'jackson-dataformat-xml'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    <span class="comment">// 比JDK自带XML实现更高效的类库</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.woodstox'</span>, <span class="string">name:</span> <span class="string">'woodstox-core'</span>, <span class="string">version:</span> <span class="string">'5.1.0'</span></span><br><span class="line">    <span class="comment">// Java 8 新功能</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.datatype'</span>, <span class="string">name:</span> <span class="string">'jackson-datatype-jsr310'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.module'</span>, <span class="string">name:</span> <span class="string">'jackson-module-parameter-names'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.datatype'</span>, <span class="string">name:</span> <span class="string">'jackson-datatype-jdk8'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line"></span><br><span class="line">    compileOnly <span class="string">group:</span> <span class="string">'org.projectlombok'</span>, <span class="string">name:</span> <span class="string">'lombok'</span>, <span class="string">version:</span> <span class="string">'1.16.22'</span></span><br><span class="line">&#125;<span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure></p><p>Maven配置请去mvnrepository搜索。</p><h3 id="Jackson注解"><a href="#Jackson注解" class="headerlink" title="Jackson注解"></a>Jackson注解</h3><p>Jackson类库包含了很多注解，可以让我们快速建立Java类与JSON之间的关系。详细文档可以参考<a href="https://github.com/FasterXML/jackson-annotations/wiki/Jackson-Annotations" target="_blank" rel="noopener">Jackson-Annotations</a>。下面介绍一下常用的。</p><h4 id="属性命名"><a href="#属性命名" class="headerlink" title="属性命名"></a>属性命名</h4><p><code>@JsonProperty</code>注解指定一个属性用于JSON映射，默认情况下映射的JSON属性与注解的属性名称相同，不过可以使用该注解的value值修改JSON属性名，该注解还有一个index属性指定生成JSON属性的顺序，如果有必要的话。</p><h4 id="属性包含"><a href="#属性包含" class="headerlink" title="属性包含"></a>属性包含</h4><p>还有一些注解可以管理在映射JSON的时候包含或排除某些属性，下面介绍一下常用的几个。</p><p><code>@JsonIgnore</code>注解用于排除某个属性，这样该属性就不会被Jackson序列化和反序列化。</p><p><code>@JsonIgnoreProperties</code>注解是类注解。在序列化为JSON的时候，<code>@JsonIgnoreProperties({&quot;prop1&quot;, &quot;prop2&quot;})</code>会忽略pro1和pro2两个属性。在从JSON反序列化为Java类的时候，<code>@JsonIgnoreProperties(ignoreUnknown=true)</code>会忽略所有没有Getter和Setter的属性。该注解在Java类和JSON不完全匹配的时候很有用。</p><p><code>@JsonIgnoreType</code>也是类注解，会排除所有指定类型的属性。</p><h4 id="序列化相关"><a href="#序列化相关" class="headerlink" title="序列化相关"></a>序列化相关</h4><p><code>@JsonPropertyOrder</code>和<code>@JsonProperty</code>的index属性类似，指定属性序列化时的顺序。</p><p><code>@JsonRootName</code>注解用于指定JSON根属性的名称。</p><h3 id="处理JSON"><a href="#处理JSON" class="headerlink" title="处理JSON"></a>处理JSON</h3><p>简单映射<br>我们用Lombok设置一个简单的Java类。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line"><span class="variable">@AllArgsConstructor</span></span><br><span class="line"><span class="variable">@NoArgsConstructor</span></span><br><span class="line">public class Friend &#123;</span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">nickname</span>;</span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">int</span> <span class="selector-tag">age</span>;</span><br><span class="line">&#125;<span class="selector-tag">1234567</span></span><br></pre></td></tr></table></figure></p><p>然后就可以处理JSON数据了。首先需要一个ObjectMapper对象，序列化和反序列化都需要它。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">Friend <span class="keyword">friend</span> = <span class="keyword">new</span> Friend(<span class="string">"yitian"</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写为字符串</span></span><br><span class="line"><span class="keyword">String</span> <span class="built_in">text</span> = mapper.writeValueAsString(<span class="keyword">friend</span>);</span><br><span class="line"><span class="comment">// 写为文件</span></span><br><span class="line">mapper.writeValue(<span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"friend.json"</span>), <span class="keyword">friend</span>);</span><br><span class="line"><span class="comment">// 写为字节流</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = mapper.writeValueAsBytes(<span class="keyword">friend</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">text</span>);</span><br><span class="line"><span class="comment">// 从字符串中读取</span></span><br><span class="line">Friend newFriend = mapper.readValue(<span class="built_in">text</span>, Friend.class);</span><br><span class="line"><span class="comment">// 从字节流中读取</span></span><br><span class="line">newFriend = mapper.readValue(bytes, Friend.class);</span><br><span class="line"><span class="comment">// 从文件中读取</span></span><br><span class="line">newFriend = mapper.readValue(<span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"friend.json"</span>), Friend.class);</span><br><span class="line">System.out.<span class="built_in">println</span>(newFriend);<span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure></p><p>程序结果如下。可以看到生成的JSON属性和Java类中定义的一致。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"nickname"</span>:<span class="string">"yitian"</span>,<span class="string">"age"</span>:25&#125;</span><br><span class="line">Friend(<span class="attribute">nickname</span>=yitian, <span class="attribute">age</span>=25)12</span><br></pre></td></tr></table></figure></p><h3 id="集合的映射"><a href="#集合的映射" class="headerlink" title="集合的映射"></a>集合的映射</h3><p>除了使用Java类进行映射之外，我们还可以直接使用Map和List等Java集合组织JSON数据，在需要的时候可以使用readTree方法直接读取JSON中的某个属性值。需要注意的是从JSON转换为Map对象的时候，由于Java的类型擦除，所以类型需要我们手动用new TypeReference<t>给出。</t></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="built_in">map</span>.put(<span class="string">"age"</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">map</span>.put(<span class="string">"name"</span>, <span class="string">"yitian"</span>);</span><br><span class="line"><span class="built_in">map</span>.put(<span class="string">"interests"</span>, <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;<span class="string">"pc games"</span>, <span class="string">"music"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span> <span class="built_in">text</span> = mapper.writeValueAsString(<span class="built_in">map</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; map2 = mapper.readValue(<span class="built_in">text</span>, <span class="keyword">new</span> TypeReference&lt;Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt;&gt;() &#123;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.<span class="built_in">println</span>(map2);</span><br><span class="line"></span><br><span class="line">JsonNode root = mapper.readTree(<span class="built_in">text</span>);</span><br><span class="line"><span class="keyword">String</span> name = root.<span class="built_in">get</span>(<span class="string">"name"</span>).asText();</span><br><span class="line"><span class="built_in">int</span> age = root.<span class="built_in">get</span>(<span class="string">"age"</span>).asInt();</span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"name:"</span> + name + <span class="string">" age:"</span> + age);<span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure><p>程序结果如下。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"yitian"</span>,<span class="string">"interests"</span>:[<span class="string">"pc games"</span>,<span class="string">"music"</span>],<span class="string">"age"</span>:25&#125;</span><br><span class="line">&#123;<span class="attribute">name</span>=yitian, interests=[pc games, music], <span class="attribute">age</span>=25&#125;</span><br><span class="line">name:yitian age:25123</span><br></pre></td></tr></table></figure></p><h3 id="Jackson配置"><a href="#Jackson配置" class="headerlink" title="Jackson配置"></a>Jackson配置</h3><p>Jackson预定义了一些配置，我们通过启用和禁用某些属性可以修改Jackson运行的某些行为。详细文档参考<a href="https://github.com/FasterXML/jackson-databind/wiki/JacksonFeatures" target="_blank" rel="noopener">JacksonFeatures。</a>下面我简单翻译一下Jackson README上列出的一些属性。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 美化输出</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.enable</span>(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line"><span class="comment">// 允许序列化空的POJO类</span></span><br><span class="line"><span class="comment">// （否则会抛出异常）</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.disable</span>(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class="line"><span class="comment">// 把java.util.Date, Calendar输出为数字（时间戳）</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.disable</span>(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在遇到未知属性的时候不抛出异常</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.disable</span>(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line"><span class="comment">// 强制JSON 空字符串("")转换为null对象值:</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.enable</span>(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JSON中允许C/C++ 样式的注释(非标准，默认禁用)</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.configure</span>(JsonParser.Feature.ALLOW_COMMENTS, true);</span><br><span class="line"><span class="comment">// 允许没有引号的字段名（非标准）</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.configure</span>(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);</span><br><span class="line"><span class="comment">// 允许单引号（非标准）</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.configure</span>(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);</span><br><span class="line"><span class="comment">// 强制转义非ASCII字符</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.configure</span>(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);</span><br><span class="line"><span class="comment">// 将内容包裹为一个JSON属性，属性名由@JsonRootName注解指定</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.configure</span>(SerializationFeature.WRAP_ROOT_VALUE, true);<span class="selector-tag">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure></p><p>这里有三个方法，configure方法接受配置名和要设置的值，Jackson 2.5版本新加的enable和disable方法则直接启用和禁用相应属性，我推荐使用后面两个方法。</p><h3 id="用注解管理映射"><a href="#用注解管理映射" class="headerlink" title="用注解管理映射"></a>用注解管理映射</h3><p>前面介绍了一些Jackson注解，下面来应用一下这些注解。首先来看看使用了注解的Java类。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line"><span class="variable">@NoArgsConstructor</span></span><br><span class="line"><span class="variable">@AllArgsConstructor</span></span><br><span class="line"><span class="variable">@JsonRootName</span>(<span class="string">"FriendDetail"</span>)</span><br><span class="line"><span class="variable">@JsonIgnoreProperties</span>(&#123;<span class="string">"uselessProp1"</span>, <span class="string">"uselessProp3"</span>&#125;)</span><br><span class="line">public class FriendDetail &#123;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"NickName"</span>)</span><br><span class="line">    private String name;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Age"</span>)</span><br><span class="line">    private int age;</span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">uselessProp1</span>;</span><br><span class="line">    @<span class="selector-tag">JsonIgnore</span></span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">int</span> <span class="selector-tag">uselessProp2</span>;</span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">uselessProp3</span>;</span><br><span class="line">&#125;<span class="selector-tag">123456789101112131415</span></span><br></pre></td></tr></table></figure></p><p>然后看看代码。需要注意的是，由于设置了排除的属性，所以生成的JSON和Java类并不是完全对应关系，所以禁用<code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>是必要的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//mapper.enable(SerializationFeature.WRAP_ROOT_VALUE);</span></span><br><span class="line">mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line">FriendDetail fd = <span class="keyword">new</span> FriendDetail(<span class="string">"yitian"</span>, <span class="number">25</span>, <span class="string">""</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">text</span> = mapper.writeValueAsString(fd);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">FriendDetail fd2 = mapper.readValue(<span class="built_in">text</span>, FriendDetail.class);</span><br><span class="line">System.out.<span class="built_in">println</span>(fd2);<span class="number">123456789</span></span><br></pre></td></tr></table></figure><p>运行结果如下。可以看到生成JSON的时候忽略了我们制定的值，而且在转换为Java类的时候对应的属性为空。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"NickName"</span>:<span class="string">"yitian"</span>,<span class="string">"Age"</span>:25&#125;</span><br><span class="line">FriendDetail(<span class="attribute">name</span>=yitian, <span class="attribute">age</span>=25, <span class="attribute">uselessProp1</span>=<span class="literal">null</span>, <span class="attribute">uselessProp2</span>=0, <span class="attribute">uselessProp3</span>=<span class="literal">null</span>)12</span><br></pre></td></tr></table></figure><p>然后取消注释代码中的那行，也就是启用<code>WRAP_ROOT_VALUE</code>功能，再运行一下程序，运行结果如下。可以看到生成的JSON结果发生了变化，而且由于JSON结果变化，所以Java类转换失败（所有字段值全为空）。<code>WRAP_ROOT_VALUE</code>这个功能在有些时候比较有用，因为有些JSON文件需要这种结构。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"FriendDetail"</span>:&#123;<span class="string">"NickName"</span>:<span class="string">"yitian"</span>,<span class="string">"Age"</span>:25&#125;&#125;</span><br><span class="line">FriendDetail(<span class="attribute">name</span>=<span class="literal">null</span>, <span class="attribute">age</span>=0, <span class="attribute">uselessProp1</span>=<span class="literal">null</span>, <span class="attribute">uselessProp2</span>=0, <span class="attribute">uselessProp3</span>=<span class="literal">null</span>)12</span><br></pre></td></tr></table></figure></p><h3 id="Java8日期时间类支持"><a href="#Java8日期时间类支持" class="headerlink" title="Java8日期时间类支持"></a>Java8日期时间类支持</h3><p>Java8增加了一套全新的日期时间类，Jackson对此也有支持。这些支持是以Jackson模块形式提供的，所以首先就是注册这些模块。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> <span class="type">ObjectMapper</span>()</span><br><span class="line">        .registerModule(<span class="keyword">new</span> <span class="type">JavaTimeModule</span>())</span><br><span class="line">        .registerModule(<span class="keyword">new</span> <span class="type">ParameterNamesModule</span>())</span><br><span class="line">        .registerModule(<span class="keyword">new</span> <span class="type">Jdk8Module</span>());<span class="number">1234</span></span><br></pre></td></tr></table></figure></p><p>导入类库之后，Jackson也可以自动搜索所有模块，不需要我们手动注册。<br> <code>mapper.findAndRegisterModules();1</code></p><p>我们新建一个带有LocalDate字段的Java类。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line"><span class="variable">@NoArgsConstructor</span></span><br><span class="line"><span class="variable">@AllArgsConstructor</span></span><br><span class="line"><span class="variable">@JsonRootName</span>(<span class="string">"Person"</span>)</span><br><span class="line">public class Person &#123;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Name"</span>)</span><br><span class="line">    private String name;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"NickName"</span>)</span><br><span class="line">    private String nickname;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Age"</span>)</span><br><span class="line">    private int age;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"IdentityCode"</span>)</span><br><span class="line">    private String identityCode;</span><br><span class="line">    <span class="variable">@JsonProperty</span></span><br><span class="line">    <span class="variable">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-DD"</span>)</span><br><span class="line">    private LocalDate birthday;</span><br><span class="line"></span><br><span class="line">&#125;<span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure></p><p>然后来看看代码。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> java8DateTime() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">"yitian"</span>, <span class="string">"易天"</span>, <span class="number">25</span>, <span class="string">"10000"</span>, LocalDate.of(<span class="number">1994</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper()</span><br><span class="line">            .registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">    <span class="comment">//mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span></span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">text</span> = mapper.writeValueAsString(p1);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">    Person p2 = mapper.readValue(<span class="built_in">text</span>, Person.class);</span><br><span class="line">    System.out.<span class="built_in">println</span>(p2);</span><br><span class="line">&#125;<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure></p><p>运行结果如下。可以看到，生成的JSON日期变成了[1994,1,1]这样的时间戳形式，一般情况下不符合我们的要求。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"birthday"</span>:[1994,1,1],<span class="string">"Name"</span>:<span class="string">"yitian"</span>,<span class="string">"NickName"</span>:<span class="string">"易天"</span>,<span class="string">"Age"</span>:25,<span class="string">"IdentityCode"</span>:<span class="string">"10000"</span>&#125;</span><br><span class="line">Person(<span class="attribute">name</span>=yitian, <span class="attribute">nickname</span>=易天, <span class="attribute">age</span>=25, <span class="attribute">identityCode</span>=10000, <span class="attribute">birthday</span>=1994-01-01)12</span><br></pre></td></tr></table></figure></p><p>取消注释那行代码，程序运行结果如下。这样一来就变成了我们一般使用的形式了。如果有格式需要的话，可以使用<code>@JsonFormat(pattern = &quot;yyyy-MM-DD&quot;)</code>注解格式化日期显示。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"birthday"</span>:<span class="string">"1994-01-01"</span>,<span class="string">"Name"</span>:<span class="string">"yitian"</span>,<span class="string">"NickName"</span>:<span class="string">"易天"</span>,<span class="string">"Age"</span>:25,<span class="string">"IdentityCode"</span>:<span class="string">"10000"</span>&#125;</span><br><span class="line">Person(<span class="attribute">name</span>=yitian, <span class="attribute">nickname</span>=易天, <span class="attribute">age</span>=25, <span class="attribute">identityCode</span>=10000, <span class="attribute">birthday</span>=1994-01-01)12</span><br></pre></td></tr></table></figure></p><p>处理XML</p><p>Jackson是一个处理JSON的类库，不过它也通过<code>jackson-dataformat-xml</code>包提供了处理XML的功能。Jackson建议我们在处理XML的时候使用<code>woodstox-core</code>包，它是一个XML的实现，比JDK自带XML实现更加高效，也更加安全。</p><p>这里有个注意事项，如果你正在使用Java 9以上的JDK，可能会出现<code>java.lang.NoClassDefFoundError: javax/xml/bind/JAXBException</code>异常，这是因为Java 9实现了JDK的模块化，将原本和JDK打包在一起的JAXB实现分隔出来。所以这时候需要我们手动添加JAXB的实现。在Gradle中添加下面的代码即可。</p><p><code>compile group: &#39;javax.xml.bind&#39;, name: &#39;jaxb-api&#39;, version: &#39;2.3.0&#39;1</code></p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Jackson XML除了使用Jackson JSON和JDK JAXB的一些注解之外，自己也定义了一些注解。下面简单介绍一下几个常用注解。</p><p><code>@JacksonXmlProperty</code>注解有三个属性，<code>namespace</code>和<code>localname</code>属性用于指定XML命名空间的名称，<code>isAttribute</code>指定该属性作为XML的属性（）还是作为子标签（）.</p><p><code>@JacksonXmlRootElement</code>注解有两个属性，<code>namespace</code>和<code>localname</code>属性用于指定XML根元素命名空间的名称。</p><p><code>@JacksonXmlText</code>注解将属性直接作为未被标签包裹的普通文本表现。</p><p><code>@JacksonXmlCData</code>将属性包裹在CDATA标签中。</p><h3 id="XML映射"><a href="#XML映射" class="headerlink" title="XML映射"></a>XML映射</h3><p>新建如下一个Java类。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line"><span class="variable">@NoArgsConstructor</span></span><br><span class="line"><span class="variable">@AllArgsConstructor</span></span><br><span class="line"><span class="variable">@JsonRootName</span>(<span class="string">"Person"</span>)</span><br><span class="line">public class Person &#123;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Name"</span>)</span><br><span class="line">    private String name;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"NickName"</span>)</span><br><span class="line">    <span class="comment">//@JacksonXmlText</span></span><br><span class="line">    private String nickname;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Age"</span>)</span><br><span class="line">    private int age;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"IdentityCode"</span>)</span><br><span class="line">    <span class="variable">@JacksonXmlCData</span></span><br><span class="line">    private String identityCode;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Birthday"</span>)</span><br><span class="line">    <span class="comment">//@JacksonXmlProperty(isAttribute = true)</span></span><br><span class="line">    <span class="variable">@JsonFormat</span>(pattern = <span class="string">"yyyy/MM/DD"</span>)</span><br><span class="line">    private LocalDate birthday;</span><br><span class="line"></span><br><span class="line">&#125;<span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure></p><p>下面是代码示例，基本上和JSON的API非常相似，XmlMapper实际上就是ObjectMapper的子类。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person(<span class="string">"yitian"</span>, <span class="string">"易天"</span>, <span class="number">25</span>, <span class="string">"10000"</span>, LocalDate.of(<span class="number">1994</span>, <span class="number">1</span>, <span class="number">1</span>))<span class="comment">;</span></span><br><span class="line">XmlMapper mapper = new XmlMapper()<span class="comment">;</span></span><br><span class="line">mapper.findAndRegisterModules()<span class="comment">;</span></span><br><span class="line">mapper.<span class="keyword">disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span></span><br><span class="line"><span class="keyword">mapper.enable(SerializationFeature.INDENT_OUTPUT);</span></span><br><span class="line"><span class="keyword">String </span>text = mapper.writeValueAsString(p1)<span class="comment">;</span></span><br><span class="line">System.out.println(text)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Person p2 = mapper.readValue(text, Person.class)<span class="comment">;</span></span><br><span class="line">System.out.println(p2)<span class="comment">;12345678910</span></span><br></pre></td></tr></table></figure></p><p>运行结果如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>yitian<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NickName</span>&gt;</span>易天<span class="tag">&lt;/<span class="name">NickName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Age</span>&gt;</span>25<span class="tag">&lt;/<span class="name">Age</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">IdentityCode</span>&gt;</span>&lt;![CDATA[10000]]&gt;<span class="tag">&lt;/<span class="name">IdentityCode</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Birthday</span>&gt;</span>1994/01/01<span class="tag">&lt;/<span class="name">Birthday</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Person(name=yitian, nickname=易天, age=25, identityCode=10000, birthday=1994-01-01)123456789</span><br></pre></td></tr></table></figure><p>如果取消那两行注释，那么运行结果如下。可以看到Jackson XML注解对生成的XML的控制效果。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">birthday</span>=<span class="string">"1994/01/01"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>yitian<span class="tag">&lt;/<span class="name">Name</span>&gt;</span>易天</span><br><span class="line">  <span class="tag">&lt;<span class="name">Age</span>&gt;</span>25<span class="tag">&lt;/<span class="name">Age</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">IdentityCode</span>&gt;</span>&lt;![CDATA[10000]]&gt;<span class="tag">&lt;/<span class="name">IdentityCode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Person(name=yitian, nickname=null, age=25, identityCode=10000, birthday=1994-01-01)1234567</span><br></pre></td></tr></table></figure></p><h3 id="Spring-Boot集成"><a href="#Spring-Boot集成" class="headerlink" title="Spring Boot集成"></a>Spring Boot集成</h3><p>自动配置</p><p>Spring Boot对Jackson的支持非常完善，只要我们引入相应类库，Spring Boot就可以自动配置开箱即用的Bean。Spring自动配置的ObjectMapper（或者XmlMapper）作了如下配置，基本上可以适应大部分情况。</p><p>禁用了<code>MapperFeature.DEFAULT_VIEW_INCLUSION</code><br>禁用了<code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code><br>禁用了<code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code></p><p>如果需要修改自动配置的ObjectMapper属性也非常简单，Spring Boot提供了一组环境变量，直接在application.properties文件中修改即可。</p><table><thead><tr><th>Jackson枚举</th><th>Spring环境变量</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>com.fasterxml.jackson.databind.DeserializationFeature|spring.jackson.deserialization.=true|false<br>com.fasterxml.jackson.core.JsonGenerator.Feature|spring.jackson.generator.=true|false<br>com.fasterxml.jackson.databind.MapperFeature|spring.jackson.mapper.=true|false<br>com.fasterxml.jackson.core.JsonParser.Feature|spring.jackson.parser.=true|false<br>com.fasterxml.jackson.databind.SerializationFeature|spring.jackson.serialization.=true|false<br>com.fasterxml.jackson.annotation.JsonInclude.Include|spring.jackson.default-property-inclusion=always|non_null|non_absent|non_default|non_empty</p><p>由于Spring会同时配置相应的<code>HttpMessageConverters</code>，所以我们其实要做的很简单，用Jackson注解标注好要映射的Java类，然后直接让控制器返回对象即可！下面是一个Java类。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonRootName(<span class="meta-string">"person"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="keyword">private</span> int id;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy-MM-DD"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDate birthday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person(String name, int id, LocalDate birthday) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure></p><p>然后是控制器代码。在整个过程中我们只需要引入Jackson类库，然后编写业务代码就好了。关于如何配置Jackson类库，我们完全不需要管，这就是Spring Boot的方便之处。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person = new Person(<span class="string">"yitian"</span>, <span class="number">10000</span>, LocalDate.of(<span class="number">1994</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String index() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = <span class="meta-string">"/json"</span>, produces = <span class="meta-string">"application/json"</span>)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Person json() &#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure><p>进入localhost:8080/xml就可以看到对应结果了。 </p><h4 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h4><p>Spring Boot自动配置非常方便，但不是万能的。在必要的时候，我们需要手动配置Bean来替代自动配置的Bean。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Qualifier(<span class="meta-string">"xml"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> XmlMapper xmlMapper(Jackson2ObjectMapperBuilder builder) &#123;</span><br><span class="line">        XmlMapper mapper = builder.createXmlMapper(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">        mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(<span class="meta-string">"json"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> ObjectMapper jsonMapper(Jackson2ObjectMapperBuilder builder) &#123;</span><br><span class="line">        ObjectMapper mapper = builder.createXmlMapper(<span class="literal">false</span>)</span><br><span class="line">                .build();</span><br><span class="line">        mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure><p>然后在需要的地方进行依赖注入。需要注意为了区分ObjectMapper和XmlMapper，需要使用@Qualifier注解进行标记。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ObjectMapper jsonMapper;</span><br><span class="line">    <span class="keyword">private</span> XmlMapper xmlMapper;</span><br><span class="line">    <span class="keyword">private</span> Person person = new Person(<span class="string">"yitian"</span>, <span class="number">10000</span>, LocalDate.of(<span class="number">1994</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MainController(<span class="meta">@Autowired</span> <span class="meta">@Qualifier(<span class="meta-string">"json"</span>)</span> ObjectMapper jsonMapper, <span class="meta">@Autowired</span> <span class="meta">@Qualifier(<span class="meta-string">"xml"</span>)</span> XmlMapper xmlMapper) &#123;</span><br><span class="line">        <span class="keyword">this</span>.jsonMapper = jsonMapper;</span><br><span class="line">        <span class="keyword">this</span>.xmlMapper = xmlMapper;</span><br><span class="line">    &#125;<span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>以上就是Jackson类库的一些介绍，希望对大家有所帮助。</p><hr><p>本文来自 过了即是客 的CSDN 博客 ，全文地址请点击：<a href="https://blog.csdn.net/u011054333/article/details/80504154?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/u011054333/article/details/80504154?utm_source=copy</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java生态圈中有很多处理JSON和XML格式化的类库，Jackson是其中比较著名的一个。虽然JDK自带了XML处理类库，但是相对来说比较低级，使用本文介绍的Jackson等高级类库处理起来会方便很多。&lt;/p&gt;
&lt;h3 id=&quot;引入类库&quot;&gt;&lt;a href=&quot;#引入类库&quot; 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记03——文件上传</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B003%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记03——文件上传/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:27:07.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>文件上传主要用到了MultipartFile 这个类，它源自 SpringMVC ，可以提高对文件保存的效率</p></blockquote><p>1、创建FileController 开始写文件上传的接口</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.domain.JsonData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">String</span>  filePath=<span class="string">"D:/ideWorkspace/practice/src/main/resources/static/images/"</span>;</span><br><span class="line">    @RequestMapping(<span class="string">"/v1/upload"</span>)</span><br><span class="line">    <span class="keyword">public</span> Object upLoad(@RequestParam(<span class="string">"head_img"</span>) MultipartFile  file)&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//判空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file.getSize()&gt;<span class="number">100000</span>)&#123;</span><br><span class="line">            <span class="comment">//大小限制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前文件名</span></span><br><span class="line">        <span class="keyword">String</span> name = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//后缀名</span></span><br><span class="line">        <span class="keyword">String</span> substring = name.substring(name.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        <span class="comment">//重新生成唯一文件名</span></span><br><span class="line">        <span class="keyword">String</span> fileName = UUID.randomUUID() + substring;</span><br><span class="line">        File <span class="keyword">new</span><span class="type">File</span>=<span class="keyword">new</span> <span class="type">File</span>(filePath+fileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="keyword">new</span><span class="type">File</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">JsonData</span>(<span class="string">"1"</span>,<span class="string">"ok"</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="type">JsonData</span>(<span class="string">"0"</span>,<span class="string">"上传失败"</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类中，还是用我们最简单的注解方式@RestController  +@RequestMapping<br>然后指定访问路径，主要的区别在于，方法参数使用的是MultipartFile   这个类型，然后给参数指定了一个key.<br>（1）先对文件进行一些基本的校验，是否为空，文件大小限制<br>（2）然后获取文件现在名称，通过UUID或者时间戳 重命名这个文件<br>（3） 重点来了，通过 file.transferTo(newFile); 这行代码将文件写入到相应位置，MultipartFile 对象的transferTo方法，用于文件保存（效率和操作比原先用FileOutStream方便和高效）<br>（4）对结果进行一些处理和返回状态</p><p>2、这里用到了一个JsonData的 java类，代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonData</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">4185756603091671454</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String  result;</span><br><span class="line">    <span class="keyword">private</span> String  message;</span><br><span class="line">    <span class="keyword">private</span> Object  <span class="keyword">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JsonData(String result, String message, Object <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getResult() &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setResult(String result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getMessage() &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setMessage(String message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setData(Object <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是一个简单的实例，实际开发中根据规范和实际需求制定。然后以json的方式返回。</p><p>3、测试接口<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180831/AbhIhh43Bl.png?imageslim" alt="mark"><br><img src="http://oima95jt3.bkt.clouddn.com/blog/180831/Ea885D3dAA.png?imageslim" alt="mark"></p><p>当然也可以多文件进行上传，处理都一样都是使用了 MutipartFile  ,通过transferTo进行写入</p><p>4、如何对上传大小进行限制<br>可以再启动类中进行配置。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.MultipartConfigFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.MultipartConfigElement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置文件大小限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">MultipartConfigElement <span class="title">multipartConfigElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MultipartConfigFactory factory = <span class="keyword">new</span> MultipartConfigFactory();</span><br><span class="line">        <span class="comment">//单个文件最大  -----这里的硬编码应该放到配置文件中进行配置，这里只演示下</span></span><br><span class="line">        factory.setMaxFileSize(<span class="string">"10240KB"</span>); <span class="comment">//KB,MB  </span></span><br><span class="line">        <span class="comment">/// 设置总上传数据总大小  </span></span><br><span class="line">        factory.setMaxRequestSize(<span class="string">"1024000KB"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> factory.<span class="title">createMultipartConfig</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类中加入上面代码，，自定义相关大小限制。常规应该把大小的描述放到配置文件中，然后进行引用，这里只是一个示范。<br>但是这只是在本地，上传到项目文件夹。。接下来应该打包程序，指定文件路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; class=&quot;headerlink&quot; title=&quot;文件上传&quot;&gt;&lt;/a&gt;文件上传&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;文件上传主要用到了MultipartFile 这个类，它源自 SpringMVC ，可以提高对文件
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Springboot入门笔记01——环境配置</title>
    <link href="http://yoursite.com/2018/10/06/springboot/Springboot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/10/06/springboot/Springboot入门笔记01——环境配置/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:25:21.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Springboot-简介"><a href="#Springboot-简介" class="headerlink" title="Springboot 简介"></a>Springboot 简介</h3><blockquote><p>简化Spring应用开发的一个框架；<br>整个Spring技术栈的一个大整合；<br>J2EE开发的一站式解决方案；</p></blockquote><p>###1、SpringBoot2.x依赖环境和版本新特性说明</p><blockquote><p>1、依赖版本jdk8以上, Springboot2.x用JDK8, 因为底层是 Spring framework5,<br>​    2、安装maven最新版本，maven3.2以上版本，下载地址 ：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a><br>​    3、springbootGitHub地址：<a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot</a><br>​    4、springboot官方文档：<a href="https://spring.io/guides/gs/spring-boot/" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-boot/</a><br>我自己使用的是 jdk8、maven 3.5.3、 开发工具为 Intellij Idea </p></blockquote><p>###2、基础环境搭建和maven、idea的使用（从头搭建一个简单的web项目）</p><p>####1、安装jdk 1.8，配置环境变量</p><p>####2、安装maven 3.5.3 ,配置环境变量</p><p>####3、idea的相关配置，比如jdk，maven等（ 这些就不讲了）</p><p>####4、创建一个简单的maven 管理的web 项目</p><p>#####（1）创建一个maven 项目，File——New——Project<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/1BfBhK5eag.png?imageslim" alt="mark"></p><p>#####(2)定义项目的坐标，然后一直next 到finish<br>groupId：项目名称，定义为组织名+项目名，一般用公司的域名反写，这个按照一定规范些就行<br>artifactid :这个一般是项目名或者模块的名称<br>version:当前项目或者moudle 的版本号<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/cliJ5JAgcb.png?imageslim" alt="mark"><br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/CeeDCFLim6.png?imageslim" alt="mark"></p><p>#####（3）maven 项目结构说明<br>使用maven创建的工程我们称他们为maven 工程，maven 工程具有一定的目录规范，如下：<br>src/main/java—— 存放项目的.java 文件<br>src/main/resources —— 存放项目资源文件，如spring，mybatis配置文件<br>src/test/java —— 存放所有单元测试的.java 文件，如 JUnit测试类<br>src/test/resources —— 测试用的资源文件<br>target —— 项目输出位置，编译后的.class 文件会输出到此目录<br>pom.xml —— maven 项目的核心配置文件  *<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/jLb9IAJ5KC.png?imageslim" alt="mark"></p><p>#####（4）为刚才创建的项目添加web 支持，因为刚才我们创建的是一个普通的maven 项目，如果想要被外部访问，需要添加web支持。<br>快捷键 ctrl+alt+shift+s   或者file ——project structure打开 项目的设置面板<br>左边选择moudle, 然后点击+号，添加web 支持<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/HhA47gj54h.png?imageslim" alt="mark"><br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/F8H19h78kE.png?imageslim" alt="mark"></p><p>根据自己项目实际情况，其实就是指定到src \main\webapp下<br>需要修改资源文件路径为  D:\ideWorkspace\practice\src\main\webapp<br>修改描述文件路径为 D:\ideWorkspace\practice\src\main\webapp\WEB-INF\web.xml<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/I7dece74k2.png?imageslim" alt="mark"></p><p>可以看到现在下面有个警告，我们还没有添加Artifacts，可以直接点击右边的创建按钮，也可以再左侧点击Artifacts进行添加<br>如下：<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/e2a58j0216.png?imageslim" alt="mark"><br>选择自己刚才创建的，点击ok 就添加完成了。<br><strong>这样一个web项目就创建完成了，在这里我们不再演示创建一个servlet 和一个静态页面，去访问资源了。由于我们是springboot 学习，接下来就要直接上springboot了，以上是对maven 项目的一个简单介绍以及 idea 的使用。 （传统web项目以及tomcat、servlet 等可以自行百度）</strong></p><p>###3、springboot 项目的环境搭建以及包的依赖<br>可以参考官方的例子，这里只简单说下步骤<br><a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener">https://spring.io/guides/gs/rest-service/</a><br>修改pom.xml文件 添加相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.gongsi.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>practice<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--依赖父工程，使用springboot必须加--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加相关依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用Spring MVC构建Web（包括RESTful）应用程序的入门者。使用Tomcat作为默认嵌入式容器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用JUnit，Hamcrest和Mockito等库来测试Spring Boot应用程序的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jayway.jsonpath<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-path<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入依赖后，工程就已经是一个springboot的项目了，可以写相关代码，用内置的tomcat运行</p><p><strong>关于maven 库的依赖</strong><br><a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a><br>可以从这个仓库进行搜索，然后把相关的xml依赖 添加到 pom.xml下的  dependencies 标签下</p><p><strong>更快的创建springboot项目的方法</strong><br><a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a><br>相当于是个在线的插件，输入相关参数，下载配置好的springboot 工程<br><strong>更更方便的创建springboot项目的方法</strong><br>使用idea 已经内置的创建插件<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/im9L66je2B.png?imageslim" alt="mark"><br>点击创建，然后选择 spring initializr 然后一步步填写相关信息，进行创建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Springboot-简介&quot;&gt;&lt;a href=&quot;#Springboot-简介&quot; class=&quot;headerlink&quot; title=&quot;Springboot 简介&quot;&gt;&lt;/a&gt;Springboot 简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;简化Spring应用开发的
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记08——Mybatis逆向工程之IDE自动生成实体类</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B008%E2%80%94%E2%80%94Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%B9%8BIDE%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%AE%9E%E4%BD%93%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记08——Mybatis逆向工程之IDE自动生成实体类/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:26:32.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这里只是介绍一种最简单的逆向生成java实体类的方法"><a href="#这里只是介绍一种最简单的逆向生成java实体类的方法" class="headerlink" title="这里只是介绍一种最简单的逆向生成java实体类的方法"></a>这里只是介绍一种最简单的逆向生成java实体类的方法</h3><p>mybatis提供了一种逆向工程，网上有很多，大多通过配置文件的方式和依赖的方式，稍微有一点繁琐。我们的Intellij idea  已经集成了自动生成pojo类的工具，直接使用更加方便。</p><h3 id="idea连接数据库"><a href="#idea连接数据库" class="headerlink" title="idea连接数据库"></a>idea连接数据库</h3><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180910/GidBI2FB89.png?imageslim" alt="mark"><br><img src="http://oima95jt3.bkt.clouddn.com/blog/180910/3E1c6480jg.png?imageslim" alt="mark"></p><h3 id="修改生成脚本"><a href="#修改生成脚本" class="headerlink" title="修改生成脚本"></a>修改生成脚本</h3><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180910/lfdD1D59hc.png?imageslim" alt="mark"></p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180910/KFDfciab9E.png?imageslim" alt="mark"><br><strong>当然很重要的一点要记得修改我们的包名，图片忘记标记了</strong></p><h3 id="快速生成实体类"><a href="#快速生成实体类" class="headerlink" title="快速生成实体类"></a>快速生成实体类</h3><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180910/LflB6GAi6i.png?imageslim" alt="mark"><br>然后选择相应的文件路径，打开自动生成的javabean ，可以稍作修改，直接拷贝到相应包中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;这里只是介绍一种最简单的逆向生成java实体类的方法&quot;&gt;&lt;a href=&quot;#这里只是介绍一种最简单的逆向生成java实体类的方法&quot; class=&quot;headerlink&quot; title=&quot;这里只是介绍一种最简单的逆向生成java实体类的方法&quot;&gt;&lt;/a&gt;这里只是介绍一种
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Springboot入门笔记05——springboot 注解整合mybatis</title>
    <link href="http://yoursite.com/2018/10/06/springboot/Springboot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B005%E2%80%94%E2%80%94springboot%20%E6%B3%A8%E8%A7%A3%E6%95%B4%E5%90%88mybatis/"/>
    <id>http://yoursite.com/2018/10/06/springboot/Springboot入门笔记05——springboot 注解整合mybatis/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:27:26.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、springboot-持久化数据方式介绍"><a href="#1、springboot-持久化数据方式介绍" class="headerlink" title="1、springboot 持久化数据方式介绍"></a>1、springboot 持久化数据方式介绍</h3><blockquote><p>1、原始java访问数据库<br>​        开发流程麻烦<br>​        （1）注册驱动/加载驱动<br>​            Class.forName(“com.mysql.jdbc.Driver”)<br>​        （2）建立连接<br>​            Connection con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/dbname”,”root”,”root”);<br>​        （3）创建Statement<br>​        （4）执行SQL语句<br>​        （5）处理结果集<br>​          (6)关闭连接，释放资源<br>​    2、apache dbutils框架<br>​        比上一步简单点<br>​        官网:<a href="https://commons.apache.org/proper/commons-dbutils/" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-dbutils/</a><br>​    3、jpa框架<br>​        spring-data-jpa<br>​        jpa在复杂查询的时候性能不是很好<br>​    4、Hiberante   解释：ORM：对象关系映射Object Relational Mapping<br>​        企业大都喜欢使用hibernate<br>​    5、Mybatis框架<br>​        互联网行业通常使用mybatis<br>​        不提供对象和关系模型的直接映射,半ORM</p></blockquote><p>###springboot 集成mybatis 的步骤<br>1、pom.xml添加依赖<br>2、配置文件配置 jdbc  数据库连接地址、以及数据源等等<br>3、分包进行分层，编码结构清晰<br>4、创建表和相应的pojo类<br>5、实现mapper或者叫dao 层的功能编码，sql注入<br>6、实现service层的编码，调用dao层实现操作数据库<br>7、实现controller 层的代码，编写外部调用接口，内部调用service层方法处理mapper层的数据<br>8、添加@MapperScan注解，运行程序，调试bug,可能会修改配置比如mysql serverTimezone的影响，测试</p><p>####1、首先来添加mybatis的相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!-- MySQL的JDBC驱动包--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 引入第三方数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>####2、修改配置文件application.properties<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#可以自动识别,所以下面这行可写可不写</span><br><span class="line"><span class="selector-id">#spring</span><span class="selector-class">.datasource</span><span class="selector-class">.driver-class-name</span> =com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span></span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.driver-class-name</span> =com<span class="selector-class">.mysql</span><span class="selector-class">.cj</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span></span><br><span class="line">#数据库的连接地址，用户名，密码</span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.url</span>=jdbc:mysql:<span class="comment">//localhost:3306/movie?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.username</span> =root</span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.password</span> =<span class="number">112233</span></span><br><span class="line">#数据源</span><br><span class="line">#如果不使用默认的数据源 （com<span class="selector-class">.zaxxer</span><span class="selector-class">.hikari</span><span class="selector-class">.HikariDataSource</span>）</span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.type</span> =com<span class="selector-class">.alibaba</span><span class="selector-class">.druid</span><span class="selector-class">.pool</span><span class="selector-class">.DruidDataSource</span></span><br></pre></td></tr></table></figure></p><p>这里简单讲解下配置文件：<br>1、首先，声明jdbc的驱动这个可以写也可以不写，springboot 会自动识别当前的jdbc,这里仅供参考<br>2、配置好数据库的连接地址：修改为自己的本地或者远程数据库，这里注意，如果你的表里有time字段，最好设置下serverTimezone ，不设置的话 可能会有错误。。然后是数据库用户名和密码<br>3、数据源：这个可以改也可以不改，默认的是com.zaxxer.hikari.HikariDataSource；但是如果想改的话也可以改为<br>淘宝的这个。</p><p>###3、分包<br>一般写代码都要进行分层，这里最起码我们简单分一下包</p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180831/Ca5EdLj1BH.png?imageslim" alt="mark"><br>一个简单的项目，打开分为这么几个包，<br>controller：主要方我们的api接口<br>domain:放一些实体类，同javaBean 、pojo 都可以，是我们的module层。<br>mapper:是存放所有访问数据库的接口，同dao.<br>service :业务逻辑层，我们的业务代码都放在这，service 又可以分为 接口 和实现类 两个包进行分类<br>utils:是我们的工具类<br>大家可以根据自己的习惯进行分一下包，然后就开始创建相关类了。</p><p>###4、创建表和相应的pojo类<br>创建表，就打开数据库创建就行了。不管用什么方法，图形界面，命令行都可以。我们这里创建了一个movie数据库，一个user表。 有 id 、name 、create_time、age、phone   这几个字段<br>可以这样建  mysql -u root -p   密码 连接数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> movie;</span><br><span class="line"><span class="keyword">use</span> movie;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">32</span>) primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) ,</span><br><span class="line">age  <span class="built_in">int</span>(<span class="number">32</span>),</span><br><span class="line">phone <span class="built_in">varchar</span>(<span class="number">32</span>),</span><br><span class="line">create_time  datetime</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后创建相应的javaBean User,字段类型一定要和表相对应</p><p>###5、实现mapper或者叫dao 层的功能编码，sql注入<br>在mapper包下创建 UserMapper 类，主要来操作User这个表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mybatis.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问数据库的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注意： 这里的#&#123;&#125;内容必须和User 类的属性一一对应；推荐使用#&#123;&#125;取值，不要用$&#123;&#125;,因为存在注入的风险</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"INSERT INTO USER(name,phone,create_time,age) VALUES(#&#123;name&#125;,#&#123;phone&#125;,#&#123;createTime&#125;,#&#123;age&#125;)"</span>)</span><br><span class="line">    <span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>, keyProperty = <span class="string">"id"</span>, keyColumn = <span class="string">"id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Insert（）注解可以将sql 映射user类，然后将数据写入user表   sql语句 values() 值以 #{属性名} 进行一一匹配<br>@Options 配置，主键id是自增长的，我们如果要想把id映射到user类中，需要表明使用主键true，属性名和列名<br>//useGeneratedKeys=true 表示使用主键，true就可以返回。  keyProperty java对象的属性；keyColumn表示数据库的字段<br>mapper方法写完后，就可以写service 层方法进行调用</p><p>###6、实现service层的编码，调用dao层实现操作数据库<br>一般先创建一个UserService 的接口，声明操作数据库的方法，比如需要有增删改查的方法，就在接口中声明。<br>然后创建一个impl 包，用来存放具体实现service的实现类 。比如现在创建一个 UserServiceImpl.java 类。<br>这两个类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.service;</span><br><span class="line"><span class="keyword">import</span> com.mybatis.domain.User;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//其他方法。</span></span><br><span class="line">    <span class="comment">//删</span></span><br><span class="line">    <span class="comment">//改</span></span><br><span class="line">    <span class="comment">//查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.service.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mybatis.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.mybatis.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.mybatis.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">        <span class="keyword">int</span> id = user.getId();</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>UserServiceImpl 首先实现了 UserService 接口，重写了操作方法<br>有两个注解 @Service 和 @Autowired   通过注解声明，springmvc就能扫描到这个类，@Autowired封装了自动装配UserMapper  。调用 mapper层的insert() 方法进行注入，还可以拿到id </p><p>###7、实现controller 层的代码，编写外部调用接口，内部调用service层方法处理mapper层的数据</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mybatis.domain.JsonData;</span><br><span class="line"><span class="keyword">import</span> com.mybatis.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.mybatis.service.impl.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/api/v1/user"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: user 保存接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">"add"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object add() &#123;</span><br><span class="line"></span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setAge(<span class="number">22</span>);</span><br><span class="line">        user.setCreateTime(new Date());</span><br><span class="line">        user.setName(<span class="string">"我最帅"</span>);</span><br><span class="line">        user.setPhone(<span class="string">"17615881722"</span>);</span><br><span class="line">        int id = userService.add(user);</span><br><span class="line">        <span class="keyword">return</span> JsonData.buildSuccess(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面一样，@RestController<br>@RequestMapping指定路径<br>方法get post根据情况自己定，这里就简单的将一个user对象写入user 表， 至于结果返回 自己定吧。</p><p>###8、添加@MapperScan注解，运行主程序，进行测试，调用接口，查看数据库表。<br><strong>必须在主程序中添加注解@MapperScan(“com.mybatis.mapper”)</strong><br>告诉程序要扫描mapper包，不然写的dao层的代码无法找到</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.mybatis.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionApplication</span>  &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)&#123;</span><br><span class="line">        SpringApplication.run(ActionApplication.<span class="keyword">class</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、springboot-持久化数据方式介绍&quot;&gt;&lt;a href=&quot;#1、springboot-持久化数据方式介绍&quot; class=&quot;headerlink&quot; title=&quot;1、springboot 持久化数据方式介绍&quot;&gt;&lt;/a&gt;1、springboot 持久化数据方式
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记07——Mybatis增删改查以及事务示例，打印sql</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B007%E2%80%94%E2%80%94Mybatis%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%A4%BA%E4%BE%8B%EF%BC%8C%E6%89%93%E5%8D%B0sql/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记07——Mybatis增删改查以及事务示例，打印sql/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:26:39.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p>1、实现打印sql语句以及切换数据源<br>2、springboot 整合mybatis增删改查实例<br>3、整合事务示例（简单事务介绍）</p><p>###1、实现打印sql语句以及切换数据源<br>（1）添加打印sql 配置<br>每次通过接口往数据库写入信息，如果我们想查看mybatis实际编译的sql语句，可以使用如下方法：<br>在配置文件application.properties 文件中添加如下代码<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#增加打印sql语句，一般用于本地开发测试</span><br><span class="line">mybatis<span class="selector-class">.configuration</span><span class="selector-class">.log-impl</span>=org<span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.logging</span><span class="selector-class">.stdout</span><span class="selector-class">.StdOutImpl</span></span><br></pre></td></tr></table></figure></p><p><img src="http://oima95jt3.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180906102545.png?imageslim" alt="mark"><br>（2）切换数据源<br>可以再配置文件中设置数据源，默认使用的是HikariDataSource ，我们也可以改为 阿里巴巴的 DruidDataSource数据源<br>配置文件如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#数据源</span><br><span class="line">#如果不使用默认的数据源 （com<span class="selector-class">.zaxxer</span><span class="selector-class">.hikari</span><span class="selector-class">.HikariDataSource</span>）</span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.type</span>=com<span class="selector-class">.alibaba</span><span class="selector-class">.druid</span><span class="selector-class">.pool</span><span class="selector-class">.DruidDataSource</span></span><br></pre></td></tr></table></figure></p><p>如果使用阿里巴巴的数据源 需要在pom文件中添加依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入第三方数据源 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>###2、springboot 整合mybatis增删改查实例</p><p>直接上代码：</p><p>####UserMapper类<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">package</span> <span class="selector-tag">code</span><span class="selector-class">.mapper</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">code</span><span class="selector-class">.domain</span><span class="selector-class">.User</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.annotations</span>.*;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.List</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Insert</span>(<span class="string">"insert into user(name,create_time,age,phone) values(#&#123;name&#125;,#&#123;createTime&#125;,#&#123;age&#125;,#&#123;phone&#125;)"</span>)</span><br><span class="line">    <span class="variable">@Options</span>(useGeneratedKeys = true,keyProperty = <span class="string">"id"</span>,keyColumn = <span class="string">"id"</span>)</span><br><span class="line">    int insert(User user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：查找全部</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@Select</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="variable">@Results</span>(&#123;</span><br><span class="line">            <span class="variable">@Result</span>(column = <span class="string">"create_time"</span>,property = <span class="string">"createTime"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    List&lt;User&gt; getAll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable">@Select</span>(<span class="string">"SELECT * FROM user WHERE id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="variable">@Results</span>(&#123;</span><br><span class="line">            <span class="variable">@Result</span>(column = <span class="string">"create_time"</span>,property = <span class="string">"createTime"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    User findById(long id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：更新对象</span></span><br><span class="line"><span class="comment">     * @param user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@Update</span>(<span class="string">"UPDATE user SET name=#&#123;name&#125; WHERE id =#&#123;id&#125;"</span>)</span><br><span class="line">    void update(User user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：根据id删除用户</span></span><br><span class="line"><span class="comment">     * @param userId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@Delete</span>(<span class="string">"DELETE FROM user WHERE id =#&#123;userId&#125;"</span>)</span><br><span class="line">    void delete(long userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里用到了几个注解@Insert、 @Select 、@Update  、@Delete 看名字就能看出来是增删改查的操作，然后后面跟上sql语句，没什么难的。<br>还有一个注解要注意下@Results   ,当数据表的字段和 User 类的属性名称不完全一致的时候，需要说明下映射<br>比如这里，数据库user表是 create_time ,而user类使用的是驼峰命名，createTime,这个时候如果不添加映射，数据就写不进去。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Results</span>(&#123;</span><br><span class="line">            <span class="variable">@Result</span>(column = <span class="string">"create_time"</span>,property = <span class="string">"createTime"</span>)</span><br><span class="line">            <span class="comment">//这里可以添加多个字段的映射</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>当然还可以设置id，因为如果多个地方都用到，每次写一遍就太麻烦了，所以，就写一次，声明id，然后直接引用id。这个看下面其他的例子把，下面贴一下网上总结的用法：</p><p>#####@Results用法总结<br>MyBatis中使用@Results注解来映射查询结果集到实体类属性。</p><p>（1）@Results的基本用法。当数据库字段名与实体类对应的属性名不一致时，可以使用@Results映射来将其对应起来。column为数据库字段名，porperty为实体类属性名，jdbcType为数据库字段数据类型，id为是否为主键。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="variable">@Results</span>(&#123;</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=true),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"name"</span>, property=<span class="string">"name"</span>, jdbcType=JdbcType.VARCHAR),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"class_id "</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;Student&gt; selectAll();</span><br></pre></td></tr></table></figure><p>如上所示的数据库字段名class_id与实体类属性名classId，就通过这种方式建立了映射关系。</p><p>（2）@ResultMap的用法。当这段@Results代码需要在多个方法用到时，为了提高代码复用性，我们可以为这个@Results注解设置id，然后使用@ResultMap注解来复用这段代码。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="variable">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=true),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"name"</span>, property=<span class="string">"name"</span>, jdbcType=JdbcType.VARCHAR),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"class_id "</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;Student&gt; selectAll();</span><br><span class="line"> </span><br><span class="line"><span class="variable">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student where id = #&#123;id&#125;"</span>&#125;)</span><br><span class="line"><span class="variable">@ResultMap</span>(value=<span class="string">"studentMap"</span>)</span><br><span class="line">Student selectById(integer id);</span><br></pre></td></tr></table></figure><p>（3）@One的用法。当我们需要通过查询到的一个字段值作为参数，去执行另外一个方法来查询关联的内容，而且两者是一对一关系时，可以使用@One注解来便捷的实现。比如当我们需要查询学生信息以及其所属班级信息时，需要以查询到的class_id为参数，来执行ClassesMapper中的selectById方法，从而获得学生所属的班级信息。可以使用如下代码。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="variable">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=true),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"name"</span>, property=<span class="string">"name"</span>, jdbcType=JdbcType.VARCHAR),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"class_id "</span>, property=<span class="string">"myClass"</span>, javaType=MyClass.class,</span><br><span class="line">        one=<span class="variable">@One</span>(select=<span class="string">"com.my.mybatis.mapper.MyClassMapper.selectById"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;Student&gt; selectAllAndClassMsg();</span><br></pre></td></tr></table></figure><p>（4）@Many的用法。与@One类似，只不过如果使用@One查询到的结果是多行，会抛出TooManyResultException异常，这种时候应该使用的是@Many注解，实现一对多的查询。比如在需要查询学生信息和每次考试的成绩信息时。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="variable">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=true),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"name"</span>, property=<span class="string">"name"</span>, jdbcType=JdbcType.VARCHAR),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"class_id "</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"gradeList"</span>, javaType=List.class,</span><br><span class="line">        many=<span class="variable">@Many</span>(select=<span class="string">"com.my.mybatis.mapper.GradeMapper.selectByStudentId"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;Student&gt; selectAllAndGrade();</span><br></pre></td></tr></table></figure><h3 id="还有一种更简单的方式来映射实体类"><a href="#还有一种更简单的方式来映射实体类" class="headerlink" title="还有一种更简单的方式来映射实体类"></a>还有一种更简单的方式来映射实体类</h3><p>直接在清单文件中添加配置，就可以忽略驼峰命名参数<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#数据库字段下划线和Java实体类映射</span><br><span class="line">  # mybatis 下划线转驼峰配置,两者都可以</span><br><span class="line">#mybatis.<span class="keyword">configuration</span>.mapUnderscoreToCamelCase=<span class="literal">true</span></span><br><span class="line">mybatis.<span class="keyword">configuration</span>.<span class="keyword">map</span>-underscore-<span class="keyword">to</span>-camel-<span class="keyword">case</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>####UserController类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package code.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> code.domain.JsonData;</span><br><span class="line"><span class="keyword">import</span> code.domain.User;</span><br><span class="line"><span class="keyword">import</span> code.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> code.services.interfaces.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.<span class="keyword">factory</span>.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="built_in">List</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line">    public <span class="built_in">Object</span> insertUser(<span class="meta">@RequestParam</span>(required = <span class="keyword">true</span>) <span class="built_in">String</span> name, <span class="meta">@RequestParam</span>(required = <span class="keyword">true</span>) <span class="built_in">int</span> age, <span class="meta">@RequestParam</span>(required = <span class="keyword">true</span>) <span class="built_in">String</span> phone) &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setAge(age);</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="built_in">int</span> id = userService.insert(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData().buildSuccess(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get_all"</span>)</span><br><span class="line">    public <span class="built_in">Object</span>  getAll()&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;User&gt; all = userMapper.getAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData().buildSuccess(all,<span class="string">"200"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/find_by_id"</span>)</span><br><span class="line">    public <span class="built_in">Object</span> findById(<span class="meta">@RequestParam</span>(name = <span class="string">"user_id"</span>,required = <span class="keyword">true</span>) long id)&#123;</span><br><span class="line"></span><br><span class="line">        User byId = userMapper.findById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData().buildSuccess(byId,<span class="string">"200"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line">    public <span class="built_in">Object</span> deleteById(<span class="built_in">int</span> id)&#123;</span><br><span class="line">        userMapper.delete(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> JsonData().buildSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    public <span class="built_in">Object</span> updateById(<span class="built_in">String</span> name,<span class="built_in">int</span> id)&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        userMapper.update(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData().buildSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###3、整合事务示例（简单事务介绍）</p><p>####事务简介<br>    1、事务基本上分为单机事务 、分布式事务。我们常见的是单机事务，比如买东西付款，开启事务，一方扣款，一方收款，全部完成操作，此次事务才算解说。。如果是分布式事务就相当复杂了，多个数据库和服务器，所以需要用消息队列进行处理了。</p><pre><code>2、讲解场景的隔离级别    Serializable： 最严格，串行处理，消耗资源大    Repeatable Read：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据    Read Committed：大多数主流数据库的默认事务等级    Read Uncommitted：保证了读取过程中不会读取到非法数据。3、讲解常见的传播行为    PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务,最常见的选择。    PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。    PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。    PROPAGATION_REQUIRES_NEW--新建事务，如果当前存在事务，把当前事务挂起, 两个事务之间没有关系，一个异常，一个提交，不会同时回滚    PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。    PROPAGATION_NEVER--以非事务方式执行，如果当前存在事务，则抛出异常</code></pre><p>####简单的开启事务实战。<br>我们使用最常见的传播行为，<code>propagation=Propagation.REQUIRED</code><br>由于上面我们直接controller层调用mapper层，没有经过service层写代码，因为操作简单，所以没必要再写一遍。<br>现在我们试一下通过service层 添加事务<br>UserServiceImpl类中添加如下代码，，并且再UserService中已经添加了接口<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation=Propagation.REQUIRED)</span><br><span class="line">public int addAccount() &#123;</span><br><span class="line">    User <span class="keyword">user</span> = new User();</span><br><span class="line">    <span class="keyword">user</span>.<span class="built_in">set</span>Age(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">user</span>.<span class="built_in">set</span>CreateTime(new Date());</span><br><span class="line">    <span class="keyword">user</span>.<span class="built_in">set</span>Name(<span class="string">"事务测试"</span>);</span><br><span class="line">    <span class="keyword">user</span>.<span class="built_in">set</span>Phone(<span class="string">"110110110"</span>);</span><br><span class="line">    <span class="keyword">user</span>Mapper.insert(<span class="keyword">user</span>);</span><br><span class="line">    int i = <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码是开启了事务，然后王数据库添加信息，然后执行异常，这样测试下数据库到底有没有写入信息。<br>UserController:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">//测试事务</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"transac"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">transac</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id = userService.addAccount();</span><br><span class="line">    <span class="function"><span class="keyword">return</span> JsonData.<span class="title">buildSuccess</span><span class="params">(id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，查看log和 数据表</p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180906/6EF6i3GICg.png?imageslim" alt="mark"><br><img src="http://oima95jt3.bkt.clouddn.com/blog/180906/bHKK3L16lF.png?imageslim" alt="mark"></p><p>如果不加事务，虽然也会报错，但是确实已经执行了sql，写入了数据库</p><p>以上只是一个简单的增删该查的实例，可以直观的了解springboot整合mybatis，通过sql语句对数据库进行操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h3&gt;&lt;p&gt;1、实现打印sql语句以及切换数据源&lt;br&gt;2、springboot 整合mybatis增删改查实例&lt;br&gt;3、整合事务示例（简单事务介绍）
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记06——配置文件的介绍</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B006%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记06——配置文件的介绍/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:26:47.763Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、springboot-配置文件分类"><a href="#一、springboot-配置文件分类" class="headerlink" title="一、springboot 配置文件分类"></a>一、springboot 配置文件分类</h3><p>•application.properties<br>•application.yml<br>YAML Ain’t Markup Language  yaml不是一种标记语言<br>springboot 有两种配置文件，可以是properties,也可以是yml，各有各的好处。本人打算使用properties方式，纯属个人爱好<br>对比下：</p><pre><code>1)YAML（Yet Another Markup Language）            写 YAML 要比写 XML 快得多(无需关注标签或引号)            使用空格 Space 缩进表示分层，不同层次之间的缩进可以使用不同的空格数目            注意：key后面的冒号，后面一定要跟一个空格,树状结构        application.properties示例            server.port=8090              server.session-timeout=30              server.tomcat.max-threads=0              server.tomcat.uri-encoding=UTF-8         application.yml示例            server:                    port: 8090                    session-timeout: 30                    tomcat.max-threads: 0                    tomcat.uri-encoding: UTF-8 </code></pre><p>####二、最简单的方式，官网直接复制，需要用啥就复制啥，然后改改</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.spring.io<span class="regexp">/spring-boot/</span>docs<span class="regexp">/2.1.0.BUILD-SNAPSHOT/</span>reference<span class="regexp">/htmlsingle/</span><span class="comment">#common-application-properties</span></span><br></pre></td></tr></table></figure><p>####1、 properties这样写<br><code>server.port=8080</code></p><p>####2、YAML这样写<br><strong>在yml中缩进一定不能使用TAB，否则会报很奇怪的错误；（缩进特么只能用空格！！！！） </strong><br><strong>每个k的冒号后面一定都要加一个空格；</strong><br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">server:</span></span><br><span class="line"><span class="symbol">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="symbol">path:</span> /hello</span><br></pre></td></tr></table></figure></p><p> k:(空格)v：表示一对键值对（空格必须有）；<br>以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的—–属性和值也是大小写敏感</p><p>#####值的写法<br><strong>（1）字面量：普通的值（数字，字符串，布尔）</strong><br>k: v：字面直接来写；<br>字符串默认不用加上单引号或者双引号；<br>“”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思<br>name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi<br>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据<br>name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi<br><strong>（2）对象、Map（属性和值）（键值对）：</strong></p><p>k: v：在下一行来写对象的属性和值的关系；注意缩进<br>对象还是k: v的方式<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">friends:</span></span><br><span class="line"><span class="symbol">lastName:</span> zhangsan</span><br><span class="line"><span class="symbol">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>行内写法<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">friends</span>: &#123;<span class="attribute">lastName</span>: zhangsan,age: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure></p><p><strong>（3）数组（List、Set）</strong><br>用- 值表示数组中的一个元素<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pet<span class="variable">s:</span></span><br><span class="line">‐ <span class="keyword">cat</span></span><br><span class="line">‐ dog</span><br><span class="line">‐ pig</span><br></pre></td></tr></table></figure></p><p>行内写法<br><code>pets: [cat,dog,pig]</code></p><p>####3、配置文件值注入<br>配置文件如下：例如<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">person</span>:</span><br><span class="line"><span class="attribute">lastName</span>: hello</span><br><span class="line"><span class="attribute">age</span>: <span class="number">18</span></span><br><span class="line"><span class="attribute">boss</span>: false</span><br><span class="line"><span class="attribute">birth</span>: <span class="number">2017</span>/<span class="number">12</span>/<span class="number">12</span></span><br><span class="line"><span class="attribute">maps</span>: &#123;<span class="attribute">k1</span>: v1,<span class="attribute">k2</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="attribute">lists</span>:</span><br><span class="line">‐ zhoumao</span><br><span class="line">‐ zhangyue</span><br><span class="line"><span class="attribute">dog</span>:</span><br><span class="line"><span class="attribute">name</span>: 德华</span><br><span class="line"><span class="attribute">age</span>: <span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>javaBean：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 将配置文件中配置的每一个属性的值，映射到这个组件中</span><br><span class="line">* <span class="title">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span><br><span class="line">* <span class="keyword">prefix</span> = <span class="string">"person"</span>：配置文件中哪个下面的所有属性进行一一映射</span><br><span class="line">* *</span><br><span class="line">只有这个组件是容器中的组件，才能容器提供的<span class="title">@ConfigurationProperties</span>功能；</span><br><span class="line">* *</span><br><span class="line">/</span><br><span class="line"><span class="title">@Component</span></span><br><span class="line"><span class="title">@ConfigurationProperties</span>(<span class="keyword">prefix</span> = <span class="string">"person"</span>)</span><br><span class="line">public class Person &#123;</span><br><span class="line"><span class="keyword">private</span> String lastName<span class="comment">;</span></span><br><span class="line"><span class="comment">private Integer age;</span></span><br><span class="line"><span class="comment">private Boolean boss;</span></span><br><span class="line"><span class="comment">private Date birth;</span></span><br><span class="line"><span class="comment">private Map&lt;String,Object&gt; maps;</span></span><br><span class="line"><span class="comment">private List&lt;Object&gt; lists;</span></span><br><span class="line"><span class="comment">private Dog dog;</span></span><br></pre></td></tr></table></figure><p>以上配置文件的注入以对象的方式，只需要在javaBean 上添加两个注解，@Component标记类  然后@ConfigurationProperties(prefix = “person”)指定前缀   然后只要javaBean的属性和配置文件一致就可以直接映射。</p><p>使用时，需要在使用的类上指定配置文件@PropertySource({“classpath:application.yml”})</p><p>小结：可以使用yaml也可以使用properties方式，基本语法也差不太多，习惯用哪个用哪个，官网有例子，使用的时候直接复制。<br>所有的配置其实都会被注入成map,都是键值对的方式，取的时候都是根据key 获取value.<br>所以获取配置文件的方式暂时会一种就可以。</p><h3 id="三、配置文件自动映射属性和实体类"><a href="#三、配置文件自动映射属性和实体类" class="headerlink" title="三、配置文件自动映射属性和实体类"></a>三、配置文件自动映射属性和实体类</h3><p>配置文件加载有两种方式，一种直接在Controller类中添加注解，以value的形式直接使用配置文件。另一种，是注入实体类的方式。</p><p><strong>第一种：Controller类加载配置信息</strong><br>就拿我们文件的例子来看 application.proterties文件如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">web.upload-path=<span class="string">D:</span><span class="regexp">/ideWorkspace/</span>StudyProject<span class="regexp">/HelloWorld/</span>src<span class="regexp">/main/</span>resources<span class="regexp">/static/</span>images</span><br><span class="line">spring.resources.<span class="keyword">static</span>-locations=<span class="string">classpath:</span><span class="regexp">/META-INF/</span>resources<span class="regexp">/,classpath:/</span>resources<span class="regexp">/,classpath:/</span><span class="keyword">static</span><span class="regexp">/,classpath:/</span><span class="keyword">public</span>/,<span class="string">file:</span>$&#123;web.upload-path&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个文件路径，当然也可以是其他的。只要是key-value形式定义就可以。<br>然后，需要在使用配置文件的类中添加注解。<br>（1）类上添加<code>@PropertySource({&quot;classpath:application.properties&quot;})</code><br>（2）变量名使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;web.upload-path&#125;</span>"</span>)</span></span><br><span class="line"><span class="keyword">private</span> String filePath;</span><br></pre></td></tr></table></figure><p>这样就可以了。其实就是通过@PropertySource注解将配置文件路径添加进来，这样spring 就会扫描到这个配置文件，并且映射成map到这个类中，接下来通过@Value注解，以key-value的形式，通过定义的key拿到配置文件中的值。这样就避免了硬编码。（以上是在有@Controller 注解的类中使用）</p><p><strong>第二种  注入配置实体类</strong><br>接下来用个实例讲解下。<br>首先在配置文件中配置了两个属性，比如服务器的地址和名称</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="attribute">domain</span>=www.answerme.xyz</span><br><span class="line">test.<span class="attribute">name</span>=springboot</span><br></pre></td></tr></table></figure><p>如果要把他们映射到实体类，需要建一个javaBean 比如：ServerSetting.java<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器配置</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;<span class="meta-string">"classpath:application.properties"</span>&#125;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSettings</span> </span>&#123;</span><br><span class="line"><span class="comment">//名称</span></span><br><span class="line"><span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;test.name&#125;</span>"</span>)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;test.domain&#125;</span>"</span>)</span></span><br><span class="line"><span class="keyword">private</span> String domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String getName() &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> void setName(String name) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String getDomain() &#123;</span><br><span class="line"><span class="keyword">return</span> domain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> void setDomain(String domain) &#123;</span><br><span class="line"><span class="keyword">this</span>.domain = domain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后写一个controller方法测试下：<br>自动注入<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ServerSetting serverSetting;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/v1/server"</span>)</span></span><br><span class="line"><span class="keyword">public</span> Object  serverTest()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> serverSetting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<code>{&quot;name&quot;: &quot;springboot&quot;,&quot;domain&quot;: &quot;www.answerme.xyz&quot;}</code><br>说明，这种方式可以获取到配置文件的信息。<br>当然每次都要将属性和配置文件的key一一对应有点麻烦，所以有更方便的写法。<br>我们可以再@ConfigurationProperties() 注解中添加一个前缀，代码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件名: ServerSetting.java</span></span><br><span class="line"><span class="comment"> * 描述：</span></span><br><span class="line"><span class="comment"> * Create by Google on 2018/9/10 23:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器配置</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(&#123;<span class="string">"classpath:application.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ServerSetting &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> domain;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> setName(<span class="built_in">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> getDomain() &#123;</span><br><span class="line">        <span class="keyword">return</span> domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> setDomain(<span class="built_in">String</span> domain) &#123;</span><br><span class="line">        <span class="keyword">this</span>.domain = domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>常见问题：            1、配置文件注入失败，Could not resolve placeholder                解决：根据springboot启动流程，会有自动扫描包没有扫描到相关注解,                 默认Spring框架实现会从声明@ComponentScan所在的类的package进行扫描，来自动注入，                因此启动类最好放在根路径下面，或者指定扫描包范围                spring-boot扫描启动类对应的目录和子目录            2、注入bean的方式，属性名称和配置文件里面的key一一对应，就不用加@Value 这个注解                如果不一样，就要加@value(&quot;${XXX}&quot;)</code></pre><p>小结：</p><pre><code>1、添加 @Component或者Configuration 注解，后者标记为配置文件；    2、使用 @PropertySource 注解指定配置文件位置；(属性名称规范: 大模块.子模块.属性名)3、必须 通过注入IOC对象Resource 进来 ， 才能在类中使用获取的配置文件值。    @Autowired    private WeChatConfig weChatConfig;    例子：        @Configuration@PropertySource(value=&quot;classpath:application.properties&quot;)        public class WeChatConfig {            @Value(&quot;${wxpay.appid}&quot;)            private String appId;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、springboot-配置文件分类&quot;&gt;&lt;a href=&quot;#一、springboot-配置文件分类&quot; class=&quot;headerlink&quot; title=&quot;一、springboot 配置文件分类&quot;&gt;&lt;/a&gt;一、springboot 配置文件分类&lt;/h3&gt;&lt;p&gt;•a
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记04——文件路径配置以及SpringBoot打包方式讲解</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B004%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8ASpringBoot%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记04——文件路径配置以及SpringBoot打包方式讲解/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:26:58.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、文件路径的配置"><a href="#1、文件路径的配置" class="headerlink" title="1、文件路径的配置"></a>1、文件路径的配置</h3><p>由于我们上一节直接将上传的文件写到了静态资源文件夹下面，如果我们打成jar包运行到服务器上，是无法拿到这个路径的。所以我们需要主动去指定这个文件路径，然后去访问资源。（正常我们需要在配置文件中进行配置，然后引用资源文件读取配置文件）</p><p>（1）首先在resources资源文件夹下创建配置文件  命名为 application.properties   应用程序会默认读取配置文件的信息，<br>可以配置端口，数据库地址以及各种。。。<br>（2）声明文件路径<br>例如：<code>web.images-path=D:/test/images</code><br>映射名称web.images-path  这个名字随便起，自己来定，， 后面指定的是你要将图片存储的路径<br>（3）将声明的文件路径添加为外部可以访问的资源文件声明 ，添加配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.<span class="keyword">static</span>-locations=<span class="string">classpath:</span><span class="regexp">/META-INF/</span>resources<span class="regexp">/,classpath:/</span>resources<span class="regexp">/,classpath:/</span><span class="keyword">static</span><span class="regexp">/,classpath:/</span><span class="keyword">public</span>/</span><br><span class="line">,<span class="string">file:</span>$&#123;web.images-path&#125;</span><br></pre></td></tr></table></figure><p>以上代码添加到配置文件中。这里简单介绍下springboot 项目的资源文件目录</p><blockquote><p>src/main/java：存放代码<br>src/main/resources 存放资源文件<br>​         static: 存放静态文件，比如 css、js、image, （访问方式 <a href="http://localhost:8080/js/main.js）" target="_blank" rel="noopener">http://localhost:8080/js/main.js）</a><br>​         config:存放配置文件,application.properties<br>​         resources:<br>​         public<br>​         templates:存放静态页面jsp,html,tpl     <strong>此文件加需要添加接口映射才能跳转访问</strong>spring-boot-starter-thymeleaf</p></blockquote><p>springboot 资源文件的默认查找顺序为：<strong>META/resources &gt; resources &gt; static &gt; public  里面找是否存在相应的资源，如果有则直接返回。</strong><br>静态资源配置官网：<br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content</a></p><p>默认配置</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.<span class="keyword">static</span>-locations = <span class="keyword">classpath</span>:<span class="regexp">/META-INF/</span>resources<span class="regexp">/,classpath:/</span>resources<span class="regexp">/,classpath:/</span><span class="keyword">static</span><span class="regexp">/,classpath:/</span><span class="keyword">public</span><span class="regexp">/</span></span><br></pre></td></tr></table></figure><p>如果需要我们自定义一个文件夹，就需要在上面的配置中添加我们的文件夹说明，比如，在后面添加一个<code>,classpath:/test/</code>  这样就把test文件夹添加到配置中了。在resources文件夹下创建test 文件夹，就可以访问这个文件夹了。</p><p>小结：我们给图片配置路径就是把我们自定义的路径<code>web.images-path=D:/test/images</code> 添加到 <code>spring.resources.static-locations</code> 的配置说明中，file:${自己定义的名字} 指定路径。<br>然后修改FileController 的路径要和配置文件一致；并且指定的文件夹要存在’<br>接下来，我们不用硬编码，用配置文件注入的方式动态拿到指定的地址<br><strong>我们已经在配置文件中指定了文件路径，当然可以重新写一个，只要符合格式</strong><br>1、添加<code>@PropertySource({&quot;classpath:application.properties&quot;})</code>spring会自动扫描配置文件<br>2、修改路径，将硬编码改为动态获取配置文件值<br><code>@Value(&quot;${web.upload-path}&quot;)​    private String filePath;</code><br>​    注意这里的{}内的名称要和配置文件中指定的key值 完全一致<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.controller;</span><br><span class="line"><span class="keyword">import</span> com.test.domain.JsonData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;<span class="meta-string">"classpath:application.properties"</span>&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">   <span class="comment">//public static final String  filePath="D:/test/images/";</span></span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;web.upload-path&#125;</span>"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String filePath;</span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/v1/upload"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object upLoad(<span class="meta">@RequestParam(<span class="meta-string">"head_img"</span>)</span> MultipartFile  file)&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//判空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file.getSize()&gt;<span class="number">100000</span>)&#123;</span><br><span class="line">            <span class="comment">//大小限制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前文件名</span></span><br><span class="line">        String name = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//后缀名</span></span><br><span class="line">        String substring = name.substring(name.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        <span class="comment">//重新生成唯一文件名</span></span><br><span class="line">        String fileName = UUID.randomUUID() + substring;</span><br><span class="line">        File newFile=new File(filePath+fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(newFile);</span><br><span class="line">            <span class="keyword">return</span> new JsonData(<span class="string">"1"</span>,<span class="string">"ok"</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  new JsonData(<span class="string">"0"</span>,<span class="string">"上传失败"</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = <span class="meta-string">"uploads"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> JsonData uploads(HttpServletRequest request, <span class="meta">@RequestParam(<span class="meta-string">"head_img"</span>)</span> MultipartFile... file) &#123;</span><br><span class="line"></span><br><span class="line">        int num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile f : file) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取文件名</span></span><br><span class="line">            String fileName = f.getOriginalFilename();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"上传的文件名为："</span> + fileName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取文件的后缀名,比如图片的jpeg,png</span></span><br><span class="line">            String suffixName = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"上传的后缀名为："</span> + suffixName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 文件上传后的路径</span></span><br><span class="line">            fileName = UUID.randomUUID() + suffixName;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"转换后的名称:"</span> + fileName);</span><br><span class="line"></span><br><span class="line">            File dest = new File(filePath + fileName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                f.transferTo(dest);</span><br><span class="line">                num++;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == file.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> new JsonData(<span class="string">"1"</span>,<span class="string">"ok"</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> new JsonData(<span class="string">"0"</span>,<span class="string">"上传失败"</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###测试文件上传下载<br>运行springboot，然后调用接口，如：<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180905/BK4HFgH59c.png?imageslim" alt="mark"></p><p>然后再浏览器直接获取图片，因为我们已经在配置文件中指明了路径，也配置了。结果如下，直接使用地址+文件名就可以访问<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180905/0bGJ72Df7h.png?imageslim" alt="mark"></p><p>###3、springboot 打成jar运行<br>光配置完文件路径还不可以，需要进行springboot 的打包。<br>当然可以用maven 命令直接打包，但是如果不添加一个maven 插件的话，会报错no main manifest attribute, in XXX.jar。<br>因为maven没有在清单文件中写入，进行启动文件的指定<br>（1）在pom.xml文件中添加maven插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--使用maven打包需要添加这个插件，不然运行没有配置文件 MAINFEST.MF--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）使用maven 进行打包<br>   可以使用命令  mvn spring-boot:run 直接启动， 或者mvn  package 打包，<br>   默认是打成jar包，由于springboot 内置了tomcat容器，直接运行jar 包就可以开发服务。<br>   可以指定最后打包的包名：<br>   在build 标签下 添加 finalname<br>   比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>practice<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--使用maven打包需要添加这个插件，不然运行没有配置文件 MAINFEST.MF--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180831/aclDgLkiiK.png?imageslim" alt="mark"><br>在idea工具中，可以点击maven 生命周期下的 相关命令，双击直接执行。</p><p>（3）直接运行jar   执行命令 <code>java  -jar  parctice.jar</code>   即：java -jar  包名.jar<br>如果是访问我们上传的图片，就  localhost:8080/图片名  就能访问当，如果是服务器就把localhost换位服务器ip<br>但是如果是打成war 包 访问以及上传都需要加上包名。</p><p>以上是打成jar 包。 如果我们需要用一个外置的Tomcat容器来部署服务的话，那我们就可以直接打成war包，，直接扔到服务器上就tomcat  下的webapps 目录下，只要启动tomcat服务器，就会自动部署</p><p>###3、springboot 打成war部署服务器<br>（1）需要添加spring-boot-starter-tomcat依赖<br> 因为是要使用外部的tomcat，所以就需要修改pom.xml 的依赖如下<br> 修改tomcat 的作用域。 当然也有其他方法<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--因配置外部TOMCAT 而配置--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当然也有其他方法  比如移除内置tomcat 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 移除嵌入式tomcat插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我使用第一种，直接修改tomcat的作用域 为 provided ,表示仅仅在编译时使用，最终不会打到包里面</p><p>（2）修改pom.xml文件指明 打包方式为 war<br><code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>不加默认打包方式为jar包，，修改为war,比如我的项目，添加一行代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.gongsi.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>practice<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>（3）最关键的，修改启动类创建的Application。继承SpringBootServletInitializer并且重写configure方法<br> 代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.<span class="type">SpringApplication</span>;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.<span class="type">SpringBootApplication</span>;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.<span class="type">SpringApplicationBuilder</span>;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.<span class="type">MultipartConfigFactory</span>;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.support.<span class="type">SpringBootServletInitializer</span>;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.<span class="type">Bean</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.<span class="type">MultipartConfigElement</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">SpringApplicationBuilder</span> configure(<span class="type">SpringApplicationBuilder</span> builder) &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(<span class="type">Application</span>.<span class="keyword">class</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">SpringApplication</span>.run(<span class="type">Application</span>.<span class="keyword">class</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置文件大小限制</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    public <span class="type">MultipartConfigElement</span> multipartConfigElement() &#123;</span><br><span class="line">        <span class="type">MultipartConfigFactory</span> factory = <span class="keyword">new</span> <span class="type">MultipartConfigFactory</span>();</span><br><span class="line">        <span class="comment">//单个文件最大  -----这里的硬编码应该放到配置文件中进行配置，这里只演示下</span></span><br><span class="line">        factory.setMaxFileSize(<span class="string">"10240KB"</span>); <span class="comment">//KB,MB</span></span><br><span class="line">        <span class="comment">/// 设置总上传数据总大小</span></span><br><span class="line">        factory.setMaxRequestSize(<span class="string">"1024000KB"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.createMultipartConfig();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总共需要做两步操作，先继承 SpringBootServletInitializer ，然后重写 configure(SpringApplicationBuilder builder) 方法，<br>return  builder.sources(Application.class);  注意： 这个Appication 为你自己定义的类。</p><p>（4） mvn  package  进行打包，，并将打成的war 包丢到 tomcat 容器的 webapps路径下，启动tomcat  等待部署完成。</p><p>请求接口的时候，比如，我这里的war包 名为practice ,调用接口就需要 <a href="http://ip地址:8080/practice/接口名" target="_blank" rel="noopener">http://ip地址:8080/practice/接口名</a></p><p><strong>如果并发量多或者多个应用，可以用fastdfs，阿里云oss，或者用nginx搭建一个简单的文件服务器，将我们的资源和应用程序分离开来</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、文件路径的配置&quot;&gt;&lt;a href=&quot;#1、文件路径的配置&quot; class=&quot;headerlink&quot; title=&quot;1、文件路径的配置&quot;&gt;&lt;/a&gt;1、文件路径的配置&lt;/h3&gt;&lt;p&gt;由于我们上一节直接将上传的文件写到了静态资源文件夹下面，如果我们打成jar包运行到服
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记02——简单http接口开发实战</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B002%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95http%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记02——简单http接口开发实战/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:27:15.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h3><p>###一、创建一个简单的接口，返回json<br>1、创建相应的包和类<br>​     一般我们会分包进行创建，我这里简单创建了一个controller 的包，里面写相关的接口controller<br>​     然后再test包下我创建了一个Application 类，这个名词可以自己起。这个类是运行springboot的入口，需要进行配置下。<br>​     <img src="http://oima95jt3.bkt.clouddn.com/blog/180830/Kab0Ld50cf.png?imageslim" alt="mark"><br>​     Application 代码如下：<br>​<br>2、Application  类代码讲解<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)&#123;</span><br><span class="line">        SpringApplication.run(Application.<span class="keyword">class</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@SpringBootApplication 注解：</p><blockquote><p>@SpringBootApplication注解一般放在项目的一个启动类上，用来把启动类注入到容器中，用来定义容器扫描的范围，用来加载classpath环境中一些bean<br>@SpringBootApplication = @Configuration+@EnableAutoConfiguration+@ComponentScan<br>springboot 把这几个注解整合了。只需要写一个就可以</p></blockquote><p>然后在main方法中添加SpringApplication.run(Application.class,args); 来启动应用程序</p><p>3、TestController类讲解</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试用的集合</span></span><br><span class="line">    Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一个接口测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/test"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object getTest(String name)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"name"</span>,name);</span><br><span class="line">        <span class="keyword">return</span>  params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了两个注解，@RestController、 @RequestMapping<br><strong>@RestController and @RequestMapping是springMVC的注解，不是springboot特有的    </strong><br><strong>（1）@RestController</strong><br>@RestController 是spring4 新加入的注解，相当于@Controller +@ResponseBody  两个注解的功能和<br>@Controller的作用表示该类是一个控制器，可以接受用户的输入并调用模型和视图去完成用户的需求。控制器本身不输出也不处理任何东西。 我们写的接口也就是控制器里面的方法。<br>@ResponseBody 表示 请求以json映射的方式返回。<br>所以@RestController 注解的类就可以 接受请求——返回json<br><strong>2、@RequestMapping</strong><br> 这个注解可以加载类和方法上，我理解是表示资源的映射吧，为web请求指明路径。可以定义不同的映射规则<br> 注解在方法上表示当前方法时一个web请求的处理方法，注解在类上，应该是常用的请求地址或路由啥的</p><p>上面方法中再@RequestMapping(“/test”)  方法中的”/test” 就是外部访问的接口地址，暂时我们没有指定请求方法<br>这样外部就能通过 <a href="http://localhost:8080/test?name=张三" target="_blank" rel="noopener">http://localhost:8080/test?name=张三</a>  来进行调用这个接口。<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/a2miG3Dbid.png?imageslim" alt="mark"></p><p>###二、 get、post请求实战<br><strong>(1) get请求实战</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从路径中取值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cityID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = <span class="meta-string">"/&#123;city_id&#125;/&#123;user_id&#125;"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object getUserID(<span class="meta">@PathVariable(<span class="meta-string">"city_id"</span>)</span> String cityID,</span><br><span class="line">                            <span class="meta">@PathVariable(<span class="meta-string">"user_id"</span>)</span> String userID) &#123;</span><br><span class="line"></span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"cityID"</span>, cityID);</span><br><span class="line">        params.put(<span class="string">"userID"</span>, userID);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试<span class="doctag">@GetMapping</span>注解，以get方式请求接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = <span class="meta-string">"/v1/getUser"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object getMappingTest(String id, String name) &#123;</span><br><span class="line"></span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"name"</span>, name);</span><br><span class="line">        params.put(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试，设置参数默认值，别名、以及是否必传参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/v1/getUser1"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object getMyappingTest1(<span class="meta">@RequestParam(defaultValue = <span class="meta-string">"888"</span>,name = <span class="meta-string">"uid"</span>)</span> String id, <span class="meta">@RequestParam(required = true)</span> String username)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"username"</span>, username);</span><br><span class="line">        params.put(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：bean对象传参</span></span><br><span class="line"><span class="comment">     * 注意：1、注意需要指定http头为 content-type为application/json</span></span><br><span class="line"><span class="comment">     * 2、使用body传输数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/v1/save_user"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object saveUser(<span class="meta">@RequestBody</span> User user)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：测试获取http头信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accessToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/v1/get_header"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object getHeader(<span class="meta">@RequestHeader(<span class="meta-string">"access_token"</span>)</span> String accessToken, String id)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"access_token"</span>, accessToken);</span><br><span class="line">        params.put(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以HttpServletRequest获取所有请求数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/v1/test_request"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object testRequest(HttpServletRequest request)&#123;</span><br><span class="line">        </span><br><span class="line">        params.clear();</span><br><span class="line">        String id = request.getParameter(<span class="string">"id"</span>);</span><br><span class="line">        params.put(<span class="string">"id"</span>,id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(<span class="meta-string">"/v1/login"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object login(<span class="meta">@RequestParam(required = true)</span> String  userName, <span class="meta">@RequestParam(required = true)</span>String passWrod)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"name"</span>,userName);</span><br><span class="line">        params.put(<span class="string">"pwd"</span>,passWrod);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(<span class="meta-string">"/v1/class"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object loginTest(User user)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"name"</span>,user.getName);</span><br><span class="line">        params.put(<span class="string">"pwd"</span>,user.getPassword);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(<span class="meta-string">"/v1/put"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object put(String id)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(<span class="meta-string">"/v1/del"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object del(String id)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">注解简介：<span class="number">1</span>、单一参数<span class="meta">@RequestMapping(path = <span class="meta-string">"/&#123;id&#125;"</span>, method = RequestMethod.GET)</span></span><br><span class="line"><span class="number">1</span>) <span class="keyword">public</span> String getUser(<span class="meta">@PathVariable</span> String id ) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）<span class="meta">@RequestMapping(path = <span class="meta-string">"/&#123;depid&#125;/&#123;userid&#125;"</span>, method = RequestMethod.GET)</span> 可以同时指定多个提交方法</span><br><span class="line">getUser(<span class="meta">@PathVariable(<span class="meta-string">"depid"</span>)</span> String departmentID,<span class="meta">@PathVariable(<span class="meta-string">"userid"</span>)</span> String userid)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）<span class="keyword">get</span>、post、put、delete四种注解的封装</span><br><span class="line"><span class="meta">@GetMapping</span> = <span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@PostMapping</span> = <span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@PutMapping</span> = <span class="meta">@RequestMapping(method = RequestMethod.PUT)</span></span><br><span class="line"><span class="meta">@DeleteMapping</span> = <span class="meta">@RequestMapping(method = RequestMethod.DELETE)</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）<span class="meta">@RequestParam(value = <span class="meta-string">"name"</span>, required = true)</span></span><br><span class="line">可以设置默认值，可以设置别名name=<span class="string">""</span>，可以设置是否必传 requeid=<span class="literal">true</span>或<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>)<span class="meta">@RequestBody</span> 请求体映射实体类,以json映射javaBean</span><br><span class="line">需要指定http头为 content-type为application/json charset=utf<span class="number">-8</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）<span class="meta">@RequestHeader</span> 请求头，比如鉴权,可以获取请求头</span><br><span class="line"><span class="meta">@RequestHeader(<span class="meta-string">"access_token"</span>)</span> String accessToken</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）HttpServletRequest request自动注入获取参数，可以拿到任何请求数据</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开始写代码&quot;&gt;&lt;a href=&quot;#开始写代码&quot; class=&quot;headerlink&quot; title=&quot;开始写代码&quot;&gt;&lt;/a&gt;开始写代码&lt;/h3&gt;&lt;p&gt;###一、创建一个简单的接口，返回json&lt;br&gt;1、创建相应的包和类&lt;br&gt;​     一般我们会分包进行创建，我
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>集成React-Native到现有项目采坑记录</title>
    <link href="http://yoursite.com/2018/07/30/android/Android%20Studio3.1.3%E5%8D%87%E7%BA%A7%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%BB%A5%E5%8F%8A%E8%AE%B0%E5%BD%95%E5%87%A0%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/07/30/android/Android Studio3.1.3升级踩坑记录以及记录几个好用的插件/</id>
    <published>2018-07-30T07:47:55.000Z</published>
    <updated>2018-10-05T16:36:45.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到AS每天提醒更新，所以没忍住还是从3.0更新到了3.1.3,于是乎项目就跑不起来了。另外由于之前把android studio 的配置文件改了，更新完又变成了默认的配置路径，所以还要把配置文件改一下。以下是踩坑记录</p></blockquote><p>###1、Gradle 编译问题的修改</p><p>（1）gradle 编译版本对应的build gradle插件版本详情 官网<br><a href="https://developer.android.google.cn/studio/releases/gradle-plugin#updating-plugin" target="_blank" rel="noopener">https://developer.android.google.cn/studio/releases/gradle-plugin#updating-plugin</a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:3.1.3'</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">"https://jitpack.io"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>buildscript定义了全局的相关属性<br>repositories定义仓库：一个仓库代表着依赖包的来源，例如jcenter仓库dependencies用来定义构建过程：仅仅需要定义默认的Android插件，该插件可以让你执行相关Android的tasks，注意：不应该在该方法体内定义子模块的依赖包。<br>allprojects用来定义各个模块的默认属性：不仅仅局限于默认的配置，也可以自己创造tasks在allprojects方法体内，这些tasks将会在所有模块中可见。<br>我升级完android studio 使用的是 Gradle 4.4  以及插件  <strong>classpath ‘com.android.tools.build:gradle:3.1.3’</strong></p></blockquote><p>(2) compile   2018年底要废弃，使用implementtabion 和api 替换<br>官网<br><a href="http://d.android.com/r/tools/update-dependency-configurations.html" target="_blank" rel="noopener">http://d.android.com/r/tools/update-dependency-configurations.html</a><br><a href="https://developer.android.com/studio/build/dependencies" target="_blank" rel="noopener">https://developer.android.com/studio/build/dependencies</a></p><p>依赖库中所有的compile全部替换为 api，主程序的compile 替换为implementation</p><p>###2、 compile和 implementation 和api 有什么区别<br>（1）implementation:<br>Gradle将依赖项添加到编译类路径，并将依赖项打包到构建输出。但是，当您的模块配置implementation依赖项时，它让Gradle知道您不希望模块在编译时将依赖项泄漏给其他模块。也就是说，依赖性仅在运行时可用于其他模块。<br>使用这种依赖性配置，而不是 api或compile（不建议使用）可导致 显著编译时间的改进，因为它减少了构建系统需要重新编译的模块的数量。例如，如果implementation依赖项更改其API，则Gradle仅重新编译该依赖项以及直接依赖于它的模块。大多数应用和测试模块都应使用此配置。<br>（2）api<br>Gradle将依赖项添加到编译类路径并构建输出。当一个模块包含一个api依赖项时，它让Gradle知道该模块想要将该依赖项传递给其他模块，以便它们在运行时和编译时都可用。<br>此配置的行为就像compile （现在已弃用），但您应谨慎使用它，并且只能将您需要的依赖项可传递地导出到其他上游使用者。这是因为，如果api依赖项更改其外部API，Gradle将重新编译在编译时有权访问该依赖项的所有模块。因此，拥有大量api依赖项可以显着增加构建时间。除非您希望将依赖项的API公开给单独的模块，否则库模块应该使用implementation 依赖项。<br><strong>小结：</strong><br>api 等同于 compile ，并且是可以引用传递，比如A  Library 依赖了B  Library，而B Library 依赖了 C Library，使用 api或compile(已废弃)的话，A Library 就可以调用 C Library 的代码。实现了一层层的依赖，这种方式耦合度高一点，并且编译的话都需要编译一遍。</p><p>implementation  就是只管当前 moudle， 比如A  Library 依赖了B  Library，而B Library 依赖了 C Library，使用implementation的话，A Library 就不可以调用 C Library 的代码。implementation 依赖的库，其他moudle是访问不到的。<br><strong>建议：在Google IO 中提到了一个建议，依赖首先应该设置为implementation的，如果没有错，那就用implementation，如果有错，那么使用api指令。<code>使用implementation会使编译速度有所增快。</code></strong></p><p>3、解决 升级完 使用java 8  LifecycleObserver 时出现错误，<br>依赖  implementation “android.arch.lifecycle:common-java8:$lifecycle_version” 时的错误</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Default<span class="built_in"> interface </span>methods are only supported starting with Android N (--min-api 24):</span><br><span class="line"> void ndroid.arch.lifecycle.DefaultLifecycleObserver.onCreate(android.arch.lifecycle.LifecycleOwner)</span><br><span class="line">Message&#123;<span class="attribute">kind</span>=ERROR, <span class="attribute">text</span>=Default<span class="built_in"> interface </span>methods are only supported starting with Android N </span><br><span class="line">(--min-api 24): void android.arch.lifecycle.DefaultLifecycleObserver.onCreate</span><br><span class="line">(android.arch.lifecycle.LifecycleOwner), sources=[Unknown source file],<span class="built_in"> tool </span><span class="attribute">name</span>=Optional.of(D8)&#125;</span><br></pre></td></tr></table></figure><p>如果依赖这个库，那么只能使用最小24 版本，这就太坑了。解决办法如下<br>在 build.gradle  的 android{} 闭包下 添加如下代码，重新编译就好了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">       sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">       targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>###3、顺便更新几个好用的插件<br><strong>（1）Android Parcelable code generator</strong><br>​         JavaBean序列化，快速实现Parcelable接口。<br><strong>（2）CodeGlance</strong><br>在右边快速浏览代码缩略，快速定位代码，特别好用<br><strong>（3）findBugs-IDEA</strong><br>一款查找bug的插件<br><strong>（4）JsonOnlineViewer</strong><br>在android studio 内部打开api接口测试的窗口，进行接口调试<br><strong>（5）ECTranslation</strong><br>一款翻译插件<br><strong>（6）AndroidWiFiADB</strong><br>通过WiFi 无线调试手机的 插件<br> <strong>（7）Alibaba Java Coding Guidelines</strong><br>阿里巴巴的 java开发约束扫描插件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;看到AS每天提醒更新，所以没忍住还是从3.0更新到了3.1.3,于是乎项目就跑不起来了。另外由于之前把android studio 的配置文件改了，更新完又变成了默认的配置路径，所以还要把配置文件改一下。以下是踩坑记录&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>集成React-Native到现有项目采坑记录</title>
    <link href="http://yoursite.com/2018/07/30/android/%E9%9B%86%E6%88%90React-Native%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/07/30/android/集成React-Native到现有项目采坑记录/</id>
    <published>2018-07-30T07:47:53.000Z</published>
    <updated>2018-10-05T16:37:31.488Z</updated>
    
    <content type="html"><![CDATA[<p>###集成步骤<br>官方文档：<a href="https://facebook.github.io/react-native/docs/0.54/integration-with-existing-apps" target="_blank" rel="noopener">https://facebook.github.io/react-native/docs/0.54/integration-with-existing-apps</a><br>借鉴博客：<a href="https://blog.csdn.net/u012455070/article/details/78926526" target="_blank" rel="noopener">https://blog.csdn.net/u012455070/article/details/78926526</a></p><blockquote><p>（1）配置react-native的开发环境<br>（2）创建一个react-native 的项目<br>（3）把项目中的android目录里面的东西换成现有的项目<br>（4）配置android项目的build.gradle文件以及各种依赖<br>（5）运行项目，运行服务，设置ip端口调试。<br>（6）各种踩坑问题，比如不支持64位手机的so库问题，找不到服务，由于react native 版本问题导致的各种错误等等</p></blockquote><p>官方文档的集成步骤；<br>1、安装 node.js  python2   jdk 8<br>这个安装过程就不说了。网上一大堆<br>2、下载更新React Native CLI<br>命令：<code>npm install -g react-native-cli</code><br>执行这行命令就可以使用react-native 命令了。比如 使用命令运行<br>3、android 环境配置和模拟器或者手机连接<br>由于我是做android的，所以这些就跳过了，不清楚的看官方文档或者上网查<br>4、<strong>创建新的应用程序</strong><br>重点来了，创建应用的时候执行命令：<code>react-native init AwesomeProject</code>  这里的AwesomeProject是项目名称可以随便换，但是必须以字母开头。 由于下载是在国外所以特别慢，所以我们要添加以下国内镜像。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> registry https:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line">npm config <span class="keyword">set</span> disturl https:<span class="comment">//npm.taobao.org/dist</span></span><br></pre></td></tr></table></figure><p>这两个都可以，会显著提高下载速度。设置了镜像，然后再执行创建的命令。<br><strong>5、运行新应用的采坑记录</strong><br>指定react  和react-native 的版本。<br>项目目录下的 node_modules 文件夹是 reactnative 所依赖的js的一些东西。<br>如果没有，我们可以再项目跟目录执行 <code>npm install</code> 命令下载<br>这个时候我们要注意一下版本号，因为这里遇到坑了。目前最新的react–native可能是0.56 会出现一个bug<br>比如最新版本</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">react-native-cli</span>: 2<span class="selector-class">.0</span><span class="selector-class">.1</span></span><br><span class="line"><span class="selector-tag">react-native</span>: 0<span class="selector-class">.56</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure><p>但是运行的时候出现 <strong>Unable to resolve module ‘AccessibilityInfo’</strong> 这个错误，所以建议还是版本低一点，这里使用稳定版<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180730/fDJcG823jc.png?imageslim" alt="mark"></p><p><strong>切换步骤：</strong><br>（1）先将旧版卸载</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> uninstall -g react-<span class="keyword">native</span>-cli</span><br><span class="line"><span class="built_in">npm</span> uninstall -g react-<span class="keyword">native</span></span><br></pre></td></tr></table></figure><p>（2）再安装指定版本</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g react-<span class="keyword">native</span>@<span class="number">0.55</span>.<span class="number">4</span></span><br><span class="line"><span class="built_in">npm</span> install -g react-<span class="keyword">native</span>-cli@<span class="number">1.2</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以再项目初始化的时候指定下，不指定的话，只要版本对也没问题，自己查看下</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-<span class="keyword">native</span> init --version=<span class="string">"0.55.4"</span> myFirstApp</span><br></pre></td></tr></table></figure><p>6、解决红屏错误：<strong>Module build failed: Error: Plugin 0 specified in “base” … provided an invalid property of “default”</strong><br>如果出现上面错误执行下面命令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">install</span> <span class="selector-tag">--save-dev</span> <span class="selector-tag">babel-preset-react-native</span>@<span class="keyword">2</span>.<span class="keyword">1</span>.<span class="keyword">0</span></span><br></pre></td></tr></table></figure><p>7、解决 React_Native 无法运行再64位机器上<br>“/data/data/com.xxx.xxx/lib-main/libgnustl_shared.so” is 32-bit instead of 64-bit  这个错误<br>参考文章：<a href="https://blog.csdn.net/u013531824/article/details/53931307" target="_blank" rel="noopener">https://blog.csdn.net/u013531824/article/details/53931307</a><br>Android不能同时加载32和64位本机库。 如果您至少有一个依赖库使用ARM64支持编译的扩展，而另外一些依赖库仅支持ARM32，就会出现问题。 系统将检测ARM64依赖关系，加载它，然后拒绝加载仅ARM32的so库，就可能导致应用程序崩溃。<br>所以，要再项目中excute  64位的几个so库，使用32位的。<br>这个根据不同项目设置，查一下自己项目用到了哪些64位的so库，都设置一遍<br>我的项目需要移除这些，然后就不报错了。Native Libs Monitor 这个软件很好用<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ndk</span> &#123;</span><br><span class="line">       //设置支持的SO库架构</span><br><span class="line">       abiFilters <span class="string">'armeabi'</span>, <span class="string">'x86'</span>, <span class="string">'armeabi-v7a'</span>, <span class="string">'x86_64'</span>, <span class="string">'arm64-v8a'</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">packagingOptions</span> &#123;</span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/libgnustl_shared.so"</span></span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/libijkffmpeg.so"</span></span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/libijkplayer.so"</span></span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/libijksdl.so"</span></span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/libimagepipeline.so"</span></span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/librtmp-jni.so"</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>8、把android 原生项目拷贝到reactnative 项目的android 目录下<br>上面步骤可以运行一个react-native 的简单项目，接下来时怎么集成到现有的Android 项目<br> react-native  项目结构如下：<br> <img src="http://oima95jt3.bkt.clouddn.com/blog/180730/K3g273KLmD.png?imageslim" alt="mark"><br> 我们做android的话，是用Android studio 打开 android 这个目录的。<br> 6、修改gradle 的依赖配置<br> dependencies {}闭包下 所有的compile 替换位implementation 或者api因为我的Android studio是3.1.3，老报错说compile 2018年底要删除已废弃。另外我的gradle是4.4  build gradle 工具 是3.1.3<br> （1）Android 项目根目录的 build.gradle文件修改<br> 如下：如果还是不行，建议跟我一样，加上google(). .可能如果是最新版 jencter有问题，用的时候调整下顺序试一试。尽量不要用最新版本的react-native<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">allprojects </span>&#123;</span><br><span class="line">    <span class="class">repositories </span>&#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        <span class="class">maven </span>&#123; url <span class="string">"https://jitpack.io"</span> &#125;</span><br><span class="line">        <span class="comment">//添加这个maven地址，不然无法下载 react-native库</span></span><br><span class="line">        <span class="class">maven </span>&#123;</span><br><span class="line">            <span class="comment">// All of React Native (JS, Android binaries) is installed from npm</span></span><br><span class="line">            url <span class="string">"$rootDir/../node_modules/react-native/android"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再app 的build.gradle 中添加依赖<br>使用api 或者implementation 都可以， 这里我也制定了版本。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">.........</span><br><span class="line">api <span class="string">"com.facebook.react:react-native:0.55.4"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7、配置权限</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.INTERNET"</span> /&gt;</span><br><span class="line"><span class="comment">//我还要添加一个权限，建议也添加了</span></span><br><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.SYSTEM_ALERT_WINDOW"</span>/&gt;</span><br></pre></td></tr></table></figure><p>再调试的时候我们一般需要访问DevSettingsActivity，所以也需要添加到AndroidManifest.xml：<br>手机摇一摇，或者菜单，设置 电脑服务的ip地址和端口要用到</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:<span class="built_in">name</span>=<span class="string">"com.facebook.react.devsupport.DevSettingsActivity"</span> /&gt;</span><br></pre></td></tr></table></figure><p>8、代码集成<br>刚刚创建的最简单的react-native 已经有了。我们就再我们Android 项目中加载这个最简单的页面</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">DefaultHardwareBackBtnHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> OVERLAY_PERMISSION_REQ_CODE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> ReactRootView mReactRootView;</span><br><span class="line">    <span class="keyword">private</span> ReactInstanceManager mReactInstanceManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">//这里不加权限判断 6.0或以上机型会闪退</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Settings.canDrawOverlays(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,</span><br><span class="line">                        Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">                startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mReactRootView = <span class="keyword">new</span> ReactRootView(<span class="keyword">this</span>);</span><br><span class="line">        mReactInstanceManager = ReactInstanceManager.builder()</span><br><span class="line">                .setApplication(getApplication())</span><br><span class="line">                <span class="comment">//这是设置assets目录下的打包过的js文件名 这个文件可用命令生成 但调试期间我们使用npm server动态注入 发布时才将它打进assets</span></span><br><span class="line">                .setBundleAssetName(<span class="string">"index.android.bundle"</span>)</span><br><span class="line">                <span class="comment">//这里设置js入口文件 旧一点的api可能是setJSMainModuleName 但我的版本是0.51.0 取而代之的是setJSMainModulePath方法</span></span><br><span class="line">                .setJSMainModulePath(<span class="string">"index"</span>)</span><br><span class="line">                .addPackage(<span class="keyword">new</span> MainReactPackage())</span><br><span class="line">                .setUseDeveloperSupport(BuildConfig.DEBUG)</span><br><span class="line">                .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的“FirstApp”必须</span></span><br><span class="line">        <span class="comment">// 对应index.js”中的“AppRegistry.registerComponent()”的第一个参数值</span></span><br><span class="line">        <span class="comment">// 对应“package.json”中的“name”属性值</span></span><br><span class="line">        <span class="comment">// 最好也将“app.json”中的“name”和“displayName”改成它</span></span><br><span class="line">        mReactRootView.startReactApplication(mReactInstanceManager, <span class="string">"FirstApp"</span>, <span class="keyword">null</span>);</span><br><span class="line">        setContentView(mReactRootView);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == OVERLAY_PERMISSION_REQ_CODE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!Settings.canDrawOverlays(<span class="keyword">this</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">invokeDefaultOnBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onHostPause(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onHostResume(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onHostDestroy(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mReactRootView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactRootView.unmountReactApplication();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onBackPressed();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.showDevOptionsDialog();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onKeyUp</span><span class="params">(keyCode, event)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是我的activity，大概意思和官网一样。。代码直接复制就行，需要注意的是：<br>代码制定的文件名一定要和 配置文件中的一致，要检查<br>app.json中的name和displayName属性值<br>ndex.js中registerComponent的第一个参数值<br>package.json中的name属性值<br>这几个值要保持一致</p><p>9、在真机上运行项目<br>直接在 reat-native  项目根目录运行命令  react-native run-android , 跳转到上面activity<br>然后运行起来如果是红屏，说是连不上服务，就摇一摇手机，选择 Debug server host 啥的，设置电脑的ip:8081 这样就能打开了。<br>或者，直接用Android studio 运行自己的Android 项目， 跳转到上面react  的activity ，也可以是fragment的。<br>如果出现错误，继续百度谷歌解决。。。有坑是肯定的嘛。先记录这些</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###集成步骤&lt;br&gt;官方文档：&lt;a href=&quot;https://facebook.github.io/react-native/docs/0.54/integration-with-existing-apps&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件官方文档03——ViewModel</title>
    <link href="http://yoursite.com/2018/07/02/android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A303%E2%80%94%E2%80%94ViewModel/"/>
    <id>http://yoursite.com/2018/07/02/android/Android架构组件官方文档03——ViewModel/</id>
    <published>2018-07-02T09:58:17.000Z</published>
    <updated>2018-07-02T09:59:05.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ViewModel概述"><a href="#ViewModel概述" class="headerlink" title="ViewModel概述"></a>ViewModel概述</h3><p><a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>类旨在以一种有生命周期意识的方式存储和管理与UI相关的数据。<br><a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>类允许数据在配置变化（例如屏幕旋转）后存活。<br><strong>注意：要将ViewModel导入到Android项目中，请参阅<a href="https://developer.android.google.cn/topic/libraries/architecture/adding-components.html#lifecycle" target="_blank" rel="noopener">向项目添加组件</a></strong></p><p>Android framework管理UI控制器的生命周期，例如Activity和Fragment。<br>framework可能会决定销毁或重新创建UI控制器，以响应完全不受您控制的特定用户操作或设备事件。</p><p>如果系统销毁或重新创建UI控制器，则存储在其中的任何临时UI相关的数据都将丢失。例如，您的应用可能包含其中一项活动中的用户列表。当为配置更改重新创建活动时，新活动必须重新获取用户列表。<br>对于简单的数据，Activity可以使用<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onSaveInstanceState%28android.os.Bundle%29" target="_blank" rel="noopener">onSaveInstanceState()</a>方法并从<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onCreate%28android.os.Bundle%29" target="_blank" rel="noopener">onCreate()</a>中的bundle中恢复其数据，但此方法仅适用于可以序列化然后反序列化的少量数据，可能不适合像用户或位图的列表这样的大量数据。</p><p>另一个问题是UI控制器经常需要进行异步调用，这可能需要一些时间才能返回。UI控制器需要管理这些调用，并确保系统在销毁后清理它们以避免潜在的内存泄漏。这种管理需要大量的维护，并且在为配置更改而重新创建对象的情况下，由于对象可能不得不重新发出已经做出的请求，所以浪费资源。</p><p>UI控制器（如Activity和Fragment）主要用于显示UI数据，对用户操作做出反应或处理操作系统通信（如权限请求）。如果要求UI控制器也负责从数据库或网络加载数据，就会使改类变得臃肿。为UI控制器分配过多的责任可能会导致一个类尝试单独处理应用程序的所有工作，而不是将工作委托给其他类。通过这种方式给UI控制器分配过多的责任也使测试变得更加困难。</p><p>将视图数据所有权从UI控制器逻辑中分离出来更简单，更高效。</p><h3 id="实现一个ViewModel"><a href="#实现一个ViewModel" class="headerlink" title="实现一个ViewModel"></a>实现一个ViewModel</h3><p>架构组件为UI控制器提供<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>助手类。<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>对象在配置更改期间会自动保留，以便它们保存的数据立即可用于下一个Activity或fragment实例。例如，如果您需要在应用中显示用户列表，请明确分配职责来获取数据并将用户列表保存到ViewModel，而不是Activity或fragment，如以下示例代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MutableLiveData</span>&lt;<span class="type">List</span>&lt;<span class="type">User</span>&gt;&gt; users;</span><br><span class="line">    public <span class="type">LiveData</span>&lt;<span class="type">List</span>&lt;<span class="type">User</span>&gt;&gt; getUsers() &#123;</span><br><span class="line">        <span class="keyword">if</span> (users == <span class="literal">null</span>) &#123;</span><br><span class="line">            users = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="type">List</span>&lt;<span class="type">User</span>&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void loadUsers() &#123;</span><br><span class="line">        <span class="comment">// Do an asynchronous operation to fetch users.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以从一个Activity中访问列表，如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">        <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyViewModel</span> model = <span class="type">ViewModelProviders</span>.of(<span class="keyword">this</span>).get(<span class="type">MyViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line">        model.getUsers().observe(<span class="keyword">this</span>, users -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Activity重新创建，它将接收由第一个Activity创建的相同的MyViewModel实例。当持有ViewModel的Activity finish后，框架将调用ViewModel对象的onCleared()方法，以便它可以清理资源。</p><p><strong>警告：ViewModel绝不能引用视图，生命周期或可能持有对活动上下文的引用的任何类。</strong></p><p><a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>对象被设计为脱离视图或LifecycleOwners的特定实例。这种设计还意味着您可以更轻松地编写测试来覆盖ViewModel，因为它不知道视图和生命周期对象。ViewModel对象可以包含LifecycleObservers，例如LiveData对象。但是，ViewModel对象绝不能观察对生命周期感知的可观察对象（如LiveData对象）的更改。如果ViewModel需要应用程序上下文（例如查找系统服务），那么它可以扩展AndroidViewModel类并具有构造函数，该构造函数在构造函数中接收Application，因为Application类扩展了Context。</p><h3 id="ViewMode的生命周期"><a href="#ViewMode的生命周期" class="headerlink" title="ViewMode的生命周期"></a>ViewMode的生命周期</h3><p>ViewModel对象的范围是在获取ViewModel时传递给<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModelProvider.html" target="_blank" rel="noopener">ViewModelProvider</a>的生命周期。ViewModel保留在内存中，直到生命周期的范围永久消失：在一个Activity的情况下，finish()时，在一个Fragment的情况下，当它被detached(分离)时。</p><p>图1说明了一个Activity在进行一次旋转然后finish后的各种生命周期状态。该图还显示了相关Activity生命周期旁边ViewModel的生命周期。这个特定的图表说明了一个Activity的状态。这些相同的基本状态同样适用于Fragment的生命周期。<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180702/KjKH5m6E8m.png?imageslim" alt="mark"></p><p>系统首次调用Activity对象的onCreate()方法时，通常会请求<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>。系统可能会在整个Activity的生命周期中多次调用onCreate()，例如当设备屏幕旋转时。<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>从第一次请求<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>直到Activity finished 和销毁时一直存在。</p><h3 id="在片段之间共享数据"><a href="#在片段之间共享数据" class="headerlink" title="在片段之间共享数据"></a>在片段之间共享数据</h3><p>Activity中的两个或更多fragment需要彼此进行通信是很常见的。想象一下，主-从关系的F让给met的一种常见情况，其中有一个Fragment，用户从列表中选择一个项目，另一个fragment显示所选项目的内容。这种情况有些麻烦，因为这两个片段都需要定义一些接口描述，并且所有者Activity必须将两者绑定在一起。此外，这两个fragment必须处理其他fragment尚未创建或可见的场景。</p><p>可以使用ViewModel对象解决这个常见的痛点。这些fragment可以使用其Activity范围共享ViewModel来处理此通信，如以下示例代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MutableLiveData</span>&lt;<span class="type">Item</span>&gt; selected = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="type">Item</span>&gt;();</span><br><span class="line"></span><br><span class="line">    public void select(<span class="type">Item</span> item) &#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">LiveData</span>&lt;<span class="type">Item</span>&gt; getSelected() &#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SharedViewModel</span> model;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        model = <span class="type">ViewModelProviders</span>.of(getActivity()).get(<span class="type">SharedViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="type">SharedViewModel</span> model = <span class="type">ViewModelProviders</span>.of(getActivity()).get(<span class="type">SharedViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line">        model.getSelected().observe(<span class="keyword">this</span>, item -&gt; &#123;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在获取ViewModelProvider时，这两个Fragment都使用getActivity()。因此，两个Fragment 都接收相同的SharedViewModel实例，该实例的范围限定为Activity。<br>这种方法具有以下优点：</p><ul><li><p>Activity不需要做任何事情，也不需要了解这种沟通。</p></li><li><p>除了SharedViewModel约定之外，fragment不需要彼此了解。如果其中一个fragment消失，另一个fragment继续照常工作。</p></li><li><p>每个片fragment都有其自己的生命周期，并且不受其他生命周期的影响。如果一个fragment替换另一个fragment，UI将继续工作而不会出现任何问题。</p></li></ul><h3 id="用ViewModel替换Loaders"><a href="#用ViewModel替换Loaders" class="headerlink" title="用ViewModel替换Loaders"></a>用ViewModel替换Loaders</h3><p>像<a href="https://developer.android.google.cn/reference/android/content/CursorLoader.html" target="_blank" rel="noopener">CursorLoader</a>这样的Loader类经常用于保持应用程序UI中的数据与数据库同步。您可以使用ViewModel和其他几个类来替换Loaders。使用ViewModel将您的UI控制器与数据加载操作分开，这意味着您在类之间的强引用减少了。</p><p>在使用loaders的一种常见方法中，应用程序可能使用CursorLoader来观察数据库的内容。当数据库中的值发生更改时，加载程序会自动触发重新加载数据并更新UI：<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180702/akE7BEdHC6.png?imageslim" alt="mark"><br><strong>图2.使用加载器加载数据</strong></p><p>ViewModel与Room和LiveData一起使用来替换Loaders。ViewModel可确保数据在设备配置更改后仍然存在。当数据库发生更改时，Room会通知您的LiveData，而LiveData则会用修改的数据更新您的UI。<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180702/aIAdcEJ71B.png?imageslim" alt="mark"><br><strong>图3.使用ViewModel加载数据</strong></p><p><a href="https://medium.com/google-developers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4" target="_blank" rel="noopener">此博客文章</a>描述了如何将ViewModel与LiveData一起使用来替换<a href="https://developer.android.google.cn/reference/android/content/AsyncTaskLoader.html" target="_blank" rel="noopener">AsyncTaskLoader</a>。</p><p>随着你的数据变得越来越复杂，你可能会选择一个单独的类来加载数据。ViewModel的目的是封装UI控制器的数据，以使数据不受配置更改的影响。有关如何跨配置更改加载，保留和管理数据的信息，请参阅<a href="https://developer.android.google.cn/topic/libraries/architecture/saving-states.html" target="_blank" rel="noopener">保存UI状态</a>。</p><p><a href="https://developer.android.google.cn/topic/libraries/architecture/guide.html#fetching_data" target="_blank" rel="noopener">Android App Architecture指南</a>建议构建一个存储库类来处理这些功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ViewModel概述&quot;&gt;&lt;a href=&quot;#ViewModel概述&quot; class=&quot;headerlink&quot; title=&quot;ViewModel概述&quot;&gt;&lt;/a&gt;ViewModel概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>架构组件——Lifecycle详解</title>
    <link href="http://yoursite.com/2018/06/27/android/%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Lifecycle%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/06/27/android/架构组件——Lifecycle详解/</id>
    <published>2018-06-27T08:58:43.000Z</published>
    <updated>2018-10-05T16:36:34.537Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、Lifecycle介绍"><a href="#1、Lifecycle介绍" class="headerlink" title="1、Lifecycle介绍"></a>1、Lifecycle介绍</h4><p>lifecycle官方文档地址：<br><a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">https://developer.android.com/topic/libraries/architecture/lifecycle</a></p><h5 id="为什么要使用lifecycle？"><a href="#为什么要使用lifecycle？" class="headerlink" title="为什么要使用lifecycle？"></a>为什么要使用lifecycle？</h5><blockquote><p>activity 和fragment 是有声明周期的，有时候，我们的很多操作需要写在声明周期的方法中，比如，下载，文件操作等，这样很多情况下回导致，我们在activity中的声明周期方法中写越来越多的代码，activity或者fragment 越来越臃肿，代码维护越来越困难。 使用lifecycle就可以很好的解决这类问题。<br>lifecycle代码简洁，我们可以通过实现LifecycleObserver 接口，来监听声明周期，然后我们在activity和fragment中去注册监听。</p></blockquote><h4 id="2、几个重要的类和接口"><a href="#2、几个重要的类和接口" class="headerlink" title="2、几个重要的类和接口"></a>2、几个重要的类和接口</h4><ul><li><p><strong>Lifecycle</strong><br> Lifecycle是一个持有组件生命周期状态（如Activity或Fragment）的信息的类，并允许其他对象观察此状态。</p></li><li><p><strong>Event</strong> ：从框架和Lifecycle类派发的生命周期事件。这些事件映射到活动和片段中的回调事件。</p></li><li><p><strong>State</strong> ：由Lifecycle对象跟踪的组件的当前状态。</p></li><li><strong>LifecycleOwner</strong> （重要）Lifecycle持有者</li><li><p>实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</p></li><li><p><strong>LifecycleObserver</strong>（重要）Lifecycle观察者</p></li><li>实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。</li></ul><h4 id="3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver-的使用"><a href="#3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver-的使用" class="headerlink" title="3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver 的使用"></a>3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver 的使用</h4><h5 id="（1）LifecycleOwner（生命周期持有者接口）"><a href="#（1）LifecycleOwner（生命周期持有者接口）" class="headerlink" title="（1）LifecycleOwner（生命周期持有者接口）"></a>（1）LifecycleOwner（生命周期持有者接口）</h5><blockquote><p>官网介绍：<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>是一个单一的方法接口，表示该类有一个 <a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>。它有一个方法，<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner#getLifecycle%28%29" target="_blank" rel="noopener">getLifecycle()</a>这个方法 必须由这个类来实现。如果您试图管理整个应用程序进程的生命周期，请参阅 <a href="https://developer.android.com/reference/android/arch/lifecycle/ProcessLifecycleOwner" target="_blank" rel="noopener">ProcessLifecycleOwner</a>。该接口从各个类（如Fragment和AppCompatActivity）抽象生命周期的所有权，并允许编写与它们一起工作的组件。<br>任何自定义应用程序类都可以实现LifecycleOwner接口<br>实现LifecycleObserver的组件与实现LifecycleOwner的组件无缝协作，因为所有者可以提供生命周期，观察者可以注册以观看</p></blockquote><p>简单来说，LifecycleOwner就是一个接口，谁继承了它，就持有了lifecycle对象。然后就可以调用getLifecycle()方法获取继承了抽象类Lifecycle的LifecycleRegistry，然后调用 addObserver(@NonNull LifecycleObserver observer) 方法来注册监听。<br>这样，<strong>该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</strong></p><p><strong>注意：Support Library 26.1.0 及其以后的版本，Activity 和Fragment 已经实现了LifecycleOwner 接口，所以，我们可以直接在Activity 和Fragment中使用getLifecycle()方法来获取lifecycle对象，来添加观察者监听。</strong></p><h5 id="（2）LifecycleObserver（生命周期观察者接口）"><a href="#（2）LifecycleObserver（生命周期观察者接口）" class="headerlink" title="（2）LifecycleObserver（生命周期观察者接口）"></a>（2）LifecycleObserver（生命周期观察者接口）</h5><blockquote><p>LifecycleObserver 是一个观察者接口，实现了它，可以通过注解或者继承的方式，来管理声明周期的监听。只要在持有lifecycle的类中注册了它，当声明周期发生变化时，它就能收到，进行我们自定义的操作。</p></blockquote><p>两种实现方式：</p><pre><code>1. 实现DefultLifecyceObserver接口，然后重写里面生命周期方法；2. 直接实现LifecycleObserver接口，然后通过注解的方式来接收生命周期的变化；</code></pre><p><strong>Lifecycle.java文档中是建议使用第一种方式，因为文档中说明了，随着Java8成为主流，注解的方式会被弃用。DefaultLifecycleObserver是需要另外声明的java8 比如下面</strong><br>GenericLifecycleObserver，FullLifecycleObserver，DefaultLifecycleObserver 这三个接口都是直接或者间接继承的LifecycleObserver</p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 如果使用的是java 8要显示声明如下的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lifecycle_version</span> </span>= <span class="string">"1.1.1"</span></span><br><span class="line">implementation <span class="string">"android.arch.lifecycle:common-java8:$lifecycle_version"</span></span><br></pre></td></tr></table></figure><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180626/DJk2i4fhm9.png" alt="mark"> </p><h4 id="3、开始使用Lifecycle"><a href="#3、开始使用Lifecycle" class="headerlink" title="3、开始使用Lifecycle"></a>3、开始使用Lifecycle</h4><p>我们写个测试代码，首先，我们要测试一下，到底LifecycleObserver到底能不能监听到声明周期的变化。并且实验下上图中的声明周期状态<br>先写两个简单的Activity，FirstActivity 和SecondActivity, 单纯的一个跳转。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Button</span> firstBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> <span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.first_activity_layout);</span><br><span class="line">        initView();</span><br><span class="line">        initListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initView() &#123;</span><br><span class="line">        firstBtn = findViewById(<span class="type">R</span>.id.first_btn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initListener() &#123;</span><br><span class="line">        firstBtn.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onClick(<span class="type">View</span> v) &#123;</span><br><span class="line">                <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="type">FirstActivity</span>.<span class="keyword">this</span>, <span class="type">SecondActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们要做的是要写一个需要拥有声明周期的类，正常我们自定义控件啊，或者做其他逻辑的类，是没有声明周期的，现在有了LifecycleObserver,我们可以让一个普通的类拥有感知声明周期变化的能力。比如，现在自定义一个，MyObserver类。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class MyObserver implements DefaultLifecycleObserver&#123;</span><br><span class="line">   <span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"MyListener"</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onCreate(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onCreate()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onStart(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onStart()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onResume(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onResume()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onPause(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onPause()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onStop(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onStop()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onDestroy(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onDestroy() "</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们采取的是，直接继承DefaultLifecycleObserver接口，来实现它所有的方法。我们在里面做了log,来查看，是否这个类，收到了activity声明周期的变化。<br>然后，要做的就是<strong>注册监听</strong><br>在Activity 的OnCreate方法中，调用getLifecycle();</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Button</span> firstBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> <span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.first_activity_layout);</span><br><span class="line">        initView();</span><br><span class="line">        initListener();</span><br><span class="line">        <span class="comment">//添加了这一行代码</span></span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="type">MyObserver</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initView() &#123;</span><br><span class="line">        firstBtn = findViewById(<span class="type">R</span>.id.first_btn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initListener() &#123;</span><br><span class="line">        firstBtn.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onClick(<span class="type">View</span> v) &#123;</span><br><span class="line">                <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="type">FirstActivity</span>.<span class="keyword">this</span>, <span class="type">SecondActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，api26,.1以后，Activity中可以直接 getLifecycle().addObserver(new MyObserver()); 这样，就已经注册了声明周期观察者的监听。运行查看log<br>启动FirstActivity后，MyObserver类已经监听到了Activity的声明周期方法<br>并且，和图中表示一致，各个声明周期方法对应相应的节点。一定要清楚，后面会用到。比如，onResume()方法执行后，Activity处于RESUME状态，我们可以通过判断这个状态来做一些事情<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/cD74jCJ522.png?imageslim" alt="mark"><br>点击跳转到SecondActivity<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/7A8Ia38Kb2.png?imageslim" alt="mark"><br>可以看到，FirstActivity声明周期走了onPause  onStop，MyObserver也成功监听到了，继续返回FirstActivity<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/dB5fkImjbE.png?imageslim" alt="mark"><br>最后，点击返回键，退出FirstActivity，<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/8lIlKAejLF.png?imageslim" alt="mark"></p><p>通过这个简单的小例子，我们看到了 我们的类，只要实现了 LifecycleObserver接口，然后，在Activity 或者Fragment中 通过getLifecycle().addObserver()方法，把这个类的对象传入，就可以实现声明周期的感应监听。</p><p>当然，我们可以再初始化这个类的时候，把Lifecycle对象传入，那我们自定义的类就可以自己去管理声明周期，而不依赖activity或者fragment。 这样，activity在使用此类的时候就不必关系声明周期的问题，因为，在这个类里面我们已经处理了。比如： 给MyObserver类 添加一个构造方法，传入一个Lifecycle对象。</p><p><strong>要注意的是：</strong><br>生命周期状态为<strong>RESUMED</strong>时表示，当前activity 是在前台，并且可交互也就是onResume()执行后</p><p>生命周期状态为<strong>STARTED</strong>时，表示当前activity处于可见但是不可交互，也就是onStart()方法刚执行完或者onPause()方法刚执行完的状态</p><p>生命周期状态为<strong>CREATED</strong>,表示onCreate()方法刚刚执行完或者onStop()方法刚刚执行完，也就是当前activity不在前台，但是也没有处于销毁状态。</p><p>生命周期状态为<strong>DESTORYED</strong>,表示当前Activity还不存在，没有被创建或者已经销毁，我们通常考虑比较多的就是，onDestory()方法执行后，当前Activity已经销毁。</p><p>所以，如果我们要保证在Activity或者Fragment的有效生命周期内进行的操作，必须判断，<strong>当前lifecycle的状态是否至少是CREATED状态</strong>，避免Activity或者fragment销毁了以后，回调或者网络请求才回来，此时做一些操作会导致异常。</p><p>添加以下代码，就是我们把lifecycle对象传给观察者，让它自己去判断回调后的代码，保证至少是CREATED状态<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Lifecycle lifecycle;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Lifecycle lifecycle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//然后再相应的回调方法中使用下面代码判断，保证数据回调回来，当前activity是存在的</span></span><br><span class="line">    <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(CREATED)) &#123;</span><br><span class="line">            <span class="comment">//这里只是示例，不一定是CREATED</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里用到了Lifecycle类的方法，下面我们看一下Lifecycle的源码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> &#123;</span></span><br><span class="line">    <span class="meta">@MainThread</span>  <span class="comment">//添加将在LifecycleOwner更改状态时通知的LifecycleObserver。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> addObserver(<span class="meta">@NonNull</span> LifecycleObserver observer);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span> <span class="comment">//从观察者列表中删除给定的观察者。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> removeObserver(<span class="meta">@NonNull</span> LifecycleObserver observer);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span> <span class="comment">//返回生命周期的当前状态。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> State getCurrentState();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        ON_CREATE,<span class="comment">//用于onCreate事件的常量LifecycleOwner。</span></span><br><span class="line"></span><br><span class="line">        ON_START,</span><br><span class="line"></span><br><span class="line">        ON_RESUME,</span><br><span class="line"></span><br><span class="line">        ON_PAUSE,</span><br><span class="line"></span><br><span class="line">        ON_STOP,</span><br><span class="line"></span><br><span class="line">        ON_DESTROY,</span><br><span class="line"></span><br><span class="line">        ON_ANY <span class="comment">//一个Event可以用来匹配所有事件的常数。 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED, <span class="comment">//LifecycleOwner的初始化状态。 </span></span><br><span class="line">        CREATED, </span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line"><span class="comment">//比较此状态是否大于或等于给定值state。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isAtLeast(<span class="meta">@NonNull</span> State state) &#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marks a class as a LifecycleObserver. It does not have any methods, instead, relies on</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> OnLifecycleEvent&#125; annotated methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Lifecycle Lifecycle - for samples and usage patterns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleObserver</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个抽象类，注释已经很详细了，应该不用解释了</p><p>最后借用下官网的-生命周期感知组件的最佳实战</p><pre><code>1. 尽可能保持您的UI控制器（活动和片段）尽可能精简。他们不应该试图获取他们自己的数据;相反，使用[ViewModel](https://developer.android.com/reference/android/arch/lifecycle/ViewModel)来做到这一点，并观察一个LiveData对象来反映更改回视图。2. 尝试编写数据驱动的用户界面，其中您的用户界面控制器的职责是在数据更改时更新视图，或将用户操作通知给ViewModel。3. 把你的数据逻辑放在[ViewModel](https://developer.android.com/reference/android/arch/lifecycle/ViewModel)类中。ViewModel应作为您的UI控制器和其他应用程序之间的连接器。但要小心，ViewModel不负责提取数据（例如，来自网络）。相反，ViewModel应调用相应的组件来获取数据，然后将结果提供给UI控制器。4. 使用[dataBinding](https://developer.android.com/topic/libraries/data-binding/)在视图和UI控制器之间保持干净的界面。这使您可以使您的视图更具说明性，并最大限度地减少需要在活动和片段中编写的更新代码。   如果你喜欢用Java编程语言来做到这一点，可以使用像Butter Knife这样的库来避免样板代码并且有更好的抽象。5. 如果您的UI很复杂，请考虑创建一个演示者类（[presenter](http://www.gwtproject.org/articles/mvp-architecture.html#presenter)）来处理UI修改。这可能是一项艰巨的任务，但它可以使您的UI组件更易于测试。6. 避免在ViewModel中引用View或Activity上下文。   如果ViewModel超出活动（在配置更改的情况下），则活动会泄漏并且垃圾收集器无法正确处理。</code></pre><p>借用下<a href="https://blog.csdn.net/zhuzp_blog/article/details/78871374" target="_blank" rel="noopener">https://blog.csdn.net/zhuzp_blog/article/details/78871374</a>  作者的两张图，更清晰，对于相信信息，可到作者博客去查看相关讲解<br><img src="https://img-blog.csdn.net/20180531152720780?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180531152910152?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、Lifecycle介绍&quot;&gt;&lt;a href=&quot;#1、Lifecycle介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Lifecycle介绍&quot;&gt;&lt;/a&gt;1、Lifecycle介绍&lt;/h4&gt;&lt;p&gt;lifecycle官方文档地址：&lt;br&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件官方文档02——LiveData</title>
    <link href="http://yoursite.com/2018/06/27/android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A302%E2%80%94%E2%80%94LiveData/"/>
    <id>http://yoursite.com/2018/06/27/android/Android架构组件官方文档02——LiveData/</id>
    <published>2018-06-27T03:33:09.000Z</published>
    <updated>2018-10-05T15:38:01.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LiveData概述"><a href="#LiveData概述" class="headerlink" title="LiveData概述"></a>LiveData概述</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>是一个可观察的数据持有者类。<br>与常规可观察性不同，LiveData具有生命周期感知能力，这意味着它尊重其他应用程序组件（例如活动，片段或服务）的生命周期。<br>这种感知确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。<br>注意：要将LiveData组件导入到Android项目中，请参阅向项目<a href="https://developer.android.com/topic/libraries/architecture/adding-components.html#lifecycle" target="_blank" rel="noopener">添加组件</a>。<br>如果观察者的生命周期处于<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#STARTED" target="_blank" rel="noopener">STARTED</a>或<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#RESUMED" target="_blank" rel="noopener">RESUMED</a>状态，则LiveData会将<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html" target="_blank" rel="noopener">Observer</a>类表示的观察者视为活动状态。<br><a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>仅通知处于活跃状态的观察者更新。<br>未注册观看<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>对象的非活跃期的观察者不会收到有关更改的通知。</p><p>您可以注册与实现LifecycleOwner接口的对象配对的观察者。此关系允许在相应生命周期对象的状态更改为DESTROYED时删除观察者。<br>这对于活动和片段尤其有用，因为它们可以安全地观察LiveData对象，而不必担心泄漏 - 在其生命周期被破坏时，活动和片段会立即取消订阅。</p><p>有关如何使用LiveData的更多信息，请参阅使用LiveData对象</p><h3 id="使用LiveData的优点"><a href="#使用LiveData的优点" class="headerlink" title="使用LiveData的优点"></a>使用LiveData的优点</h3><p>使用LiveData提供以下优点：<br><strong>确保您的UI界面符合您UI数据状态</strong></p><blockquote><p>LiveData遵循观察者模式。<br>当生命周期状态改变时，LiveData会通知Observer对象。<br>您可以合并代码以更新这些Observer对象中的UI。<br>每次应用程序数据更改时，您的观察者都可以在每次更改时更新UI，而不是每次更新UI。<br><strong>没有内存泄漏</strong><br>观察者绑定到<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.html" target="_blank" rel="noopener">Lifecycle</a>对象，并在其相关生命周期被破坏后自行清理。</p></blockquote><p><strong>不会因为活动停止而崩溃</strong></p><blockquote><p>如果观察者的生命周期处于非活动状态，例如在后退堆栈中的活动，则它不会收到任何LiveData事件。</p></blockquote><p><strong>没有更多的手动声明周期处理</strong><br>UI组件只是观察相关数据，不停止或恢复观察。<br>LiveData自动管理所有这些，因为它在观察时意识到相关的生命周期状态更改。<br><strong>始终保持最新的数据</strong><br>如果生命周期变为非活动状态，它将在再次变为活动状态时收到最新数据。例如，后台活动在返回到前台后立即收到最新数据。<br><strong>正确的配置更改</strong><br>如果由于配置更改（如设备旋转）而重新创建活动或片段，它会立即收到最新的可用数据。<br><strong>共享资源</strong><br>您可以使用单例模式扩展LiveData对象以包装系统服务，以便它们可以在应用程序中共享。<br>LiveData对象连接到系统服务一次，然后任何需要该资源的观察者都可以观看LiveData对象。<br>有关更多信息，请参阅扩展LiveData。</p><h3 id="使用LiveData对象"><a href="#使用LiveData对象" class="headerlink" title="使用LiveData对象"></a>使用LiveData对象</h3><p>按照以下步骤操作LiveData对象：</p><ol><li>创建一个LiveData实例来保存某种类型的数据。这通常在您的<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>类中完成。</li><li>创建一个<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html" target="_blank" rel="noopener">Observer</a>对象，该对象定义<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html#onChanged%28T%29" target="_blank" rel="noopener">onChanged</a>()方法，该方法控制LiveData对象保存的数据更改时发生的情况。您通常在UI控制器中创建Observer对象，如活动或片段。</li><li>使用observe()方法将Observer对象附加到LiveData对象。observe()方法使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner.html" target="_blank" rel="noopener">LifecycleOwner</a>对象。这将Observer对象订阅到LiveData对象，以便通知其更改。您通常将Observer对象附加到UI控制器中，例如Activity或Fragment。</li></ol><blockquote><p><strong>注意：您可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#observeForever%28android.arch.lifecycle.Observer%3CT%3E%29" target="_blank" rel="noopener">observeForever（Observer）</a>方法注册一个没有关联的LifecycleOwner对象的观察器。在这种情况下，观察者被认为始终处于活动状态，因此总是通知修改。您可以删除这些观察者调用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#removeObserver%28android.arch.lifecycle.Observer%3CT%3E%29" target="_blank" rel="noopener">removeObserver（Observer）</a>方法。</strong></p></blockquote><p>当您更新存储在LiveData对象中的值时，只要附加的LifecycleOwner处于活动状态，它就会触发所有已注册的观察者。<br>LiveData允许UI控制器观察者订阅更新。当LiveData对象持有的数据更改时，UI会自动更新以作为响应。</p><h4 id="创建LiveData对象"><a href="#创建LiveData对象" class="headerlink" title="创建LiveData对象"></a>创建LiveData对象</h4><p>LiveData是一个可用于任何数据的包装器，包括实现集合的对象（如List）。LiveData对象通常存储在ViewModel对象中，并通过getter方法访问，如以下示例所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NameViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a LiveData with a String</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">MutableLiveData</span>&lt;<span class="type">String</span>&gt; mCurrentName;</span><br><span class="line"></span><br><span class="line">    public <span class="type">MutableLiveData</span>&lt;<span class="type">String</span>&gt; getCurrentName() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurrentName == <span class="literal">null</span>) &#123;</span><br><span class="line">            mCurrentName = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="type">String</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mCurrentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rest of the ViewModel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初，LiveData对象中的数据未设置。</p><blockquote><p>注意：由于以下原因，请确保存储更新<strong>ViewModel</strong>对象中的UI的<strong>LiveData</strong>对象，而不是活动或片段：</p><ul><li>避免臃肿的活动和碎片。现在这些UI控制器负责显示数据但不保存数据状态。</li><li>将<strong>LiveData</strong>实例与特定活动或片段实例分离，并允许<strong>LiveData</strong>对象保留配置更改。</li></ul></blockquote><p>您可以在<strong><a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank" rel="noopener">ViewModel指南</a></strong>中了解更多关于ViewModel类的好处和用法。</p><h4 id="观察LiveData对象"><a href="#观察LiveData对象" class="headerlink" title="观察LiveData对象"></a>观察LiveData对象</h4><p>在大多数情况下，出于以下原因，应用程序组件的onCreate()方法是开始观察LiveData对象的正确位置：</p><ol><li>确保系统不会从Activity或fragment的onResume（）方法进行多余的调用。</li><li>确保Activity或Fragment<strong>具有</strong>一旦它变为活动状态即可显示的<strong>数据</strong>。只要应用程序组件处于<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#STARTED" target="_blank" rel="noopener">STARTED</a>状态，它就会从它所观察的LiveData对象中接收最新的值。这只会在设置要观察的LiveData对象时才会发生。</li></ol><p>通常，LiveData仅在数据更改时传递更新，并且仅传递给活动观察者。此行为的一个例外是，观察者在从非活动状态变为活动状态时也会收到更新。此外，如果观察者第二次从非激活状态变为激活状态，则只有在自上一次变为活动状态以来该值发生变化时才会收到更新。</p><p>以下示例代码说明了如何开始观察LiveData对象：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NameActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">NameViewModel</span> mModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Other code to setup the activity...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the ViewModel.</span></span><br><span class="line">        mModel = <span class="type">ViewModelProviders</span>.of(<span class="keyword">this</span>).get(<span class="type">NameViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the observer which updates the UI.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Observer</span>&lt;<span class="type">String</span>&gt; nameObserver = <span class="keyword">new</span> <span class="type">Observer</span>&lt;<span class="type">String</span>&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onChanged(<span class="meta">@Nullable</span> <span class="keyword">final</span> <span class="type">String</span> newName) &#123;</span><br><span class="line">                <span class="comment">// Update the UI, in this case, a TextView.</span></span><br><span class="line">                mNameTextView.setText(newName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.</span></span><br><span class="line">        mModel.getCurrentName().observe(<span class="keyword">this</span>, nameObserver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用nameObserver作为参数传递<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#observe%28android.arch.lifecycle.LifecycleOwner,android.arch.lifecycle.Observer%3CT%3E%29" target="_blank" rel="noopener">observe()</a>后，立即调用<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html#onChanged%28T%29" target="_blank" rel="noopener">onChanged()</a>，以提供存储在mCurrentName中的最新值。如果LiveData对象未在mCurrentName中设置值，则不调用onChanged()。</p><h4 id="更新LiveData对象"><a href="#更新LiveData对象" class="headerlink" title="更新LiveData对象"></a>更新LiveData对象</h4><p>LiveData没有公开可用的方法来更新存储的数据。<a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html" target="_blank" rel="noopener">MutableLiveData</a>类公开公开<a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#setValue%28T%29" target="_blank" rel="noopener">setValue(T)</a>和<a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#postValue%28T%29" target="_blank" rel="noopener">postValue(T)</a>方法，如果需要编辑存储在LiveData对象中的值，则必须使用这些方法。通常在ViewModel中使用MutableLiveData，然后ViewModel只向观察者公开不可变的LiveData对象。<br>在建立观察者关系后，可以更新LiveData对象的值，如以下示例所示，当用户点击按钮时触发所有观察者：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String anotherName = <span class="string">"John Doe"</span>;</span><br><span class="line">        mModel.getCurrentName().setValue(anotherName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在示例中调用setValue（T）会导致观察者用值John Doe调用它们的onChanged（）方法。该示例显示按钮按下，但setValue（）或postValue（）可能因多种原因被调用来更新mName，包括响应网络请求或数据库加载完成;在所有情况下，调用setValue（）或postValue（）都会触发观察者并更新UI。</p><blockquote><p>注意：您必须调用setValue（T）方法来更新主线程中的LiveData对象。如果代码在工作线程中执行，则可以使用postValue（T）方法更新LiveData对象。</p></blockquote><h4 id="与Room一起使用LiveData"><a href="#与Room一起使用LiveData" class="headerlink" title="与Room一起使用LiveData"></a>与Room一起使用LiveData</h4><p><a href="https://developer.android.com/training/data-storage/room/index.html" target="_blank" rel="noopener">Room</a>持久性库支持返回<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>对象的可观察查询。可观察查询是作为数据库访问对象（DAO）的一部分写入的。</p><p>当更新数据库时，会生成所有必要的代码以更新LiveData对象。生成的代码在需要时在后台线程上异步运行查询。这种模式对于保持UI中显示的数据与存储在数据库中的数据保持同步很有用。您可以在<a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank" rel="noopener">Room持久库指南</a>中阅读关于Room和DAO的更多信息。</p><h3 id="扩展LiveData"><a href="#扩展LiveData" class="headerlink" title="扩展LiveData"></a>扩展LiveData</h3><p>如果观察者的生命周期处于<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#STARTED" target="_blank" rel="noopener">STARTED</a>或<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#RESUMED" target="_blank" rel="noopener">RESUMED</a>状态，则<strong>LiveData</strong>将认为观察者处于活动状态。以下示例代码说明了如何扩展<strong>LiveData</strong>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StockManager mStockManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePriceListener mListener = <span class="keyword">new</span> SimplePriceListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPriceChanged</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">            setValue(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockLiveData</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        mStockManager = <span class="keyword">new</span> StockManager(symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.requestPriceUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.removeUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本示例中的价格监听器的实现包括以下重要方法：</p><ul><li><p>当LiveData对象具有处于活跃期的观察者时，将调用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#onActive%28%29" target="_blank" rel="noopener">onActive（）</a>方法。这意味着您需要开始观察此方法的价格更新。</p></li><li><p>当LiveData对象没有任何active期间的观察者时，将调用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#onInactive%28%29" target="_blank" rel="noopener">onInactive（）</a>方法。由于没有观察员在监听，因此没有理由保持连接到StockManager服务。</p></li><li><a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#setValue%28T%29" target="_blank" rel="noopener">setValue（T）</a>方法更新LiveData实例的值并通知任何活跃的观察者有关更改。</li></ul><p>您可以使用StockLiveData类如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void onActivityCreated(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        <span class="type">LiveData</span>&lt;<span class="type">BigDecimal</span>&gt; myPriceListener = ...;</span><br><span class="line">        myPriceListener.observe(<span class="keyword">this</span>, price -&gt; &#123;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>observe（）方法将把实现了LifecycleOwner实例的Fragment作为第一个参数传递。这样做表示此观察者被绑定到与所有者关联的生命周期对象，这意味着：</p><ul><li>如果生命周期对象不处于活跃状态，则即使值发生更改，也不会调用观察者。</li><li>生命周期对象被销毁后，观察者被自动删除。t<br> LiveData对象支持生命周期意味着您可以在多个Activity，Fragment和Service之间共享它们。为了保持示例简单，您可以按如下方式将LiveData类实现为单例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StockLiveData sInstance;</span><br><span class="line">    <span class="keyword">private</span> StockManager mStockManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePriceListener mListener = <span class="keyword">new</span> SimplePriceListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPriceChanged</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">            setValue(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StockLiveData <span class="title">get</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> StockLiveData(symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StockLiveData</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        mStockManager = <span class="keyword">new</span> StockManager(symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.requestPriceUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.removeUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以再Fragment中使用它，如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void onActivityCreated(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="type">StockLiveData</span>.get(getActivity()).observe(<span class="keyword">this</span>, price -&gt; &#123;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个Fragment和Activity可以观察MyPriceListener实例。如果LiveData只有一个或多个可见并处于活动状态，则LiveData仅连接到系统服务。</p><h3 id="转换LiveData"><a href="#转换LiveData" class="headerlink" title="转换LiveData"></a>转换LiveData</h3><p>您可能希望在LiveData更改为观察者之前更改存储在LiveData对象中的，或者您可能需要基于另一个LiveData实例的值返回不同的LiveData实例。Lifecycle软件包提供Transformations类，其中包括支持这些场景的帮助方法。<br><strong><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#map%28android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20Y%3E%29" target="_blank" rel="noopener">Transformations.map()</a></strong><br>在存储在LiveData对象中的值上使用函数，并向下游传播结果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LiveData&lt;User&gt; userLiveData = <span class="built_in">..</span>.;</span><br><span class="line">LiveData&lt;String&gt; userName = Transformations.map(userLiveData,<span class="built_in"> user </span>-&gt; &#123;</span><br><span class="line">    user.name + <span class="string">" "</span> + user.lastName</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations#switchMap%28android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20android.arch.lifecycle.LiveData%3CY%3E%3E%29" target="_blank" rel="noopener">Transformations.switchMap()</a></strong></p><p>与map（）类似，将函数应用于存储在LiveData对象中的值，并展开并向下游分派结果。传递给switchMap（）的函数必须返回一个LiveData对象，如下例所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private LiveData&lt;User&gt; getUser(String id) &#123;</span><br><span class="line">  <span class="built_in">..</span>.;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveData&lt;String&gt; userId = <span class="built_in">..</span>.;</span><br><span class="line">LiveData&lt;User&gt;<span class="built_in"> user </span>= Transformations.switchMap(userId, id -&gt; getUser(id) );</span><br></pre></td></tr></table></figure><p>您可以使用转换方法在观察者的生命周期中传递信息。除非观察者正在观察返回的LiveData对象，否则不会计算转换。由于转换是懒加载的，因此与生命周期相关的行为会隐式传递，而不需要额外的显式调用或依赖关系。</p><p>如果您认为您需要ViewModel对象中的Lifecycle对象，则转换可能是更好的解决方案。例如，假设您有一个接受地址并返回该地址的邮政编码的UI组件。您可以为此组件实现native的ViewModel，如以下示例代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PostalCodeRepository</span> repository;</span><br><span class="line">    public <span class="type">MyViewModel</span>(<span class="type">PostalCodeRepository</span> repository) &#123;</span><br><span class="line">       <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">LiveData</span>&lt;<span class="type">String</span>&gt; getPostalCode(<span class="type">String</span> address) &#123;</span><br><span class="line">       <span class="comment">// DON'T DO THIS</span></span><br><span class="line">       <span class="keyword">return</span> repository.getPostCode(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，postalCode是public的和fina的，因为该字段永远不会改变。postalCode字段定义为addressInput的转换，这意味着addressInput发生更改时将调用repository.getPostCode（）方法。如果存在活动观察者，那么这是真实的，如果在repository.getPostCode（）被调用时没有活跃的观察者，则在添加观察者之前不进行计算。</p><p>该机制允许版本较低的应用程序创建按需延迟计算的LiveData对象。ViewModel对象可以轻松获得对LiveData对象的引用，然后在其上定义转换规则。</p><h4 id="创建新的转换"><a href="#创建新的转换" class="headerlink" title="创建新的转换"></a>创建新的转换</h4><p>有十几种不同的特定转换可能在您的应用中很有用，但它们不是默认提供的。要实现自己的转换，您可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData.html" target="_blank" rel="noopener">MediatorLiveData</a>类，它监听其他<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>对象并处理它们发出的事件。<strong>MediatorLiveData</strong>将其状态正确传播到源<strong>LiveData</strong>对象。要了解有关此模式的更多信息，请参阅<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html" target="_blank" rel="noopener">Transformations</a>类的参考文档。</p><h3 id="合并多个LiveData源"><a href="#合并多个LiveData源" class="headerlink" title="合并多个LiveData源"></a>合并多个LiveData源</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData.html" target="_blank" rel="noopener">MediatorLiveData</a>是<strong>LiveData</strong>的一个子类，允许您合并多个LiveData源。<strong>MediatorLiveData</strong>对象的观察者随后会在任何原始<strong>LiveData</strong>源对象更改时触发。</p><p>例如，如果您的UI中有一个可从本地数据库或网络更新的LiveData对象，则可以将以下资源添加到MediatorLiveData对象：</p><ul><li>与存储在数据库中的数据关联的LiveData对象。</li><li>与从网络访问的数据关联的LiveData对象。<br> 您的活动只需观察<strong>MediatorLiveData</strong>对象即可从两个来源接收更新。有关详细示例，请参阅<a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank" rel="noopener">应用程序体系结构指南</a>的附录：<a href="https://developer.android.com/topic/libraries/architecture/guide.html#addendum" target="_blank" rel="noopener">展示网络状态部分</a>。<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3>有关在<a href="https://developer.android.com/training/snackbar" target="_blank" rel="noopener">Snackbar</a>消息，导航事件和其他事件中使用LiveData的其他信息，请<a href="https://medium.com/google-developers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150" target="_blank" rel="noopener">阅读此文章</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LiveData概述&quot;&gt;&lt;a href=&quot;#LiveData概述&quot; class=&quot;headerlink&quot; title=&quot;LiveData概述&quot;&gt;&lt;/a&gt;LiveData概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件官方文档01——Lifecycle</title>
    <link href="http://yoursite.com/2018/06/26/android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A301%E2%80%94%E2%80%94Lifecycle/"/>
    <id>http://yoursite.com/2018/06/26/android/Android架构组件官方文档01——Lifecycle/</id>
    <published>2018-06-26T09:14:34.000Z</published>
    <updated>2018-06-27T03:37:55.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用生命周期感知组件处理生命周期"><a href="#使用生命周期感知组件处理生命周期" class="headerlink" title="使用生命周期感知组件处理生命周期"></a>使用生命周期感知组件处理生命周期</h2><blockquote><p>支持生命周期的组件执行操作以响应另一个组件（例如Activity和fragment）的生命周期状态更改。这些组件可帮助您生成组织性更好，并且通常更轻量的代码，这些代码更易于维护。</p></blockquote><blockquote><p>常见的模式是在Activity和fragment的生命周期方法中实现依赖组件的操作。<br>但是，这种模式导致代码的组织不良以及错误泛滥。通过使用生命周期感知组件，您可以将相关组件的代码从生命周期方法中移出并移入组件本身。</p></blockquote><blockquote><p>android.arch.lifecycle包提供了类和接口，可让您构建支持生命周期的组件，这些组件可根据活动或片段的当前生命周期状态自动调整其行为<br><strong> 注意：要将<a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener">android.arch.lifecycle</a>导入到Android项目中，请参阅<a href="https://developer.android.com/topic/libraries/architecture/adding-components#lifecycle" target="_blank" rel="noopener">向项目添加组件</a>。 </strong></p></blockquote><blockquote><p>Android框架中定义的大多数应用程序组件都附带有生命周期。生命周期由操作系统或您的流程中运行的框架代码管理。它们是Android如何工作和应用程序必须尊重它们的核心。不这样做可能会触发内存泄漏甚至应用程序崩溃。</p></blockquote><p>想象一下，我们有一个在屏幕上显示设备位置的Activity。<br>常见的实现可能如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// connect to system location service</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect from system location service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, (location) -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   尽管这个示例看起来很好，但在实际的应用程序中，您最终会有太多的调用来管理UI和其他组件，以响应当前的生命周期状态。<br>管理多个组件会在生命周期方法中放置大量代码，例如onStart（）和onStop（），这使得它们很难维护。</p><p>此外，无法保证组件在活动或片段停止之前启动。<br>如果我们需要执行一个长时间运行的操作，比如onStart（）中的一些配置检查，情况尤其如此。<br>这可能会导致onStop（）方法在onStart（）之前完成的争用条件，从而使组件的存活时间超过所需的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// what if this callback is invoked AFTER activity is stopped?</span></span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener">android.arch.lifecycle</a>包提供的类和接口可帮助您以弹性和独立的方式解决这些问题。</p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>是一个持有组件生命周期状态（如Activity或Fragment）的信息的类，并允许其他对象观察此状态。<br><a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>使用两个主要枚举来跟踪其关联组件的生命周期状态：</p><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>&emsp;&emsp;从框架和Lifecycle类派发的生命周期事件。<br>&emsp;&emsp;这些事件映射到Activities和fragments中的回调事件。</p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>&emsp;&emsp;由Lifecycle对象跟踪的组件的当前状态。</p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180626/DJk2i4fhm9.png?imageslim" alt="mark"></p><p>将状态视为图中的节点，将事件视为这些节点之间的边界。</p><p>一个类可以通过向其方法添加注解来监视组件的生命周期状态。<br>然后，您可以通过调用Lifecycle类的<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle#addObserver%28android.arch.lifecycle.LifecycleObserver%29" target="_blank" rel="noopener">addObserver（）</a>方法并传递观察者的实例来添加观察者，如下例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">MyObserver</span> <span class="selector-tag">implements</span> <span class="selector-tag">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="variable">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    public void connectListener() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    public void disconnectListener() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">myLifecycleOwner</span><span class="selector-class">.getLifecycle</span>()<span class="selector-class">.addObserver</span>(new MyObserver());</span><br></pre></td></tr></table></figure><p>在上面的例子中，myLifecycleOwner对象实现了<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>接口，这将在下一节中介绍。</p><h3 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>是一个单一的方法接口，表示该类有一个<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>。<br>它有一个方法<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner#getLifecycle%28%29" target="_blank" rel="noopener">getLifecycle（）</a>，它必须由class实现。<br>如果您试图管理整个应用程序进程的生命周期，请参阅<a href="https://developer.android.com/reference/android/arch/lifecycle/ProcessLifecycleOwner" target="_blank" rel="noopener">ProcessLifecycleOwner</a>。</p><p>该接口从各个类（如Fragment和AppCompatActivity）抽象生命周期的所有权，并允许编写与它们一起工作的组件。<br>任何自定义应用程序类都可以实现LifecycleOwner接口</p><p>实现<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleObserver" target="_blank" rel="noopener">LifecycleObserver</a>的组件可以与实现<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>的组件无缝协作，因为所有者可以提供生命周期，观察者可以注册观察。</p><p>对于位置跟踪示例，我们可以使MyLocationListener类实现LifecycleObserver，然后使用onCreate()方法中的活动生命周期对其进行初始化。<br>这允许MyLocationListener类是自给自足的，这意味着对生命周期状态变化作出反应的逻辑在MyLocationListener中声明，而不是在活动中声明。<br>让各个组件存储自己的逻辑使得活动和片段逻辑更容易管理。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyLocationListener</span> myLocationListener;</span><br><span class="line"></span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> <span class="type">MyLocationListener</span>(<span class="keyword">this</span>, getLifecycle(), location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Util</span>.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.enable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个常见的用例就是避免在生命周期状处于不好的状态时调用某些回调。<br>例如，如果回调在保存活动状态后运行fragment事务，则会触发崩溃，因此我们绝不希望调用该回调。</p><p>为了简化这个用例，生命周期类允许其他对象查询当前状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Lifecycle lifecycle, Callback callback)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">           <span class="comment">// connect</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        enabled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123;</span><br><span class="line">            <span class="comment">// connect if not connected</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect if connected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个实现，我们的LocationListener类完全是生命周期感知的。<br>如果我们需要使用来自其他Activity或Fragment的LocationListener，我们只需要初始化它。<br>所有的启动和销毁操作都由该类本身进行管理。</p><p>如果Library提供需要与Android生命周期配合使用的类，我们建议您使用支持生命周期的组件。<br>您的Library客户端可以在客户端无需手动生命周期管理即可轻松集成这些组件。</p><h4 id="实施自定义LifecycleOwner"><a href="#实施自定义LifecycleOwner" class="headerlink" title="实施自定义LifecycleOwner"></a>实施自定义LifecycleOwner</h4><p><strong>Support Library 26.1.0中的Fragment和Activity以及更高版本已经实现LifecycleOwner接口。</strong></p><p>如果您想要创建LifecycleOwner的自定义类，则可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleRegistry" target="_blank" rel="noopener">LifecycleRegistry</a>类，但需要将事件转发到该类中，如以下代码示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生命周期感知组件的最佳实践"><a href="#生命周期感知组件的最佳实践" class="headerlink" title="生命周期感知组件的最佳实践"></a>生命周期感知组件的最佳实践</h3><ul><li>尽可能保持您的UI控制器（Activities和Fragments）尽可能精简。他们不应该试图获取他们自己的数据;相反，使用<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>来做到这一点，并观察一个<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" target="_blank" rel="noopener">LiveData</a>对象来反映更改回视图。</li><li>尝试编写数据驱动UI的界面，其中您的UI控制器的职责是在数据更改时更新视图，或将用户操作通知给<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>。</li><li>把你的数据逻辑放在<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>类中。<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>应作为您的UI控制器和其他应用程序之间的连接器。但要小心，<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>不负责提取数据（例如，来自网络）。相反，<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>应调用相应的组件来获取数据，然后将结果提供给UI控制器。</li><li>使用<a href="https://developer.android.com/topic/libraries/data-binding/" target="_blank" rel="noopener">Data Binding</a>在视图和UI控制器之间保持干净的界面。这使您可以使您的视图更具说明性，并最大限度地减少需要在活动和片段中编写的更新代码。如果你喜欢用Java编程语言来做到这一点，可以使用像Butter Knife这样的库来避免样板代码并且有更好的抽象</li><li>如果您的UI很复杂，请考虑创建一个presenter类来处理UI修改。这可能是一项艰巨的任务，但它可以使您的UI组件更易于测试。</li><li>避免在<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>中引用View或Activity上下文。如果<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>超出活动（在配置更改的情况下），则活动会泄漏并且垃圾收集器无法正确处理。</li></ul><h3 id="支持生命周期感知组件的用例"><a href="#支持生命周期感知组件的用例" class="headerlink" title="支持生命周期感知组件的用例"></a>支持生命周期感知组件的用例</h3><p>支持生命周期的组件可以让您在各种情况下更容易地管理生命周期。<br>一些例子是：</p><ul><li>在粗粒度和细粒度 位置更新之间切换。使用生命周期感知组件在位置应用可见时启用细粒度位置更新，并在应用处于后台时切换到粗粒度更新。LiveData是一种生命周期感知型组件，允许您的应用在用户更改位置时自动更新用户界面。</li><li>停止并开始视频缓冲。尽可能使用支持生命周期的组件来启动视频缓冲，但延迟播放直到应用程序完全启动。您还可以使用生命周期感知组件在应用程序销毁时终止缓冲。</li><li>启动和停止网络连接。使用支持生命周期的组件可以在应用程序处于前台时实时更新（流式传输）网络数据，并在应用程序进入后台时自动暂停。</li><li>暂停和恢复动画可绘制。使用生命周期感知组件处理在应用程序处于后台时暂停动画的可绘制画面，并在应用程序处于前景时恢复可绘制画面。</li></ul><h3 id="处理停止事件"><a href="#处理停止事件" class="headerlink" title="处理停止事件"></a>处理停止事件</h3><p>当Lifecycle属于AppCompatActivity或Fragment时，Lifecycle的状态将更改为<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#CREATED" target="_blank" rel="noopener">CREATED</a>，并在调用AppCompatActivity或Fragment的onSaveInstanceState()时调度<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.Event#ON_STOP" target="_blank" rel="noopener">ON_STOP</a>事件。</p><p>当Fragment或AppCompatActivity的状态通过onSaveInstanceState（）保存时，UI被认为是不可变的，直到<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.Event#ON_START" target="_blank" rel="noopener">ON_START</a>被调用。尝试在保存状态后修改UI界面可能会导致应用程序的导航状态不一致，这就是为什么如果应用程序在状态保存后运行FragmentTransaction时FragmentManager会抛出异常。<br>有关详细信息，详情请参阅 <a href="https://developer.android.com/reference/android/support/v4/app/FragmentTransaction#commit%28%29" target="_blank" rel="noopener">commit()</a>。</p><p>如果观察者的关联Lifecycle在<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#STARTED" target="_blank" rel="noopener">STARTED</a>之前，则<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" target="_blank" rel="noopener">LiveData</a>通过避免调用其观察者来防止这种边缘情况出现。<br>在幕后，它决定调用观察者之前调用<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#isAtLeast%28android.arch.lifecycle.Lifecycle.State%29" target="_blank" rel="noopener">isAtLeast()</a>。</p><p>不幸的是，AppCompatActivity的onStop()方法会在onSaveInstanceState()之后调用，这会在不允许UI状态更改但生命周期尚未移至<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#CREATED" target="_blank" rel="noopener">CREATED</a>状态的情况下留下空隙。</p><p>为了防止出现这个问题，beta2版本中的Lifecycle类将lower状态标记为CREATED而不分派事件，即使事件直到<a href="https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html#onStop%28%29" target="_blank" rel="noopener">onStop()</a>被调用也未被分派，任何检查当前状态的代码也都会获得真实值。</p><p>不幸的是，这个解决方案有两个主要问题：</p><ul><li>在API等级23或更低的情况下，Android系统实际上保存活动的状态，即使它被另一活动部分覆盖。换句话说，Android系统调用onSaveInstanceState()，但不一定调用onStop()。这会创建一个潜在的长时间间隔，即使其UI状态无​​法修改，观察者仍认为生命周期处于活动状态。</li><li>任何想要向LiveData类公开类似行为的类都必须实现Lifecycle beta2和更低版本提供的解决方法</li></ul><p><strong>注意：为了使此流程更简单，并提供与旧版本的更好兼容性，从版本1.0.0-rc1开始，在调用onSaveInstanceState()而无需等待对onStop()的调用时，将Lifecycle对象标记为CREATED，并调度onStop()方法。这不太可能影响您的代码，但您需要注意这一点，因为它与API级别26及更低级别的Activity类中的调用顺序不匹配。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用生命周期感知组件处理生命周期&quot;&gt;&lt;a href=&quot;#使用生命周期感知组件处理生命周期&quot; class=&quot;headerlink&quot; title=&quot;使用生命周期感知组件处理生命周期&quot;&gt;&lt;/a&gt;使用生命周期感知组件处理生命周期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;支
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Dart语言之旅</title>
    <link href="http://yoursite.com/2018/06/26/dart/Dart%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2018/06/26/dart/Dart语言之旅/</id>
    <published>2018-06-26T05:15:01.000Z</published>
    <updated>2018-06-26T05:28:38.095Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本页向您展示了如何使用每个主要的Dart特性，从变量和运算符到类和库，假定您已经知道如何用另一种语言编程。要了解有关Dart核心库的更多信息，请参阅<a href="https://www.dartlang.org/guides/libraries/library-tour" target="_blank" rel="noopener">Dart  Library之旅</a>。无论何时您想了解有关语言功能的更多详细信息，请参阅<a href="https://www.dartlang.org/guides/language/spec" target="_blank" rel="noopener">Dart语言规范</a>。</p></blockquote><h2 id="Dart基础特性"><a href="#Dart基础特性" class="headerlink" title="Dart基础特性"></a>Dart基础特性</h2><h3 id="一个基本的dart程序"><a href="#一个基本的dart程序" class="headerlink" title="一个基本的dart程序"></a>一个基本的dart程序</h3><p> 以下代码使用了Dart最基本的许多功能:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数.</span></span><br><span class="line">printInteger(<span class="built_in">int</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'The number is $aNumber.'</span>); <span class="comment">// 打印到工作台</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是应用程序开始执行的地方.</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>; <span class="comment">// 声明并初始化一个变量</span></span><br><span class="line">  printInteger(number); <span class="comment">// 调用一个函数.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是适用于所有（或几乎所有）Dart应用程序的写法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 单行注释</span><br><span class="line"><span class="regexp">//</span>此外dart还支持多行注释和文档注释，详情见后面</span><br><span class="line"></span><br><span class="line">int  <span class="regexp">//i</span>nt类型，其他一些内置类型是String，List bool</span><br><span class="line"></span><br><span class="line"><span class="number">42</span> <span class="regexp">//</span>数字，数字是一种编译时常量</span><br><span class="line"></span><br><span class="line">print() <span class="regexp">//</span>一种很方便的打印方法</span><br><span class="line"></span><br><span class="line"><span class="string">'......'</span> o<span class="string">r"......"</span> <span class="regexp">//</span>这两种都是表示字符串</span><br><span class="line"></span><br><span class="line"><span class="variable">$variableName</span> (or <span class="variable">$&#123;expression&#125;</span>)</span><br><span class="line"><span class="regexp">//</span>字符串插值：在字符串文字中包含一个变量或表达式的字符串。有关更多信息，请参阅字符串。</span><br><span class="line">main()  <span class="regexp">//</span>一个应用程序执行开始的特殊的、必须的函数，详情查看main函数</span><br><span class="line">var <span class="regexp">//</span>声明变量但不指定类型</span><br></pre></td></tr></table></figure><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>当你了解Dart语言时，要牢记这些事实和概念：</p><ul><li>你可以放在变量中的所有东西都是一个对象，每个对象都是一个类的实例。即使是数字，功能， null也是对象。所有对象都从Object类继承。</li><li>虽然Dart是强类型的，但类型注释是可选的，因为Dart可以推断类型。在上面的代码中，number 被推断为是类型的int。当你想明确地说没有类型时， 使用特殊类型dynamic。</li><li>Dart支持泛型类型，如List<int>（整数列表）或List<dynamic>（任何类型的对象列表）。</dynamic></int></li><li>Dart支持顶层函数（如main()），以及与类或对象绑定的函数（分别为静态方法和实例方法）。你也可以在函数中创建函数（嵌套函数或局部函数）。</li><li>同样，Dart支持顶级变量以及绑定到类或对象（静态变量和实例变量）的变量。实例变量有时称为字段或属性。</li><li>与Java，dart不具备关键字public，protected和private。如果标识符以下划线（_）开头，则它的库是私有的。有关详细信息，请参阅 库和可见性。</li><li>标识符可以以字母或下划线（_）开头，然后是这些字符和数字的任意组合。</li><li>有时候，重要的是某件事是一种<strong>表达式</strong>还是一种 <strong>声明</strong>，所以这两个词的确切含义很有帮助。</li><li>Dart工具可以报告两种问题：warnings 和errors。警告只是表明您的代码可能无法正常工作，但它们不会阻止您的程序执行。错误可以是编译时或运行时。编译时错误导致代码无法执行; 运行时错误导致 代码执行时引发异常。</li></ul><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>下表列出了Dart语言特别处理的关键词。</p><table><thead><tr><th>abstract</th><th style="text-align:left">do</th><th>import</th><th>super</th></tr></thead><tbody><tr><td>abstract1</td><td style="text-align:left">do</td><td>import 1</td><td>super</td></tr><tr><td>as 1</td><td style="text-align:left">dynamic 1</td><td>in</td><td>switch</td></tr><tr><td>assert</td><td style="text-align:left">else</td><td>interface 1</td><td>sync* 2</td></tr><tr><td>async 2</td><td style="text-align:left">enum</td><td>is</td><td>this</td></tr><tr><td>async* 2</td><td style="text-align:left">export 1</td><td>library 1</td><td>throw</td></tr><tr><td>await 2</td><td style="text-align:left">external 1</td><td>mixin 1</td><td>true</td></tr><tr><td>break</td><td style="text-align:left">extends</td><td>new</td><td>try</td></tr><tr><td>case</td><td style="text-align:left">factory 1</td><td>null</td><td>typedef 1</td></tr><tr><td>catch</td><td style="text-align:left">false</td><td>operator 1</td><td>var</td></tr><tr><td>class</td><td style="text-align:left">final</td><td>part 1</td><td>void</td></tr><tr><td>const</td><td style="text-align:left">finally</td><td>rethrow</td><td>while</td></tr><tr><td>continue</td><td style="text-align:left">for</td><td>return</td><td>with</td></tr><tr><td>covariant 1</td><td style="text-align:left">get 1</td><td>set 1</td><td>yield 2</td></tr><tr><td>default</td><td style="text-align:left">if</td><td>static 1</td><td>yield* 2</td></tr><tr><td>deferred 1</td><td style="text-align:left">implements1</td><td></td></tr></tbody></table><p>1<strong>带上标1</strong>的单词是内置标识符。<br>避免使用内置标识符作为标识符。<br>如果您尝试为类或类型名称使用内置标识符，则会发生编译时错误。<br>2<strong>带上标2</strong>的单词是较新的，与Dart 1.0版本发布后添加的异步支持相关的有限保留字。<br>您不能使用async，await或yield作为用async，async <em>或sync </em>标记的任何函数体中的标识符。<br>有关更多信息，请参见<a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">异步支持</a></p><p><strong>关键字表中的所有其他字都是保留字。</strong><br>您不能使用保留字作为标识符**</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>以下是创建变量并初始化变量的示例：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> =<span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>变量存储的是引用，命名为name的变量存储的是 值为”Bob”的字符创的一个引用<br>name变量的类型被推断为String，但您可以通过指定它来更改该类型。<br>如果对象不限于单一类型，请遵循<a href="https://www.dartlang.org/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed" target="_blank" rel="noopener">设计指南</a>指定对象或动态类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">name</span> =<span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>另一种选择是显式声明将被推断的类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="keyword">name</span> = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>未初始化的变量的初始值为<strong>null</strong>。即使数字类型的变量最初为<strong>null</strong>，因为数字 - 和Dart中的其他所有数据一样 - <strong>都是对象</strong>。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lineCount;</span><br><span class="line"><span class="keyword">assert</span>(lineCount == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：assert()产品代码中 的调用被忽略。在开发过程中， 除非条件为真，否则会引发异常。有关详细信息，请参阅Assert。assert(condition)</strong></p></blockquote><h3 id="Final和const"><a href="#Final和const" class="headerlink" title="Final和const"></a>Final和const</h3><p>如果你从不打算改变一个变量，使用final或者const，而不是var或者其他类型。最终的变量只能设置一次; 一个const变量是一个编译时常量。（Const变量<strong>隐式final</strong> 。）final的顶层或者class变量在它第一次被使用时被初始化。</p><blockquote><p><strong>注意： 实例变量可以final但不是const。</strong></p></blockquote><p> 以下是创建和设置最终变量的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>; <span class="comment">// 没有类型声明</span></span><br><span class="line"><span class="comment">// name = 'Alice';  // 取消注释会导致UC哦呜</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">'Bobby'</span>;</span><br></pre></td></tr></table></figure><p>将const用于想要成为编译时常量的变量。<br>如果const变量处于类级别，则将其标记为静态常量。<br>在声明该变量的位置，将该值设置为编译时常量，例如数字或字符串文字，常量变量或常数上算术运算的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="number">1000000</span>; <span class="comment">// 压力单位(dynes/cm2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> atm = <span class="number">1.01325</span> * bar; <span class="comment">// 标准大气压</span></span><br></pre></td></tr></table></figure><p>该const关键字不只是声明常数变量。您也可以使用它来创建常量值，以及声明创建常量值的构造函数。任何变量都可以有一个常量值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">Note:</span> [] 创建一个空的list</span></span><br><span class="line"><span class="comment">// const [] 创建一个空的， 一成不变的list (简写为EIL).</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> []; <span class="comment">// foo 当前是一个 EIL(empty immutabe list).</span></span><br><span class="line"><span class="keyword">final</span> bar = <span class="keyword">const</span> []; <span class="comment">// bar 将永远是 EIL.</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="keyword">const</span> []; <span class="comment">// baz 是一个编译时常量 EIL.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can change the value of a non-final, non-const variable,</span></span><br><span class="line"><span class="comment">// even if it used to have a const value.</span></span><br><span class="line">foo = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can't change the value of a final or const variable.</span></span><br><span class="line"><span class="comment">// bar = []; // Unhandled exception.</span></span><br><span class="line"><span class="comment">// baz = []; // Unhandled exception.</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本页向您展示了如何使用每个主要的Dart特性，从变量和运算符到类和库，假定您已经知道如何用另一种语言编程。要了解有关Dart核心库的更多信息，请参阅&lt;a href=&quot;https://www.dartlang.org/guides/libraries
      
    
    </summary>
    
      <category term="Dart学习" scheme="http://yoursite.com/categories/Dart%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Dart学习" scheme="http://yoursite.com/tags/Dart%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android权限列表</title>
    <link href="http://yoursite.com/2018/06/22/android/Android%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/22/android/Android权限列表/</id>
    <published>2018-06-22T05:16:32.000Z</published>
    <updated>2018-10-05T15:37:53.250Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.csdn.net/ufo00001/article/details/69397256" target="_blank" rel="noopener">http://blog.csdn.net/ufo00001/article/details/69397256</a></p><table><thead><tr><th>1.android.permission.WRITE_USER_DICTIONARY</th><th>允许应用程序向用户词典中写入新词 </th></tr></thead><tbody><tr><td>2.android.permission.WRITE_SYNC_SETTINGS</td><td>写入Google在线同步设置 </td></tr><tr><td>3.android.permission.WRITE_SOCIAL_STREAM</td><td>读取用户的社交信息流 </td></tr><tr><td>4.android.permission.WRITE_SMS</td><td>允许程序写短信 </td></tr><tr><td>5.android.permission.WRITE_SETTINGS</td><td>允许程序读取或写入系统设置 </td></tr><tr><td>6.android.permission.WRITE_SECURE_SETTINGS</td><td>允许应用程序读取或写入安全系统设置 </td></tr><tr><td>7.android.permission.WRITE_PROFILE</td><td>允许程序写入个人资料数据 </td></tr><tr><td>8.com.android.browser.permission.WRITE_HISTORY_BOOKMARKS</td><td>允许一个应用程序写（但不可读）用户的浏览历史和书签 </td></tr><tr><td>9.android.permission.WRITE_GSERVICES</td><td>允许程序修改Google服务地图 </td></tr><tr><td>10.android.permission.WRITE_EXTERNAL_STORAGE</td><td>允许程序写入外部存储，如SD卡上写文件 </td></tr><tr><td>11.android.permission.WRITE_CONTACTS</td><td>写入联系人，但不可读取 </td></tr><tr><td>12.android.permission.WRITE_CALL_LOG</td><td>允许程序写入（但是不能读）用户的联系人数据 </td></tr><tr><td>13.android.permission.WRITE_CALENDAR</td><td>允许程序写入日程，但不可读取 </td></tr><tr><td>14.android.permission.WRITE_APN_SETTINGS</td><td>允许程序写入网络GPRS接入点设置 </td></tr><tr><td>15.android.permission.WAKE_LOCK</td><td>允许程序在手机屏幕关闭后后台进程仍然运行 </td></tr><tr><td>16.android.permission.VIBRATE</td><td>允许程序振动 </td></tr><tr><td>17.android.permission.USE_SIP</td><td>允许程序使用SIP视频服务 </td></tr><tr><td>18.android.permission.USE_CREDENTIALS</td><td>允许程序请求验证从AccountManager </td></tr><tr><td>19.android.permission.UPDATE_DEVICE_STATS</td><td>允许程序更新设备状态 </td></tr><tr><td>20.com.android.launcher.permission.UNINSTALL_SHORTCUT</td><td>删除快捷方式 </td></tr><tr><td>21.android.permission.TRANSMIT_IR</td><td>允许使用设备的红外发射器，如果可用 </td></tr><tr><td>22.android.permission.SYSTEM_ALERT_WINDOW</td><td>允许程序显示系统窗口 </td></tr><tr><td>23.android.permission.SUBSCRIBED_FEEDS_WRITE</td><td>允许程序写入或修改订阅内容的数据库 </td></tr><tr><td>24.android.permission.SUBSCRIBED_FEEDS_READ</td><td>允许程序访问订阅信息的数据库 </td></tr><tr><td>22.android.permission.STATUS_BAR</td><td>允许程序打开、关闭、禁用状态栏 </td></tr><tr><td>23.android.permission.SIGNAL_PERSISTENT_PROCESSES</td><td>允许程序发送一个永久的进程信号 </td></tr><tr><td>24.android.permission.SET_WALLPAPER_HINTS</td><td>允许程序设置壁纸建议 </td></tr><tr><td>25.android.permission.SET_WALLPAPER</td><td>允许程序设置桌面壁纸 </td></tr><tr><td>26.android.permission.SET_TIME_ZONE</td><td>允许程序设置系统时区 </td></tr><tr><td>27.android.permission.SET_TIME</td><td>允许程序设置系统时间 </td></tr><tr><td>28.android.permission.SET_PROCESS_LIMIT</td><td>允许程序设置最大的进程数量的限制 </td></tr><tr><td>29.android.permission.SET_PREFERRED_APPLICATIONS</td><td>允许程序设置应用的参数，<br>已不再工作具体查看addPackageToPreferred（String） 介绍 </td></tr><tr><td>30.android.permission.SET_POINTER_SPEED</td><td>无法被第三方应用获得，系统权限 </td></tr><tr><td>31.android.permission.SET_ORIENTATION</td><td>允许程序设置屏幕方向为横屏或标准方式显示，不用于普通应用 </td></tr><tr><td>32.android.permission.SET_DEBUG_APP</td><td>允许程序设置调试程序，一般用于开发 </td></tr><tr><td>33.android.permission.SET_ANIMATION_SCALE</td><td>允许程序设置全局动画缩放 </td></tr><tr><td>34.android.permission.SET_ALWAYS_FINISH</td><td>允许程序设置程序在后台是否总是退出 </td></tr><tr><td>36.com.android.alarm.permission.SET_ALARM</td><td>允许程序设置闹铃提醒 </td></tr><tr><td>37.android.permission.SET_ACTIVITY_WATCHER</td><td>允许程序设置Activity观察器<br>一般用于monkey测试 </td></tr><tr><td>38.android.permission.SEND_SMS</td><td>允许程序发送短信 </td></tr><tr><td>39.android.permission.SEND_RESPOND_VIA_MESSAGE</td><td>允许用户在来电的时候用你的应用进行即时的短信息回复。 </td></tr><tr><td>40.android.permission.RESTART_PACKAGES</td><td>允许程序结束任务通过<br>restartPackage（String）方法，该方式将在外来放弃</td></tr><tr><td>41.android.permission.REORDER_TASKS</td><td>允许程序重新排序系统Z轴运行中的任务 </td></tr><tr><td>42.android.permission.RECORD_AUDIO</td><td>允许程序录制声音通过手机或耳机的麦克 </td></tr><tr><td>43.android.permission.RECEIVE_WAP_PUSH</td><td>允许程序接收WAP PUSH信息 </td></tr><tr><td>44.android.permission.RECEIVE_SMS</td><td>允许程序接收短信 </td></tr><tr><td>45.android.permission.RECEIVE_MMS</td><td>允许程序接收彩信 </td></tr><tr><td>46.android.permission.RECEIVE_BOOT_COMPLETED</td><td>允许程序开机自动运行 </td></tr><tr><td>47.android.permission.REBOOT</td><td>允许程序重新启动设备 </td></tr><tr><td>48.android.permission.READ_USER_DICTIONARY</td><td>从一个提供器中获取数据，针对对应的提供器，应用程序需要“读访问权限” </td></tr><tr><td>49.android.permission.READ_SYNC_STATS</td><td>允许程序读取同步状态，获得Google在线同步状态 </td></tr><tr><td>50.android.permission.READ_SYNC_SETTINGS</td><td>允许程序读取同步设置，读取Google在线同步设置 </td></tr><tr><td>51.android.permission.READ_SOCIAL_STREAM</td><td>读取用户的社交信息流 </td></tr><tr><td>52.android.permission.READ_SMS</td><td>允许程序读取短信内容 </td></tr><tr><td>53.android.permission.READ_PROFILE</td><td>访问用户个人资料 </td></tr><tr><td>54.android.permission.READ_PHONE_STATE</td><td>允许程序访问电话状态 </td></tr><tr><td>55.android.permission.READ_LOGS</td><td>允许程序读取系统底层日志 </td></tr><tr><td>56.android.permission.READ_INPUT_STATE</td><td>允许程序读取当前键的输入状态，仅用于系统 </td></tr><tr><td>57.com.android.browser.permission.READ_HISTORY_BOOKMARKS</td><td>允许程序读取浏览器收藏夹和历史记录 </td></tr><tr><td>58.android.permission.READ_FRAME_BUFFER</td><td>允许程序读取帧缓存用于屏幕截图 </td></tr><tr><td>59.android.permission.READ_EXTERNAL_STORAGE</td><td>程序可以读取设备外部存储空间（内置SDcard和外置SDCard）的文件，如果您的App已经添加<br>了“WRITE_EXTERNAL_STORAGE ”权限 ，则就没必要添加读的权限了，写权限已经包含了读权限了。 </td></tr><tr><td>60.android.permission.READ_CONTACTS</td><td>允许程序访问联系人通讯录信息 </td></tr><tr><td>61.android.permission.READ_CALL_LOG</td><td>读取通话记录 </td></tr><tr><td>62.android.permission.READ_CALENDAR</td><td>允许程序读取用户的日程信息 </td></tr><tr><td>63.android.permission.PROCESS_OUTGOING_CALLS</td><td>允许程序监视，修改或放弃播出电话 </td></tr><tr><td>64.android.permission.PERSISTENT_ACTIVITY</td><td>允许程序创建一个永久的Activity，该功能标记为将来将被移除 </td></tr><tr><td>65.android.permission.NFC</td><td>允许程序执行NFC近距离通讯操作，用于移动支持 </td></tr><tr><td>66.android.permission.MOUNT_UNMOUNT_FILESYSTEMS</td><td>允许程序挂载、反挂载外部文件系统 </td></tr><tr><td>67.android.permission.MOUNT_FORMAT_FILESYSTEMS</td><td>允许程序格式化可移动文件系统，比如格式化清空SD卡 </td></tr><tr><td>68.android.permission.MODIFY_PHONE_STATE</td><td>允许程序修改电话状态，如飞行模式，但不包含替换系统拨号器界面 </td></tr><tr><td>69.android.permission.MODIFY_AUDIO_SETTINGS</td><td>允许程序修改声音设置信息 </td></tr><tr><td>70.android.permission.MEDIA_CONTENT_CONTROL</td><td>允许一个应用程序知道什么是播放和控制其内容。不被第三方应用使用。 </td></tr><tr><td>71.android.permission.MASTER_CLEAR</td><td>允许程序执行软格式化，删除系统配置信息 </td></tr><tr><td>72.android.permission.MANAGE_DOCUMENTS</td><td>允许一个应用程序来管理文档的访问，通常是一个文档选择器部分 </td></tr><tr><td>73.android.permission.MANAGE_APP_TOKENS</td><td>管理创建、摧毁、Z轴顺序，仅用于系统 </td></tr><tr><td>74.android.permission.MANAGE_ACCOUNTS</td><td>允许程序管理AccountManager中的账户列表 </td></tr><tr><td>75.android.permission.LOCATION_HARDWARE</td><td>允许一个应用程序中使用定位功能的硬件，不使用第三方应用 </td></tr><tr><td>76.android.permission.KILL_BACKGROUND_PROCESSES</td><td>允许程序调用killBackgroundProcesses（String）。方法结束后台进程 </td></tr><tr><td>77.android.permission.INTERNET</td><td>允许程序访问网络连接，可能产生GPRS流量 </td></tr><tr><td>78.android.permission.INTERNAL_SYSTEM_WINDOW</td><td>允许程序打开内部窗口，不对第三方应用程序开放此权限 </td></tr><tr><td>79.com.android.launcher.permission.INSTALL_SHORTCUT</td><td>创建快捷方式 </td></tr><tr><td>80.android.permission.INSTALL_PACKAGES</td><td></td></tr><tr><td>81.android.permission.INSTALL_LOCATION_PROVIDER</td><td>允许程序安装定位提供 </td></tr><tr><td>82.android.permission.INJECT_EVENTS</td><td>允许程序访问本程序的底层事件，获取按键、轨迹球的事件流 </td></tr><tr><td>83.android.permission.HARDWARE_TEST</td><td>允许程序访问硬件辅助设备，用于硬件测试 </td></tr><tr><td>84.android.permission.GLOBAL_SEARCH</td><td>允许程序允许全局搜索 </td></tr><tr><td>85.android.permission.GET_TOP_ACTIVITY_INFO</td><td>允许一个应用程序检索私有信息是当前最顶级的活动，不被第三方应用使用 </td></tr><tr><td>86.android.permission.GET_TASKS</td><td>允许程序获取任务信息 </td></tr><tr><td>87.android.permission.GET_PACKAGE_SIZE</td><td>允许程序获取应用的文件大小 </td></tr><tr><td>88.android.permission.GET_ACCOUNTS</td><td>允许程序访问账户Gmail列表 </td></tr><tr><td>89.android.permission.FORCE_BACK</td><td>允许程序强制使用back后退按键，无论Activity是否在顶层 </td></tr><tr><td>90.android.permission.FLASHLIGHT</td><td>允许访问闪光灯 </td></tr><tr><td>91.android.permission.FACTORY_TEST</td><td>允许程序运行工厂测试模式 </td></tr><tr><td>92.android.permission.EXPAND_STATUS_BAR</td><td>允许程序扩展或收缩状态栏 </td></tr><tr><td>93.android.permission.DUMP</td><td>允许程序获取系统dump信息从系统服务 </td></tr><tr><td>94.android.permission.DISABLE_KEYGUARD</td><td>允许程序禁用键盘锁 </td></tr><tr><td>95.android.permission.DIAGNOSTIC</td><td>允许程序到RW到诊断资源 </td></tr><tr><td>96.android.permission.DEVICE_POWER</td><td>允许程序访问底层电源管理 </td></tr><tr><td>97.android.permission.DELETE_PACKAGES</td><td>允许程序删除应用 </td></tr><tr><td>98.android.permission.DELETE_CACHE_FILES</td><td>允许程序删除缓存文件 </td></tr><tr><td>99.android.permission.CONTROL_LOCATION_UPDATES</td><td>允许程序获得移动网络定位信息改变 </td></tr><tr><td>100.android.permission.CLEAR_APP_USER_DATA</td><td>允许程序清除用户数据 </td></tr><tr><td>101.android.permission.CLEAR_APP_CACHE</td><td>允许程序清除应用缓存 </td></tr><tr><td>102.android.permission.CHANGE_WIFI_STATE</td><td>允许程序改变WiFi状态 </td></tr><tr><td>103.android.permission.CHANGE_WIFI_MULTICAST_STATE</td><td>允许程序改变WiFi多播状态 </td></tr><tr><td>104.android.permission.CHANGE_NETWORK_STATE</td><td>允许程序改变网络状态，如是否联网 </td></tr><tr><td>105.android.permission.CHANGE_CONFIGURATION</td><td>允许当前应用改变配置，如定位 </td></tr><tr><td>106.android.permission.CHANGE_COMPONENT_ENABLED_STATE</td><td>改变组件是否启用状态 </td></tr><tr><td>107.android.permission.CAPTURE_VIDEO_OUTPUT</td><td>允许一个应用程序捕获视频输出，不被第三方应用使用 </td></tr><tr><td>108.android.permission.CAPTURE_SECURE_VIDEO_OUTPUT</td><td>允许一个应用程序捕获视频输出。不被第三方应用使用 </td></tr><tr><td>109.android.permission.CAPTURE_AUDIO_OUTPUT</td><td>允许一个应用程序捕获音频输出。不被第三方应用使用 </td></tr><tr><td>110.android.permission.CAMERA</td><td>允许程序访问摄像头进行拍照 </td></tr><tr><td>111.android.permission.CALL_PRIVILEGED</td><td>允许程序拨打电话，替换系统的拨号器界面 </td></tr><tr><td>112.android.permission.CALL_PHONE</td><td>允许程序从非系统拨号器里拨打电话 </td></tr><tr><td>113.android.permission.BROADCAST_WAP_PUSH</td><td>WAP PUSH服务收到后触发一个广播 </td></tr><tr><td>114.android.permission.BROADCAST_STICKY</td><td>允许程序收到广播后快速收到下一个广播 </td></tr><tr><td>115.android.permission.BROADCAST_SMS</td><td>允许程序当收到短信时触发一个广播 </td></tr><tr><td>116.android.permission.BROADCAST_PACKAGE_REMOVED</td><td>允许程序删除时广播 </td></tr><tr><td>117.android.permission.BRICK</td><td>能够禁用手机，非常危险，顾名思义就是让手机变成砖头 </td></tr><tr><td>118.android.permission.BLUETOOTH_PRIVILEGED</td><td>允许应用程序配对蓝牙设备，而无需用户交互。这不是第三方应用程序可用。 </td></tr><tr><td>119.android.permission.BLUETOOTH_ADMIN</td><td>允许程序进行发现和配对新的蓝牙设备 </td></tr><tr><td>120.android.permission.BLUETOOTH</td><td>允许程序连接配对过的蓝牙设备 </td></tr><tr><td>121.android.permission.BIND_WALLPAPER</td><td>必须通过WallpaperService服务来请求，只有系统才能用 </td></tr><tr><td>122.android.permission.BIND_VPN_SERVICE</td><td>绑定VPN服务必须通过VpnService服务来请求，只有系统才能用 </td></tr><tr><td>123.android.permission.BIND_TEXT_SERVICE</td><td>必须要求textservice（例如吗 spellcheckerservice），以确保只有系统可以绑定到它。 </td></tr><tr><td>124.android.permission.BIND_REMOTEVIEWS</td><td>必须通过RemoteViewsService服务来请求，只有系统才能用 </td></tr><tr><td>125.android.permission.BIND_PRINT_SERVICE</td><td>必须要求由printservice，以确保只有系统可以绑定到它。 </td></tr><tr><td>126.android.permission.BIND_NOTIFICATION_LISTENER_SERVICE</td><td>必须要求由notificationlistenerservice，以确保只有系统可以绑定到它。 </td></tr><tr><td>127.android.permission.BIND_NFC_SERVICE</td><td>由hostapduservice或offhostapduservice必须确保只有系统可以绑定到它。 </td></tr><tr><td>128.android.permission.BIND_INPUT_METHOD</td><td>请求InputMethodService服务，只有系统才能使用 </td></tr><tr><td>129.android.permission.BIND_DEVICE_ADMIN</td><td>请求系统管理员接收者receiver，只有系统才能使用 </td></tr><tr><td>130.android.permission.BIND_APPWIDGET</td><td>允许程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 </td></tr><tr><td>131.android.permission.BIND_ACCESSIBILITY_SERVICE</td><td>请求accessibilityservice服务，以确保只有系统可以绑定到它。 </td></tr><tr><td>132.android.permission.AUTHENTICATE_ACCOUNTS</td><td>允许程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 </td></tr><tr><td>133.com.android.voicemail.permission.ADD_VOICEMAIL</td><td>允许一个应用程序添加语音邮件系统 </td></tr><tr><td>134.android.permission.ACCOUNT_MANAGER</td><td>允许程序获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 </td></tr><tr><td>135.android.permission.ACCESS_WIFI_STATE</td><td>允许程序获取当前WiFi接入的状态以及WLAN热点的信息 </td></tr><tr><td>136.android.permission.ACCESS_SURFACE_FLINGER</td><td>Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 </td></tr><tr><td>137.android.permission.ACCESS_NETWORK_STATE</td><td>允许程序获取网络信息状态，如当前的网络连接是否有效 </td></tr><tr><td>138.android.permission.ACCESS_MOCK_LOCATION</td><td>允许程序获取模拟定位信息，一般用于帮助开发者调试应用 </td></tr><tr><td>139.android.permission.ACCESS_LOCATION_EXTRA_COMMANDS</td><td>允许程序访问额外的定位提供者指令 </td></tr><tr><td>140.android.permission.ACCESS_FINE_LOCATION</td><td>允许程序通过GPS芯片接收卫星的定位信息 </td></tr><tr><td>141.android.permission.ACCESS_COARSE_LOCATION</td><td>允许程序通过WiFi或移动基站的方式获取用户错略的经纬度信息 </td></tr><tr><td>142.android.permission.ACCESS_CHECKIN_PROPERTIES</td><td>允许程序读取或写入登记check-in数据库属性表的权限</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;http://blog.csdn.net/ufo00001/article/details/69397256&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/ufo00001/articl
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android运行时权限总结</title>
    <link href="http://yoursite.com/2018/06/22/android/Android%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/22/android/Android运行时权限总结/</id>
    <published>2018-06-22T02:50:27.000Z</published>
    <updated>2018-10-05T15:38:15.109Z</updated>
    
    <content type="html"><![CDATA[<p>###1、android6.0以后的危险权限介绍<br>（注意：Android O  8.0对于权限更加严格，下面会说一下8.0）<br>android6.0以后有些危险权限需要手动去授权，就有了运行时权限的处理。下面的表格就是危险权限组：</p><table><thead><tr><th>权限组名</th><th>权限名</th></tr></thead><tbody><tr><td>CALENDAR  日历</td><td>READ_CALENDAR<br>WRITE_CALENDER</td></tr><tr><td>CAMERA      相机</td><td>CAMERA</td></tr><tr><td>CONTACTS 联系人</td><td>READ_CONTACTS<br>WRITE_CONTACTS<br>GET_ACCOUNTS</td></tr><tr><td>LOCATION  定位</td><td>ACCESS_FINE_LOCATION<br>ACCESS_COARSE_LOCATION</td></tr><tr><td>MICROPHONE 麦克风</td><td>RECORD_AUDIO</td></tr><tr><td>PHONE 电话</td><td>READ_PHONE_STATE<br>CALL_PHONE<br>READ_CALL_LOG<br>WRITE_CALL_LOG<br>ADD_VOICEMAIL<br>USE_SIP<br>PROCESS_OUTGOING_CALLS</td></tr><tr><td>SENSORS 传感器</td><td>BODY_SENSORS</td></tr><tr><td>SMS  短信</td><td>Short Message Service<br>SEND_SMS<br>RECEIVE_SMS<br>READ_SMS<br>RECEIVE_WAP_PUSH<br>RECEIVE_MMS</td></tr><tr><td>STORAGE 数据存储</td><td>READ_EXTRAL_STRORAGE<br>WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><p>申请权限时：<br>1、在清单文件中声明权限（如果不在这张表中，声明完就可以了）<br>2、如果在这张表中的权限需要手动来申请</p><p>这些权限6.0以后需要手动申请，，每一个权限组中的权限只要有一个权限同意授权了，整个权限组中的权限就不用重复申请了。<br><strong>如果如果查看所有的权限，请参考：<a href="https://segmentfault.com/a/1190000012259370" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012259370</a></strong></p><p>###2、运行时权限申请过程：<br>传统的申请过程是：<br>1、在AndroidManifest文件中添加需要的权限。<br>2、检查权限是否授权<br>3、申请权限<br>4、处理授权的结果</p><p>一步步来：<br><strong>1、首先在请单文件中声明，这个不用说</strong><br><strong>2、检查权限是否授权</strong></p><pre><code>if (ContextCompat.checkSelfPermission(thisActivity,            Manifest.permission.READ_CONTACTS)    != PackageManager.PERMISSION_GRANTED) {    //没有授权，编写申请权限代码}else{//已经授权，执行操作代码}    </code></pre><p>   基本上调用checkSelfPermission()函数传入权限参数，返回的结果又两个：<br>如果是已授权的权限，该方法返回结果是 PackageManager.PERMISSION_GRANTED 常量为 0，<br>如果是未授权的权限，该方法返回结果是 PackageManager.PERMISSION_DENIED 常量为 -1。<br>这样就可以判断是否已经授权，来进行下一步的操作。</p><p><strong>3、如果没有授权，需要申请权限</strong><br>​    ActivityCompat.requestPermissions(thisActivity,<br>​                new String[]{Manifest.permission.READ_CONTACTS},<br>​                MY_PERMISSIONS_REQUEST_READ_CONTACTS);<br>  这是一个异步的方法，第一个参数是Context；第二个参数是需要申请的权限的字符串数组（这个是支持同时申请多个权限，系统会逐个询问是否授权）；第三个参数为请求码requestCode，主要用于回调的时候检测。<br>​<br><strong>4、处理权限申请的回调结果</strong><br>重写Activity或者fragment的 onRequestPermissionsResul()方法<br>​      //权限回调方法<br>​    @Override<br>​    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>​        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</p><pre><code>    switch (requestCode){        case 0:            //grantResults数组存储的申请的返回结果，            //PERMISSION_GRANTED 表示申请成功            if (grantResults.length&gt;0&amp;&amp;grantResults[0]== PackageManager.PERMISSION_GRANTED){                //授权成功，                //这里写相应的 操作代码            }else{                //授权失败，可以简单提示用户                Toast.makeText(this, &quot;没有授权继续操作&quot;, Toast.LENGTH_SHORT).show();            }            break;        case 1:            //同上            break;        default:            break;    }}这里稍微说一下，申请的时候是一个一个的申请的话，每次申请都有一个请求码，这里的grantResults数组就只有一个值，所以都是grantResults[0]来和PERMISSION_GRANTED来进行比较如果是一次申请多个权限，grantResults数组返回的值就不止一个，但是，直接遍历它就行，只要全部满足条件才算申请成功，才能进行相应的操作一般的写法是：通过if判断权限是否申请，没有申请，把它加到一个集合里面，把所有的权限都判断一遍以后，去遍历这个集合，只要有一个没有申请的，就需、要去申请权限，    把这个集合转为数组，传到requestPermissions的第二个参数，然后就处理相应 结果就可以了，遍历grantResults数组，判断是不是全部满足条件</code></pre><p>​     </p><p>###3、EasyPermissions的使用<br>GitHub地址：<a href="https://github.com/googlesamples/easypermissions" target="_blank" rel="noopener">https://github.com/googlesamples/easypermissions</a><br>   EasyPermissions是谷歌封装的一个运行时权限申请的库，简化了操作的过程。<br>使用过程： 没有什么先后顺序，下面没有按这个顺序。这么做是可以的，当然还有其他的使用方法</p><blockquote><p>1、builde gradle中依赖<br>2、清单文件中声明权限<br>3、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions来<br>4、通过hasPermissions检查权限，或者原生的也行，然后去申请权限<br>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法，成功或失败<br>6、在成功或者失败方法中编写要具体做的事。</p></blockquote><p>GitHub地址：<br><strong>(1)依赖库</strong><br>​    dependencies {<br>​        compile ‘pub.devrel:easypermissions:1.0.1’<br>​    }<br>​<br><strong>(2)再在清单文件中声明要申请的危险权限</strong><br>如果不声明的话，直接在代码中写也能申请成功，但是好想不会弹出询问框，直接就申请了</p><p><strong>(3)申请权限</strong><br>可以直接申请<br>​    EasyPermissions.requestPermissions(<br>​                        MainActivity.this,<br>​                        “申请权限”,<br>​                        0,<br>​                        Manifest.permission.WRITE_EXTERNAL_STORAGE,<br>​                        Manifest.permission.RECORD_AUDIO);<br>最好还是检查一下权限是否申请：<br><strong>EasyPermissions.hasPermissions(Context context, @NonNull String… perms)</strong>方法来检测一个或者多个权限是否被允许，第二个参数是个可变数组，可以申请多个<br>​    String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};<br>​    if (EasyPermissions.hasPermissions(this, perms)) {<br>​<br>        // 已经申请过权限，做想做的事<br>    } else {<br>        // 没有申请过权限，现在去申请<br>        EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),<br>                RC_CAMERA_AND_LOCATION, perms);<br>    }</p><p>下面来说一个申请权限这个方法：<br>EasyPermissions.requestPermissions():<img src="/img/bVZBii" alt="图片描述"></p><p>requestPermissions() 一般用这个四个参数的就可以<br>第一个参数：Context对象<br>第二个参数：权限弹窗上的文字提示语。告诉用户，这个权限用途。<br>第三个参数：这次请求权限的唯一标识请求码，code。<br>第四个参数 : 一些系列的权限。<br>   这里说一下第二个参数，不是第一次申请系统默认弹出的提示语，而是，我们拒绝后，再次点击申请弹出的对话框，，显示我们设置的提示语，下面有两个按钮，确认和取消，我就不贴图了。</p><p>还有六个参数的，多了两个参数就是，修改我们上面那个确认和取消的字样，你可以干成yes 和no.<br>​<br><strong>4、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions    </strong><br>一行代码就搞定了<br>​     @Override<br>​    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>​        super.onRequestPermissionsResult(requestCode, permissions, grantResults);<br>​        EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);<br>​    }</p><p><strong>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法</strong><br>​    public class MainActivity extends AppCompatActivity implements EasyPermissions.PermissionCallbacks {</p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);}@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {    super.onRequestPermissionsResult(requestCode, permissions, grantResults);    // 把执行结果的操作给EasyPermissions    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);}@Override //申请成功时调用public void onPermissionsGranted(int requestCode, List&lt;String&gt; list) {    //请求成功执行相应的操作    比如，举个例子    switch (requestCode){        case 0:            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();            break;        case 1:            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();            break;    }}@Override //申请失败时调用public void onPermissionsDenied(int requestCode, List&lt;String&gt; list) {    // 请求失败，执行相应操作}}</code></pre><p>接下来就要说一下成功或者失败后的操作了： 申请成功就直接做该做的事就行了，没啥。<br>申请如果失败了，这时候有个方法出现了EasyPermissions.somePermissionPermanentlyDenied(this, perms)<br>这个方法是谷歌建议的。就是在我们点了不在询问并拒绝，会弹出对话框，告诉用户这个权限时干嘛的，很重要，建议不要拒绝哈哈<br>比如这样：  </p><pre><code>@Overridepublic void onPermissionsDenied(int requestCode, List&lt;String&gt; perms) {if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {    new AppSettingsDialog.Builder(this).build().show();    //弹出个对话框}</code></pre><p>}                 </p><p>当然我们可以定制一下这个对话框：<br>​    @Override<br>​    public void onPermissionsDenied(int requestCode, List<string> perms) {<br>​        //处理权限名字字符串<br>​        StringBuffer sb = new StringBuffer();<br>​        for (String str : perms){<br>​            sb.append(str);<br>​            sb.append(“\n”);<br>​        }<br>​        sb.replace(sb.length() - 2,sb.length(),””);</string></p><pre><code>    switch (requestCode){        case 0:            Toast.makeText(this, &quot;已拒绝权限&quot; + perms.get(0), Toast.LENGTH_SHORT).show();            break;        case 1:            Toast.makeText(this, &quot;已拒绝WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;+ perms.get(0), Toast.LENGTH_SHORT).show();            break;    }    if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {        Toast.makeText(this, &quot;已拒绝权限&quot; + sb + &quot;并不再询问&quot; , Toast.LENGTH_SHORT).show();        new AppSettingsDialog                .Builder(this)                .setRationale(&quot;此功能需要&quot; + sb + &quot;权限，否则无法正常使用，是否打开设置&quot;)                .setPositiveButton(&quot;是&quot;)                .setNegativeButton(&quot;否&quot;)                .build()                .show();    }}</code></pre><p><strong>6、(可选)@AfterPermissionGranted()注解</strong></p><p>使用 AfterPermissioonGranted 注解。这是可选的，但是提供出来是为了方便。如果所有的请求的权限都被授予了，被注解的方法将会被执行，这样做是为了简化通常的请求权限成功之后再调用方法的流程。同时也可以在onPermissionsGranted 的回调中添加逻辑操作：<br>比如官网上的这个实例代码：<br>这里的方法名可以自己取，主要是权限都申请完，就调用这个方法，执行里面的操作。<br>其实就相当于在onPermissionsGranted()调用这个方法而已:</p><pre><code>@AfterPermissionGranted(RC_CAMERA_AND_LOCATION)private void methodRequiresTwoPermission() {String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};if (EasyPermissions.hasPermissions(this, perms)) {    // Already have permission, do the thing    // ...} else {    // Do not have permissions, request them now    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),            RC_CAMERA_AND_LOCATION, perms);}}</code></pre><p>基本上介绍完了</p><p>###4、android 8.0运行时权限<br>对于针对Android O的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p><p>例如，假设某个应用在其清单中列出READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE。应用请求READ_EXTERNAL_STORAGE，并且用户授予了该权限，如果该应用针对的是API级别24或更低级别，系统还会同时授予WRITE_EXTERNAL_STORAGE，因为该权限也属于STORAGE权限组并且也在清单中注册过。如果该应用针对的是Android O，则系统此时仅会授予READ_EXTERNAL_STORAGE，不过在该应用以后申请WRITE_EXTERNAL_STORAGE权限时，系统会立即授予该权限，而不会提示用户。<br><strong>注意：如果使用了没有授权的权限，会崩溃的</strong></p><p>所以对于8.0权限，我们要做的处理，是尽量把所用到的危险权限全部申请。但是有的权限在不同版本出现，所以要兼容不同的版本，所以要加一个版本的判断。</p><blockquote><p>归根结底：android M (6.0)以后，申请权限组一个，即表示整个权限组可以用，所以我们干脆，只要api 版本大于23（6.0）,我们申请的权限就是申请整个权限组。这样就兼容了android8.0——————-为了省事的话可以用AndPermission这个第三方框架，或者自己封装一个。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###1、android6.0以后的危险权限介绍&lt;br&gt;（注意：Android O  8.0对于权限更加严格，下面会说一下8.0）&lt;br&gt;android6.0以后有些危险权限需要手动去授权，就有了运行时权限的处理。下面的表格就是危险权限组：&lt;/p&gt;
&lt;table&gt;
&lt;the
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
