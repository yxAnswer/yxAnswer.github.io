<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术成长之路</title>
  
  <subtitle>Simple technology</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-26T09:15:21.171Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨旭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android架构组件官方文档——Lifecycle</title>
    <link href="http://yoursite.com/2018/06/26/android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E2%80%94%E2%80%94Lifecycle/"/>
    <id>http://yoursite.com/2018/06/26/android/Android架构组件官方文档——Lifecycle/</id>
    <published>2018-06-26T09:14:34.000Z</published>
    <updated>2018-06-26T09:15:21.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用生命周期感知组件处理生命周期"><a href="#使用生命周期感知组件处理生命周期" class="headerlink" title="使用生命周期感知组件处理生命周期"></a>使用生命周期感知组件处理生命周期</h2><blockquote><p>支持生命周期的组件执行操作以响应另一个组件（例如Activity和fragment）的生命周期状态更改。这些组件可帮助您生成组织性更好，并且通常更轻量的代码，这些代码更易于维护。</p></blockquote><blockquote><p>常见的模式是在Activity和fragment的生命周期方法中实现依赖组件的操作。<br>但是，这种模式导致代码的组织不良以及错误泛滥。通过使用生命周期感知组件，您可以将相关组件的代码从生命周期方法中移出并移入组件本身。</p></blockquote><blockquote><p>android.arch.lifecycle包提供了类和接口，可让您构建支持生命周期的组件，这些组件可根据活动或片段的当前生命周期状态自动调整其行为<br><strong> 注意：要将<a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener">android.arch.lifecycle</a>导入到Android项目中，请参阅<a href="https://developer.android.com/topic/libraries/architecture/adding-components#lifecycle" target="_blank" rel="noopener">向项目添加组件</a>。 </strong></p></blockquote><blockquote><p>Android框架中定义的大多数应用程序组件都附带有生命周期。生命周期由操作系统或您的流程中运行的框架代码管理。它们是Android如何工作和应用程序必须尊重它们的核心。不这样做可能会触发内存泄漏甚至应用程序崩溃。</p></blockquote><p>想象一下，我们有一个在屏幕上显示设备位置的Activity。<br>常见的实现可能如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// connect to system location service</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect from system location service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, (location) -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   尽管这个示例看起来很好，但在实际的应用程序中，您最终会有太多的调用来管理UI和其他组件，以响应当前的生命周期状态。<br>管理多个组件会在生命周期方法中放置大量代码，例如onStart（）和onStop（），这使得它们很难维护。</p><p>此外，无法保证组件在活动或片段停止之前启动。<br>如果我们需要执行一个长时间运行的操作，比如onStart（）中的一些配置检查，情况尤其如此。<br>这可能会导致onStop（）方法在onStart（）之前完成的争用条件，从而使组件的存活时间超过所需的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// what if this callback is invoked AFTER activity is stopped?</span></span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener">android.arch.lifecycle</a>包提供的类和接口可帮助您以弹性和独立的方式解决这些问题。</p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>是一个持有组件生命周期状态（如Activity或Fragment）的信息的类，并允许其他对象观察此状态。<br><a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>使用两个主要枚举来跟踪其关联组件的生命周期状态：</p><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>&emsp;&emsp;从框架和Lifecycle类派发的生命周期事件。<br>&emsp;&emsp;这些事件映射到Activities和fragments中的回调事件。</p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>&emsp;&emsp;由Lifecycle对象跟踪的组件的当前状态。</p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180626/DJk2i4fhm9.png?imageslim" alt="mark"></p><p>将状态视为图中的节点，将事件视为这些节点之间的边界。</p><p>一个类可以通过向其方法添加注解来监视组件的生命周期状态。<br>然后，您可以通过调用Lifecycle类的<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle#addObserver%28android.arch.lifecycle.LifecycleObserver%29" target="_blank" rel="noopener">addObserver（）</a>方法并传递观察者的实例来添加观察者，如下例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">MyObserver</span> <span class="selector-tag">implements</span> <span class="selector-tag">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="variable">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    public void connectListener() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    public void disconnectListener() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">myLifecycleOwner</span><span class="selector-class">.getLifecycle</span>()<span class="selector-class">.addObserver</span>(new MyObserver());</span><br></pre></td></tr></table></figure><p>在上面的例子中，myLifecycleOwner对象实现了<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>接口，这将在下一节中介绍。</p><h3 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>是一个单一的方法接口，表示该类有一个<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>。<br>它有一个方法<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner#getLifecycle%28%29" target="_blank" rel="noopener">getLifecycle（）</a>，它必须由class实现。<br>如果您试图管理整个应用程序进程的生命周期，请参阅<a href="https://developer.android.com/reference/android/arch/lifecycle/ProcessLifecycleOwner" target="_blank" rel="noopener">ProcessLifecycleOwner</a>。</p><p>该接口从各个类（如Fragment和AppCompatActivity）抽象生命周期的所有权，并允许编写与它们一起工作的组件。<br>任何自定义应用程序类都可以实现LifecycleOwner接口</p><p>实现<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleObserver" target="_blank" rel="noopener">LifecycleObserver</a>的组件可以与实现<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>的组件无缝协作，因为所有者可以提供生命周期，观察者可以注册观察。</p><p>对于位置跟踪示例，我们可以使MyLocationListener类实现LifecycleObserver，然后使用onCreate()方法中的活动生命周期对其进行初始化。<br>这允许MyLocationListener类是自给自足的，这意味着对生命周期状态变化作出反应的逻辑在MyLocationListener中声明，而不是在活动中声明。<br>让各个组件存储自己的逻辑使得活动和片段逻辑更容易管理。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyLocationListener</span> myLocationListener;</span><br><span class="line"></span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> <span class="type">MyLocationListener</span>(<span class="keyword">this</span>, getLifecycle(), location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Util</span>.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.enable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个常见的用例就是避免在生命周期状处于不好的状态时调用某些回调。<br>例如，如果回调在保存活动状态后运行fragment事务，则会触发崩溃，因此我们绝不希望调用该回调。</p><p>为了简化这个用例，生命周期类允许其他对象查询当前状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Lifecycle lifecycle, Callback callback)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">           <span class="comment">// connect</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        enabled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123;</span><br><span class="line">            <span class="comment">// connect if not connected</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect if connected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个实现，我们的LocationListener类完全是生命周期感知的。<br>如果我们需要使用来自其他Activity或Fragment的LocationListener，我们只需要初始化它。<br>所有的启动和销毁操作都由该类本身进行管理。</p><p>如果Library提供需要与Android生命周期配合使用的类，我们建议您使用支持生命周期的组件。<br>您的Library客户端可以在客户端无需手动生命周期管理即可轻松集成这些组件。</p><h4 id="实施自定义LifecycleOwner"><a href="#实施自定义LifecycleOwner" class="headerlink" title="实施自定义LifecycleOwner"></a>实施自定义LifecycleOwner</h4><p><strong>Support Library 26.1.0中的Fragment和Activity以及更高版本已经实现LifecycleOwner接口。</strong></p><p>如果您想要创建LifecycleOwner的自定义类，则可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleRegistry" target="_blank" rel="noopener">LifecycleRegistry</a>类，但需要将事件转发到该类中，如以下代码示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生命周期感知组件的最佳实践"><a href="#生命周期感知组件的最佳实践" class="headerlink" title="生命周期感知组件的最佳实践"></a>生命周期感知组件的最佳实践</h3><ul><li>尽可能保持您的UI控制器（Activities和Fragments）尽可能精简。他们不应该试图获取他们自己的数据;相反，使用<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>来做到这一点，并观察一个<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" target="_blank" rel="noopener">LiveData</a>对象来反映更改回视图。</li><li>尝试编写数据驱动UI的界面，其中您的UI控制器的职责是在数据更改时更新视图，或将用户操作通知给<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>。</li><li>把你的数据逻辑放在<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>类中。<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>应作为您的UI控制器和其他应用程序之间的连接器。但要小心，<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>不负责提取数据（例如，来自网络）。相反，<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>应调用相应的组件来获取数据，然后将结果提供给UI控制器。</li><li>使用<a href="https://developer.android.com/topic/libraries/data-binding/" target="_blank" rel="noopener">Data Binding</a>在视图和UI控制器之间保持干净的界面。这使您可以使您的视图更具说明性，并最大限度地减少需要在活动和片段中编写的更新代码。如果你喜欢用Java编程语言来做到这一点，可以使用像Butter Knife这样的库来避免样板代码并且有更好的抽象</li><li>如果您的UI很复杂，请考虑创建一个presenter类来处理UI修改。这可能是一项艰巨的任务，但它可以使您的UI组件更易于测试。</li><li>避免在<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>中引用View或Activity上下文。如果<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>超出活动（在配置更改的情况下），则活动会泄漏并且垃圾收集器无法正确处理。</li></ul><h3 id="支持生命周期感知组件的用例"><a href="#支持生命周期感知组件的用例" class="headerlink" title="支持生命周期感知组件的用例"></a>支持生命周期感知组件的用例</h3><p>支持生命周期的组件可以让您在各种情况下更容易地管理生命周期。<br>一些例子是：</p><ul><li>在粗粒度和细粒度 位置更新之间切换。使用生命周期感知组件在位置应用可见时启用细粒度位置更新，并在应用处于后台时切换到粗粒度更新。LiveData是一种生命周期感知型组件，允许您的应用在用户更改位置时自动更新用户界面。</li><li>停止并开始视频缓冲。尽可能使用支持生命周期的组件来启动视频缓冲，但延迟播放直到应用程序完全启动。您还可以使用生命周期感知组件在应用程序销毁时终止缓冲。</li><li>启动和停止网络连接。使用支持生命周期的组件可以在应用程序处于前台时实时更新（流式传输）网络数据，并在应用程序进入后台时自动暂停。</li><li>暂停和恢复动画可绘制。使用生命周期感知组件处理在应用程序处于后台时暂停动画的可绘制画面，并在应用程序处于前景时恢复可绘制画面。</li></ul><h3 id="处理停止事件"><a href="#处理停止事件" class="headerlink" title="处理停止事件"></a>处理停止事件</h3><p>当Lifecycle属于AppCompatActivity或Fragment时，Lifecycle的状态将更改为<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#CREATED" target="_blank" rel="noopener">CREATED</a>，并在调用AppCompatActivity或Fragment的onSaveInstanceState()时调度<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.Event#ON_STOP" target="_blank" rel="noopener">ON_STOP</a>事件。</p><p>当Fragment或AppCompatActivity的状态通过onSaveInstanceState（）保存时，UI被认为是不可变的，直到<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.Event#ON_START" target="_blank" rel="noopener">ON_START</a>被调用。尝试在保存状态后修改UI界面可能会导致应用程序的导航状态不一致，这就是为什么如果应用程序在状态保存后运行FragmentTransaction时FragmentManager会抛出异常。<br>有关详细信息，详情请参阅 <a href="https://developer.android.com/reference/android/support/v4/app/FragmentTransaction#commit%28%29" target="_blank" rel="noopener">commit()</a>。</p><p>如果观察者的关联Lifecycle在<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#STARTED" target="_blank" rel="noopener">STARTED</a>之前，则<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" target="_blank" rel="noopener">LiveData</a>通过避免调用其观察者来防止这种边缘情况出现。<br>在幕后，它决定调用观察者之前调用<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#isAtLeast%28android.arch.lifecycle.Lifecycle.State%29" target="_blank" rel="noopener">isAtLeast()</a>。</p><p>不幸的是，AppCompatActivity的onStop()方法会在onSaveInstanceState()之后调用，这会在不允许UI状态更改但生命周期尚未移至<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#CREATED" target="_blank" rel="noopener">CREATED</a>状态的情况下留下空隙。</p><p>为了防止出现这个问题，beta2版本中的Lifecycle类将lower状态标记为CREATED而不分派事件，即使事件直到<a href="https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html#onStop%28%29" target="_blank" rel="noopener">onStop()</a>被调用也未被分派，任何检查当前状态的代码也都会获得真实值。</p><p>不幸的是，这个解决方案有两个主要问题：</p><ul><li>在API等级23或更低的情况下，Android系统实际上保存活动的状态，即使它被另一活动部分覆盖。换句话说，Android系统调用onSaveInstanceState()，但不一定调用onStop()。这会创建一个潜在的长时间间隔，即使其UI状态无​​法修改，观察者仍认为生命周期处于活动状态。</li><li>任何想要向LiveData类公开类似行为的类都必须实现Lifecycle beta2和更低版本提供的解决方法</li></ul><p><strong>注意：为了使此流程更简单，并提供与旧版本的更好兼容性，从版本1.0.0-rc1开始，在调用onSaveInstanceState()而无需等待对onStop()的调用时，将Lifecycle对象标记为CREATED，并调度onStop()方法。这不太可能影响您的代码，但您需要注意这一点，因为它与API级别26及更低级别的Activity类中的调用顺序不匹配。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用生命周期感知组件处理生命周期&quot;&gt;&lt;a href=&quot;#使用生命周期感知组件处理生命周期&quot; class=&quot;headerlink&quot; title=&quot;使用生命周期感知组件处理生命周期&quot;&gt;&lt;/a&gt;使用生命周期感知组件处理生命周期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;支
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Dart语言之旅</title>
    <link href="http://yoursite.com/2018/06/26/dart/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/06/26/dart/学习资料记录/</id>
    <published>2018-06-26T05:15:01.000Z</published>
    <updated>2018-06-26T05:28:38.095Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本页向您展示了如何使用每个主要的Dart特性，从变量和运算符到类和库，假定您已经知道如何用另一种语言编程。要了解有关Dart核心库的更多信息，请参阅<a href="https://www.dartlang.org/guides/libraries/library-tour" target="_blank" rel="noopener">Dart  Library之旅</a>。无论何时您想了解有关语言功能的更多详细信息，请参阅<a href="https://www.dartlang.org/guides/language/spec" target="_blank" rel="noopener">Dart语言规范</a>。</p></blockquote><h2 id="Dart基础特性"><a href="#Dart基础特性" class="headerlink" title="Dart基础特性"></a>Dart基础特性</h2><h3 id="一个基本的dart程序"><a href="#一个基本的dart程序" class="headerlink" title="一个基本的dart程序"></a>一个基本的dart程序</h3><p> 以下代码使用了Dart最基本的许多功能:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数.</span></span><br><span class="line">printInteger(<span class="built_in">int</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'The number is $aNumber.'</span>); <span class="comment">// 打印到工作台</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是应用程序开始执行的地方.</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>; <span class="comment">// 声明并初始化一个变量</span></span><br><span class="line">  printInteger(number); <span class="comment">// 调用一个函数.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是适用于所有（或几乎所有）Dart应用程序的写法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 单行注释</span><br><span class="line"><span class="regexp">//</span>此外dart还支持多行注释和文档注释，详情见后面</span><br><span class="line"></span><br><span class="line">int  <span class="regexp">//i</span>nt类型，其他一些内置类型是String，List bool</span><br><span class="line"></span><br><span class="line"><span class="number">42</span> <span class="regexp">//</span>数字，数字是一种编译时常量</span><br><span class="line"></span><br><span class="line">print() <span class="regexp">//</span>一种很方便的打印方法</span><br><span class="line"></span><br><span class="line"><span class="string">'......'</span> o<span class="string">r"......"</span> <span class="regexp">//</span>这两种都是表示字符串</span><br><span class="line"></span><br><span class="line"><span class="variable">$variableName</span> (or <span class="variable">$&#123;expression&#125;</span>)</span><br><span class="line"><span class="regexp">//</span>字符串插值：在字符串文字中包含一个变量或表达式的字符串。有关更多信息，请参阅字符串。</span><br><span class="line">main()  <span class="regexp">//</span>一个应用程序执行开始的特殊的、必须的函数，详情查看main函数</span><br><span class="line">var <span class="regexp">//</span>声明变量但不指定类型</span><br></pre></td></tr></table></figure><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>当你了解Dart语言时，要牢记这些事实和概念：</p><ul><li>你可以放在变量中的所有东西都是一个对象，每个对象都是一个类的实例。即使是数字，功能， null也是对象。所有对象都从Object类继承。</li><li>虽然Dart是强类型的，但类型注释是可选的，因为Dart可以推断类型。在上面的代码中，number 被推断为是类型的int。当你想明确地说没有类型时， 使用特殊类型dynamic。</li><li>Dart支持泛型类型，如List<int>（整数列表）或List<dynamic>（任何类型的对象列表）。</dynamic></int></li><li>Dart支持顶层函数（如main()），以及与类或对象绑定的函数（分别为静态方法和实例方法）。你也可以在函数中创建函数（嵌套函数或局部函数）。</li><li>同样，Dart支持顶级变量以及绑定到类或对象（静态变量和实例变量）的变量。实例变量有时称为字段或属性。</li><li>与Java，dart不具备关键字public，protected和private。如果标识符以下划线（_）开头，则它的库是私有的。有关详细信息，请参阅 库和可见性。</li><li>标识符可以以字母或下划线（_）开头，然后是这些字符和数字的任意组合。</li><li>有时候，重要的是某件事是一种<strong>表达式</strong>还是一种 <strong>声明</strong>，所以这两个词的确切含义很有帮助。</li><li>Dart工具可以报告两种问题：warnings 和errors。警告只是表明您的代码可能无法正常工作，但它们不会阻止您的程序执行。错误可以是编译时或运行时。编译时错误导致代码无法执行; 运行时错误导致 代码执行时引发异常。</li></ul><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>下表列出了Dart语言特别处理的关键词。</p><table><thead><tr><th>abstract</th><th style="text-align:left">do</th><th>import</th><th>super</th></tr></thead><tbody><tr><td>abstract1</td><td style="text-align:left">do</td><td>import 1</td><td>super</td></tr><tr><td>as 1</td><td style="text-align:left">dynamic 1</td><td>in</td><td>switch</td></tr><tr><td>assert</td><td style="text-align:left">else</td><td>interface 1</td><td>sync* 2</td></tr><tr><td>async 2</td><td style="text-align:left">enum</td><td>is</td><td>this</td></tr><tr><td>async* 2</td><td style="text-align:left">export 1</td><td>library 1</td><td>throw</td></tr><tr><td>await 2</td><td style="text-align:left">external 1</td><td>mixin 1</td><td>true</td></tr><tr><td>break</td><td style="text-align:left">extends</td><td>new</td><td>try</td></tr><tr><td>case</td><td style="text-align:left">factory 1</td><td>null</td><td>typedef 1</td></tr><tr><td>catch</td><td style="text-align:left">false</td><td>operator 1</td><td>var</td></tr><tr><td>class</td><td style="text-align:left">final</td><td>part 1</td><td>void</td></tr><tr><td>const</td><td style="text-align:left">finally</td><td>rethrow</td><td>while</td></tr><tr><td>continue</td><td style="text-align:left">for</td><td>return</td><td>with</td></tr><tr><td>covariant 1</td><td style="text-align:left">get 1</td><td>set 1</td><td>yield 2</td></tr><tr><td>default</td><td style="text-align:left">if</td><td>static 1</td><td>yield* 2</td></tr><tr><td>deferred 1</td><td style="text-align:left">implements1</td><td></td></tr></tbody></table><p>1<strong>带上标1</strong>的单词是内置标识符。<br>避免使用内置标识符作为标识符。<br>如果您尝试为类或类型名称使用内置标识符，则会发生编译时错误。<br>2<strong>带上标2</strong>的单词是较新的，与Dart 1.0版本发布后添加的异步支持相关的有限保留字。<br>您不能使用async，await或yield作为用async，async <em>或sync </em>标记的任何函数体中的标识符。<br>有关更多信息，请参见<a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">异步支持</a></p><p><strong>关键字表中的所有其他字都是保留字。</strong><br>您不能使用保留字作为标识符**</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>以下是创建变量并初始化变量的示例：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> =<span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>变量存储的是引用，命名为name的变量存储的是 值为”Bob”的字符创的一个引用<br>name变量的类型被推断为String，但您可以通过指定它来更改该类型。<br>如果对象不限于单一类型，请遵循<a href="https://www.dartlang.org/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed" target="_blank" rel="noopener">设计指南</a>指定对象或动态类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">name</span> =<span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>另一种选择是显式声明将被推断的类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="keyword">name</span> = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>未初始化的变量的初始值为<strong>null</strong>。即使数字类型的变量最初为<strong>null</strong>，因为数字 - 和Dart中的其他所有数据一样 - <strong>都是对象</strong>。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lineCount;</span><br><span class="line"><span class="keyword">assert</span>(lineCount == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：assert()产品代码中 的调用被忽略。在开发过程中， 除非条件为真，否则会引发异常。有关详细信息，请参阅Assert。assert(condition)</strong></p></blockquote><h3 id="Final和const"><a href="#Final和const" class="headerlink" title="Final和const"></a>Final和const</h3><p>如果你从不打算改变一个变量，使用final或者const，而不是var或者其他类型。最终的变量只能设置一次; 一个const变量是一个编译时常量。（Const变量<strong>隐式final</strong> 。）final的顶层或者class变量在它第一次被使用时被初始化。</p><blockquote><p><strong>注意： 实例变量可以final但不是const。</strong></p></blockquote><p> 以下是创建和设置最终变量的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>; <span class="comment">// 没有类型声明</span></span><br><span class="line"><span class="comment">// name = 'Alice';  // 取消注释会导致UC哦呜</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">'Bobby'</span>;</span><br></pre></td></tr></table></figure><p>将const用于想要成为编译时常量的变量。<br>如果const变量处于类级别，则将其标记为静态常量。<br>在声明该变量的位置，将该值设置为编译时常量，例如数字或字符串文字，常量变量或常数上算术运算的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="number">1000000</span>; <span class="comment">// 压力单位(dynes/cm2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> atm = <span class="number">1.01325</span> * bar; <span class="comment">// 标准大气压</span></span><br></pre></td></tr></table></figure><p>该const关键字不只是声明常数变量。您也可以使用它来创建常量值，以及声明创建常量值的构造函数。任何变量都可以有一个常量值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">Note:</span> [] 创建一个空的list</span></span><br><span class="line"><span class="comment">// const [] 创建一个空的， 一成不变的list (简写为EIL).</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> []; <span class="comment">// foo 当前是一个 EIL(empty immutabe list).</span></span><br><span class="line"><span class="keyword">final</span> bar = <span class="keyword">const</span> []; <span class="comment">// bar 将永远是 EIL.</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="keyword">const</span> []; <span class="comment">// baz 是一个编译时常量 EIL.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can change the value of a non-final, non-const variable,</span></span><br><span class="line"><span class="comment">// even if it used to have a const value.</span></span><br><span class="line">foo = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can't change the value of a final or const variable.</span></span><br><span class="line"><span class="comment">// bar = []; // Unhandled exception.</span></span><br><span class="line"><span class="comment">// baz = []; // Unhandled exception.</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本页向您展示了如何使用每个主要的Dart特性，从变量和运算符到类和库，假定您已经知道如何用另一种语言编程。要了解有关Dart核心库的更多信息，请参阅&lt;a href=&quot;https://www.dartlang.org/guides/libraries
      
    
    </summary>
    
      <category term="Dart学习" scheme="http://yoursite.com/categories/Dart%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Dart学习" scheme="http://yoursite.com/tags/Dart%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Dart语言之旅</title>
    <link href="http://yoursite.com/2018/06/26/dart/Dart%E8%AF%AD%E8%A8%80%E4%B9%8B%E6%97%85/"/>
    <id>http://yoursite.com/2018/06/26/dart/Dart语言之旅/</id>
    <published>2018-06-26T05:15:01.000Z</published>
    <updated>2018-06-26T05:28:38.095Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本页向您展示了如何使用每个主要的Dart特性，从变量和运算符到类和库，假定您已经知道如何用另一种语言编程。要了解有关Dart核心库的更多信息，请参阅<a href="https://www.dartlang.org/guides/libraries/library-tour" target="_blank" rel="noopener">Dart  Library之旅</a>。无论何时您想了解有关语言功能的更多详细信息，请参阅<a href="https://www.dartlang.org/guides/language/spec" target="_blank" rel="noopener">Dart语言规范</a>。</p></blockquote><h2 id="Dart基础特性"><a href="#Dart基础特性" class="headerlink" title="Dart基础特性"></a>Dart基础特性</h2><h3 id="一个基本的dart程序"><a href="#一个基本的dart程序" class="headerlink" title="一个基本的dart程序"></a>一个基本的dart程序</h3><p> 以下代码使用了Dart最基本的许多功能:</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数.</span></span><br><span class="line">printInteger(<span class="built_in">int</span> aNumber) &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'The number is $aNumber.'</span>); <span class="comment">// 打印到工作台</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这是应用程序开始执行的地方.</span></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">42</span>; <span class="comment">// 声明并初始化一个变量</span></span><br><span class="line">  printInteger(number); <span class="comment">// 调用一个函数.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是适用于所有（或几乎所有）Dart应用程序的写法：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 单行注释</span><br><span class="line"><span class="regexp">//</span>此外dart还支持多行注释和文档注释，详情见后面</span><br><span class="line"></span><br><span class="line">int  <span class="regexp">//i</span>nt类型，其他一些内置类型是String，List bool</span><br><span class="line"></span><br><span class="line"><span class="number">42</span> <span class="regexp">//</span>数字，数字是一种编译时常量</span><br><span class="line"></span><br><span class="line">print() <span class="regexp">//</span>一种很方便的打印方法</span><br><span class="line"></span><br><span class="line"><span class="string">'......'</span> o<span class="string">r"......"</span> <span class="regexp">//</span>这两种都是表示字符串</span><br><span class="line"></span><br><span class="line"><span class="variable">$variableName</span> (or <span class="variable">$&#123;expression&#125;</span>)</span><br><span class="line"><span class="regexp">//</span>字符串插值：在字符串文字中包含一个变量或表达式的字符串。有关更多信息，请参阅字符串。</span><br><span class="line">main()  <span class="regexp">//</span>一个应用程序执行开始的特殊的、必须的函数，详情查看main函数</span><br><span class="line">var <span class="regexp">//</span>声明变量但不指定类型</span><br></pre></td></tr></table></figure><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>当你了解Dart语言时，要牢记这些事实和概念：</p><ul><li>你可以放在变量中的所有东西都是一个对象，每个对象都是一个类的实例。即使是数字，功能， null也是对象。所有对象都从Object类继承。</li><li>虽然Dart是强类型的，但类型注释是可选的，因为Dart可以推断类型。在上面的代码中，number 被推断为是类型的int。当你想明确地说没有类型时， 使用特殊类型dynamic。</li><li>Dart支持泛型类型，如List<int>（整数列表）或List<dynamic>（任何类型的对象列表）。</dynamic></int></li><li>Dart支持顶层函数（如main()），以及与类或对象绑定的函数（分别为静态方法和实例方法）。你也可以在函数中创建函数（嵌套函数或局部函数）。</li><li>同样，Dart支持顶级变量以及绑定到类或对象（静态变量和实例变量）的变量。实例变量有时称为字段或属性。</li><li>与Java，dart不具备关键字public，protected和private。如果标识符以下划线（_）开头，则它的库是私有的。有关详细信息，请参阅 库和可见性。</li><li>标识符可以以字母或下划线（_）开头，然后是这些字符和数字的任意组合。</li><li>有时候，重要的是某件事是一种<strong>表达式</strong>还是一种 <strong>声明</strong>，所以这两个词的确切含义很有帮助。</li><li>Dart工具可以报告两种问题：warnings 和errors。警告只是表明您的代码可能无法正常工作，但它们不会阻止您的程序执行。错误可以是编译时或运行时。编译时错误导致代码无法执行; 运行时错误导致 代码执行时引发异常。</li></ul><h3 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h3><p>下表列出了Dart语言特别处理的关键词。</p><table><thead><tr><th>abstract</th><th style="text-align:left">do</th><th>import</th><th>super</th></tr></thead><tbody><tr><td>abstract1</td><td style="text-align:left">do</td><td>import 1</td><td>super</td></tr><tr><td>as 1</td><td style="text-align:left">dynamic 1</td><td>in</td><td>switch</td></tr><tr><td>assert</td><td style="text-align:left">else</td><td>interface 1</td><td>sync* 2</td></tr><tr><td>async 2</td><td style="text-align:left">enum</td><td>is</td><td>this</td></tr><tr><td>async* 2</td><td style="text-align:left">export 1</td><td>library 1</td><td>throw</td></tr><tr><td>await 2</td><td style="text-align:left">external 1</td><td>mixin 1</td><td>true</td></tr><tr><td>break</td><td style="text-align:left">extends</td><td>new</td><td>try</td></tr><tr><td>case</td><td style="text-align:left">factory 1</td><td>null</td><td>typedef 1</td></tr><tr><td>catch</td><td style="text-align:left">false</td><td>operator 1</td><td>var</td></tr><tr><td>class</td><td style="text-align:left">final</td><td>part 1</td><td>void</td></tr><tr><td>const</td><td style="text-align:left">finally</td><td>rethrow</td><td>while</td></tr><tr><td>continue</td><td style="text-align:left">for</td><td>return</td><td>with</td></tr><tr><td>covariant 1</td><td style="text-align:left">get 1</td><td>set 1</td><td>yield 2</td></tr><tr><td>default</td><td style="text-align:left">if</td><td>static 1</td><td>yield* 2</td></tr><tr><td>deferred 1</td><td style="text-align:left">implements1</td><td></td></tr></tbody></table><p>1<strong>带上标1</strong>的单词是内置标识符。<br>避免使用内置标识符作为标识符。<br>如果您尝试为类或类型名称使用内置标识符，则会发生编译时错误。<br>2<strong>带上标2</strong>的单词是较新的，与Dart 1.0版本发布后添加的异步支持相关的有限保留字。<br>您不能使用async，await或yield作为用async，async <em>或sync </em>标记的任何函数体中的标识符。<br>有关更多信息，请参见<a href="https://www.dartlang.org/guides/language/language-tour#asynchrony-support" target="_blank" rel="noopener">异步支持</a></p><p><strong>关键字表中的所有其他字都是保留字。</strong><br>您不能使用保留字作为标识符**</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>以下是创建变量并初始化变量的示例：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">name</span> =<span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>变量存储的是引用，命名为name的变量存储的是 值为”Bob”的字符创的一个引用<br>name变量的类型被推断为String，但您可以通过指定它来更改该类型。<br>如果对象不限于单一类型，请遵循<a href="https://www.dartlang.org/guides/language/effective-dart/design#do-annotate-with-object-instead-of-dynamic-to-indicate-any-object-is-allowed" target="_blank" rel="noopener">设计指南</a>指定对象或动态类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dynamic</span> <span class="keyword">name</span> =<span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>另一种选择是显式声明将被推断的类型</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="keyword">name</span> = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>未初始化的变量的初始值为<strong>null</strong>。即使数字类型的变量最初为<strong>null</strong>，因为数字 - 和Dart中的其他所有数据一样 - <strong>都是对象</strong>。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> lineCount;</span><br><span class="line"><span class="keyword">assert</span>(lineCount == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>注意：assert()产品代码中 的调用被忽略。在开发过程中， 除非条件为真，否则会引发异常。有关详细信息，请参阅Assert。assert(condition)</strong></p></blockquote><h3 id="Final和const"><a href="#Final和const" class="headerlink" title="Final和const"></a>Final和const</h3><p>如果你从不打算改变一个变量，使用final或者const，而不是var或者其他类型。最终的变量只能设置一次; 一个const变量是一个编译时常量。（Const变量<strong>隐式final</strong> 。）final的顶层或者class变量在它第一次被使用时被初始化。</p><blockquote><p><strong>注意： 实例变量可以final但不是const。</strong></p></blockquote><p> 以下是创建和设置最终变量的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>; <span class="comment">// 没有类型声明</span></span><br><span class="line"><span class="comment">// name = 'Alice';  // 取消注释会导致UC哦呜</span></span><br><span class="line"><span class="keyword">final</span> <span class="built_in">String</span> nickname = <span class="string">'Bobby'</span>;</span><br></pre></td></tr></table></figure><p>将const用于想要成为编译时常量的变量。<br>如果const变量处于类级别，则将其标记为静态常量。<br>在声明该变量的位置，将该值设置为编译时常量，例如数字或字符串文字，常量变量或常数上算术运算的结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="number">1000000</span>; <span class="comment">// 压力单位(dynes/cm2)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> atm = <span class="number">1.01325</span> * bar; <span class="comment">// 标准大气压</span></span><br></pre></td></tr></table></figure><p>该const关键字不只是声明常数变量。您也可以使用它来创建常量值，以及声明创建常量值的构造函数。任何变量都可以有一个常量值。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">Note:</span> [] 创建一个空的list</span></span><br><span class="line"><span class="comment">// const [] 创建一个空的， 一成不变的list (简写为EIL).</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">const</span> []; <span class="comment">// foo 当前是一个 EIL(empty immutabe list).</span></span><br><span class="line"><span class="keyword">final</span> bar = <span class="keyword">const</span> []; <span class="comment">// bar 将永远是 EIL.</span></span><br><span class="line"><span class="keyword">const</span> baz = <span class="keyword">const</span> []; <span class="comment">// baz 是一个编译时常量 EIL.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// You can change the value of a non-final, non-const variable,</span></span><br><span class="line"><span class="comment">// even if it used to have a const value.</span></span><br><span class="line">foo = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// You can't change the value of a final or const variable.</span></span><br><span class="line"><span class="comment">// bar = []; // Unhandled exception.</span></span><br><span class="line"><span class="comment">// baz = []; // Unhandled exception.</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本页向您展示了如何使用每个主要的Dart特性，从变量和运算符到类和库，假定您已经知道如何用另一种语言编程。要了解有关Dart核心库的更多信息，请参阅&lt;a href=&quot;https://www.dartlang.org/guides/libraries
      
    
    </summary>
    
      <category term="Dart学习" scheme="http://yoursite.com/categories/Dart%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Dart学习" scheme="http://yoursite.com/tags/Dart%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android权限列表</title>
    <link href="http://yoursite.com/2018/06/22/android/Android%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/22/android/Android权限列表/</id>
    <published>2018-06-22T05:16:32.000Z</published>
    <updated>2018-06-22T05:17:44.664Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.csdn.net/ufo00001/article/details/69397256" target="_blank" rel="noopener">http://blog.csdn.net/ufo00001/article/details/69397256</a></p><table><thead><tr><th>1.android.permission.WRITE_USER_DICTIONARY</th><th>允许应用程序向用户词典中写入新词 </th></tr></thead><tbody><tr><td>2.android.permission.WRITE_SYNC_SETTINGS</td><td>写入Google在线同步设置 </td></tr><tr><td>3.android.permission.WRITE_SOCIAL_STREAM</td><td>读取用户的社交信息流 </td></tr><tr><td>4.android.permission.WRITE_SMS</td><td>允许程序写短信 </td></tr><tr><td>5.android.permission.WRITE_SETTINGS</td><td>允许程序读取或写入系统设置 </td></tr><tr><td>6.android.permission.WRITE_SECURE_SETTINGS</td><td>允许应用程序读取或写入安全系统设置 </td></tr><tr><td>7.android.permission.WRITE_PROFILE</td><td>允许程序写入个人资料数据 </td></tr><tr><td>8.com.android.browser.permission.WRITE_HISTORY_BOOKMARKS</td><td>允许一个应用程序写（但不可读）用户的浏览历史和书签 </td></tr><tr><td>9.android.permission.WRITE_GSERVICES</td><td>允许程序修改Google服务地图 </td></tr><tr><td>10.android.permission.WRITE_EXTERNAL_STORAGE</td><td>允许程序写入外部存储，如SD卡上写文件 </td></tr><tr><td>11.android.permission.WRITE_CONTACTS</td><td>写入联系人，但不可读取 </td></tr><tr><td>12.android.permission.WRITE_CALL_LOG</td><td>允许程序写入（但是不能读）用户的联系人数据 </td></tr><tr><td>13.android.permission.WRITE_CALENDAR</td><td>允许程序写入日程，但不可读取 </td></tr><tr><td>14.android.permission.WRITE_APN_SETTINGS</td><td>允许程序写入网络GPRS接入点设置 </td></tr><tr><td>15.android.permission.WAKE_LOCK</td><td>允许程序在手机屏幕关闭后后台进程仍然运行 </td></tr><tr><td>16.android.permission.VIBRATE</td><td>允许程序振动 </td></tr><tr><td>17.android.permission.USE_SIP</td><td>允许程序使用SIP视频服务 </td></tr><tr><td>18.android.permission.USE_CREDENTIALS</td><td>允许程序请求验证从AccountManager </td></tr><tr><td>19.android.permission.UPDATE_DEVICE_STATS</td><td>允许程序更新设备状态 </td></tr><tr><td>20.com.android.launcher.permission.UNINSTALL_SHORTCUT</td><td>删除快捷方式 </td></tr><tr><td>21.android.permission.TRANSMIT_IR</td><td>允许使用设备的红外发射器，如果可用 </td></tr><tr><td>22.android.permission.SYSTEM_ALERT_WINDOW</td><td>允许程序显示系统窗口 </td></tr><tr><td>23.android.permission.SUBSCRIBED_FEEDS_WRITE</td><td>允许程序写入或修改订阅内容的数据库 </td></tr><tr><td>24.android.permission.SUBSCRIBED_FEEDS_READ</td><td>允许程序访问订阅信息的数据库 </td></tr><tr><td>22.android.permission.STATUS_BAR</td><td>允许程序打开、关闭、禁用状态栏 </td></tr><tr><td>23.android.permission.SIGNAL_PERSISTENT_PROCESSES</td><td>允许程序发送一个永久的进程信号 </td></tr><tr><td>24.android.permission.SET_WALLPAPER_HINTS</td><td>允许程序设置壁纸建议 </td></tr><tr><td>25.android.permission.SET_WALLPAPER</td><td>允许程序设置桌面壁纸 </td></tr><tr><td>26.android.permission.SET_TIME_ZONE</td><td>允许程序设置系统时区 </td></tr><tr><td>27.android.permission.SET_TIME</td><td>允许程序设置系统时间 </td></tr><tr><td>28.android.permission.SET_PROCESS_LIMIT</td><td>允许程序设置最大的进程数量的限制 </td></tr><tr><td>29.android.permission.SET_PREFERRED_APPLICATIONS</td><td>允许程序设置应用的参数，<br>已不再工作具体查看addPackageToPreferred（String） 介绍 </td></tr><tr><td>30.android.permission.SET_POINTER_SPEED</td><td>无法被第三方应用获得，系统权限 </td></tr><tr><td>31.android.permission.SET_ORIENTATION</td><td>允许程序设置屏幕方向为横屏或标准方式显示，不用于普通应用 </td></tr><tr><td>32.android.permission.SET_DEBUG_APP</td><td>允许程序设置调试程序，一般用于开发 </td></tr><tr><td>33.android.permission.SET_ANIMATION_SCALE</td><td>允许程序设置全局动画缩放 </td></tr><tr><td>34.android.permission.SET_ALWAYS_FINISH</td><td>允许程序设置程序在后台是否总是退出 </td></tr><tr><td>36.com.android.alarm.permission.SET_ALARM</td><td>允许程序设置闹铃提醒 </td></tr><tr><td>37.android.permission.SET_ACTIVITY_WATCHER</td><td>允许程序设置Activity观察器<br>一般用于monkey测试 </td></tr><tr><td>38.android.permission.SEND_SMS</td><td>允许程序发送短信 </td></tr><tr><td>39.android.permission.SEND_RESPOND_VIA_MESSAGE</td><td>允许用户在来电的时候用你的应用进行即时的短信息回复。 </td></tr><tr><td>40.android.permission.RESTART_PACKAGES</td><td>允许程序结束任务通过<br>restartPackage（String）方法，该方式将在外来放弃</td></tr><tr><td>41.android.permission.REORDER_TASKS</td><td>允许程序重新排序系统Z轴运行中的任务 </td></tr><tr><td>42.android.permission.RECORD_AUDIO</td><td>允许程序录制声音通过手机或耳机的麦克 </td></tr><tr><td>43.android.permission.RECEIVE_WAP_PUSH</td><td>允许程序接收WAP PUSH信息 </td></tr><tr><td>44.android.permission.RECEIVE_SMS</td><td>允许程序接收短信 </td></tr><tr><td>45.android.permission.RECEIVE_MMS</td><td>允许程序接收彩信 </td></tr><tr><td>46.android.permission.RECEIVE_BOOT_COMPLETED</td><td>允许程序开机自动运行 </td></tr><tr><td>47.android.permission.REBOOT</td><td>允许程序重新启动设备 </td></tr><tr><td>48.android.permission.READ_USER_DICTIONARY</td><td>从一个提供器中获取数据，针对对应的提供器，应用程序需要“读访问权限” </td></tr><tr><td>49.android.permission.READ_SYNC_STATS</td><td>允许程序读取同步状态，获得Google在线同步状态 </td></tr><tr><td>50.android.permission.READ_SYNC_SETTINGS</td><td>允许程序读取同步设置，读取Google在线同步设置 </td></tr><tr><td>51.android.permission.READ_SOCIAL_STREAM</td><td>读取用户的社交信息流 </td></tr><tr><td>52.android.permission.READ_SMS</td><td>允许程序读取短信内容 </td></tr><tr><td>53.android.permission.READ_PROFILE</td><td>访问用户个人资料 </td></tr><tr><td>54.android.permission.READ_PHONE_STATE</td><td>允许程序访问电话状态 </td></tr><tr><td>55.android.permission.READ_LOGS</td><td>允许程序读取系统底层日志 </td></tr><tr><td>56.android.permission.READ_INPUT_STATE</td><td>允许程序读取当前键的输入状态，仅用于系统 </td></tr><tr><td>57.com.android.browser.permission.READ_HISTORY_BOOKMARKS</td><td>允许程序读取浏览器收藏夹和历史记录 </td></tr><tr><td>58.android.permission.READ_FRAME_BUFFER</td><td>允许程序读取帧缓存用于屏幕截图 </td></tr><tr><td>59.android.permission.READ_EXTERNAL_STORAGE</td><td>程序可以读取设备外部存储空间（内置SDcard和外置SDCard）的文件，如果您的App已经添加<br>了“WRITE_EXTERNAL_STORAGE ”权限 ，则就没必要添加读的权限了，写权限已经包含了读权限了。 </td></tr><tr><td>60.android.permission.READ_CONTACTS</td><td>允许程序访问联系人通讯录信息 </td></tr><tr><td>61.android.permission.READ_CALL_LOG</td><td>读取通话记录 </td></tr><tr><td>62.android.permission.READ_CALENDAR</td><td>允许程序读取用户的日程信息 </td></tr><tr><td>63.android.permission.PROCESS_OUTGOING_CALLS</td><td>允许程序监视，修改或放弃播出电话 </td></tr><tr><td>64.android.permission.PERSISTENT_ACTIVITY</td><td>允许程序创建一个永久的Activity，该功能标记为将来将被移除 </td></tr><tr><td>65.android.permission.NFC</td><td>允许程序执行NFC近距离通讯操作，用于移动支持 </td></tr><tr><td>66.android.permission.MOUNT_UNMOUNT_FILESYSTEMS</td><td>允许程序挂载、反挂载外部文件系统 </td></tr><tr><td>67.android.permission.MOUNT_FORMAT_FILESYSTEMS</td><td>允许程序格式化可移动文件系统，比如格式化清空SD卡 </td></tr><tr><td>68.android.permission.MODIFY_PHONE_STATE</td><td>允许程序修改电话状态，如飞行模式，但不包含替换系统拨号器界面 </td></tr><tr><td>69.android.permission.MODIFY_AUDIO_SETTINGS</td><td>允许程序修改声音设置信息 </td></tr><tr><td>70.android.permission.MEDIA_CONTENT_CONTROL</td><td>允许一个应用程序知道什么是播放和控制其内容。不被第三方应用使用。 </td></tr><tr><td>71.android.permission.MASTER_CLEAR</td><td>允许程序执行软格式化，删除系统配置信息 </td></tr><tr><td>72.android.permission.MANAGE_DOCUMENTS</td><td>允许一个应用程序来管理文档的访问，通常是一个文档选择器部分 </td></tr><tr><td>73.android.permission.MANAGE_APP_TOKENS</td><td>管理创建、摧毁、Z轴顺序，仅用于系统 </td></tr><tr><td>74.android.permission.MANAGE_ACCOUNTS</td><td>允许程序管理AccountManager中的账户列表 </td></tr><tr><td>75.android.permission.LOCATION_HARDWARE</td><td>允许一个应用程序中使用定位功能的硬件，不使用第三方应用 </td></tr><tr><td>76.android.permission.KILL_BACKGROUND_PROCESSES</td><td>允许程序调用killBackgroundProcesses（String）。方法结束后台进程 </td></tr><tr><td>77.android.permission.INTERNET</td><td>允许程序访问网络连接，可能产生GPRS流量 </td></tr><tr><td>78.android.permission.INTERNAL_SYSTEM_WINDOW</td><td>允许程序打开内部窗口，不对第三方应用程序开放此权限 </td></tr><tr><td>79.com.android.launcher.permission.INSTALL_SHORTCUT</td><td>创建快捷方式 </td></tr><tr><td>80.android.permission.INSTALL_PACKAGES</td><td></td></tr><tr><td>81.android.permission.INSTALL_LOCATION_PROVIDER</td><td>允许程序安装定位提供 </td></tr><tr><td>82.android.permission.INJECT_EVENTS</td><td>允许程序访问本程序的底层事件，获取按键、轨迹球的事件流 </td></tr><tr><td>83.android.permission.HARDWARE_TEST</td><td>允许程序访问硬件辅助设备，用于硬件测试 </td></tr><tr><td>84.android.permission.GLOBAL_SEARCH</td><td>允许程序允许全局搜索 </td></tr><tr><td>85.android.permission.GET_TOP_ACTIVITY_INFO</td><td>允许一个应用程序检索私有信息是当前最顶级的活动，不被第三方应用使用 </td></tr><tr><td>86.android.permission.GET_TASKS</td><td>允许程序获取任务信息 </td></tr><tr><td>87.android.permission.GET_PACKAGE_SIZE</td><td>允许程序获取应用的文件大小 </td></tr><tr><td>88.android.permission.GET_ACCOUNTS</td><td>允许程序访问账户Gmail列表 </td></tr><tr><td>89.android.permission.FORCE_BACK</td><td>允许程序强制使用back后退按键，无论Activity是否在顶层 </td></tr><tr><td>90.android.permission.FLASHLIGHT</td><td>允许访问闪光灯 </td></tr><tr><td>91.android.permission.FACTORY_TEST</td><td>允许程序运行工厂测试模式 </td></tr><tr><td>92.android.permission.EXPAND_STATUS_BAR</td><td>允许程序扩展或收缩状态栏 </td></tr><tr><td>93.android.permission.DUMP</td><td>允许程序获取系统dump信息从系统服务 </td></tr><tr><td>94.android.permission.DISABLE_KEYGUARD</td><td>允许程序禁用键盘锁 </td></tr><tr><td>95.android.permission.DIAGNOSTIC</td><td>允许程序到RW到诊断资源 </td></tr><tr><td>96.android.permission.DEVICE_POWER</td><td>允许程序访问底层电源管理 </td></tr><tr><td>97.android.permission.DELETE_PACKAGES</td><td>允许程序删除应用 </td></tr><tr><td>98.android.permission.DELETE_CACHE_FILES</td><td>允许程序删除缓存文件 </td></tr><tr><td>99.android.permission.CONTROL_LOCATION_UPDATES</td><td>允许程序获得移动网络定位信息改变 </td></tr><tr><td>100.android.permission.CLEAR_APP_USER_DATA</td><td>允许程序清除用户数据 </td></tr><tr><td>101.android.permission.CLEAR_APP_CACHE</td><td>允许程序清除应用缓存 </td></tr><tr><td>102.android.permission.CHANGE_WIFI_STATE</td><td>允许程序改变WiFi状态 </td></tr><tr><td>103.android.permission.CHANGE_WIFI_MULTICAST_STATE</td><td>允许程序改变WiFi多播状态 </td></tr><tr><td>104.android.permission.CHANGE_NETWORK_STATE</td><td>允许程序改变网络状态，如是否联网 </td></tr><tr><td>105.android.permission.CHANGE_CONFIGURATION</td><td>允许当前应用改变配置，如定位 </td></tr><tr><td>106.android.permission.CHANGE_COMPONENT_ENABLED_STATE</td><td>改变组件是否启用状态 </td></tr><tr><td>107.android.permission.CAPTURE_VIDEO_OUTPUT</td><td>允许一个应用程序捕获视频输出，不被第三方应用使用 </td></tr><tr><td>108.android.permission.CAPTURE_SECURE_VIDEO_OUTPUT</td><td>允许一个应用程序捕获视频输出。不被第三方应用使用 </td></tr><tr><td>109.android.permission.CAPTURE_AUDIO_OUTPUT</td><td>允许一个应用程序捕获音频输出。不被第三方应用使用 </td></tr><tr><td>110.android.permission.CAMERA</td><td>允许程序访问摄像头进行拍照 </td></tr><tr><td>111.android.permission.CALL_PRIVILEGED</td><td>允许程序拨打电话，替换系统的拨号器界面 </td></tr><tr><td>112.android.permission.CALL_PHONE</td><td>允许程序从非系统拨号器里拨打电话 </td></tr><tr><td>113.android.permission.BROADCAST_WAP_PUSH</td><td>WAP PUSH服务收到后触发一个广播 </td></tr><tr><td>114.android.permission.BROADCAST_STICKY</td><td>允许程序收到广播后快速收到下一个广播 </td></tr><tr><td>115.android.permission.BROADCAST_SMS</td><td>允许程序当收到短信时触发一个广播 </td></tr><tr><td>116.android.permission.BROADCAST_PACKAGE_REMOVED</td><td>允许程序删除时广播 </td></tr><tr><td>117.android.permission.BRICK</td><td>能够禁用手机，非常危险，顾名思义就是让手机变成砖头 </td></tr><tr><td>118.android.permission.BLUETOOTH_PRIVILEGED</td><td>允许应用程序配对蓝牙设备，而无需用户交互。这不是第三方应用程序可用。 </td></tr><tr><td>119.android.permission.BLUETOOTH_ADMIN</td><td>允许程序进行发现和配对新的蓝牙设备 </td></tr><tr><td>120.android.permission.BLUETOOTH</td><td>允许程序连接配对过的蓝牙设备 </td></tr><tr><td>121.android.permission.BIND_WALLPAPER</td><td>必须通过WallpaperService服务来请求，只有系统才能用 </td></tr><tr><td>122.android.permission.BIND_VPN_SERVICE</td><td>绑定VPN服务必须通过VpnService服务来请求，只有系统才能用 </td></tr><tr><td>123.android.permission.BIND_TEXT_SERVICE</td><td>必须要求textservice（例如吗 spellcheckerservice），以确保只有系统可以绑定到它。 </td></tr><tr><td>124.android.permission.BIND_REMOTEVIEWS</td><td>必须通过RemoteViewsService服务来请求，只有系统才能用 </td></tr><tr><td>125.android.permission.BIND_PRINT_SERVICE</td><td>必须要求由printservice，以确保只有系统可以绑定到它。 </td></tr><tr><td>126.android.permission.BIND_NOTIFICATION_LISTENER_SERVICE</td><td>必须要求由notificationlistenerservice，以确保只有系统可以绑定到它。 </td></tr><tr><td>127.android.permission.BIND_NFC_SERVICE</td><td>由hostapduservice或offhostapduservice必须确保只有系统可以绑定到它。 </td></tr><tr><td>128.android.permission.BIND_INPUT_METHOD</td><td>请求InputMethodService服务，只有系统才能使用 </td></tr><tr><td>129.android.permission.BIND_DEVICE_ADMIN</td><td>请求系统管理员接收者receiver，只有系统才能使用 </td></tr><tr><td>130.android.permission.BIND_APPWIDGET</td><td>允许程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 </td></tr><tr><td>131.android.permission.BIND_ACCESSIBILITY_SERVICE</td><td>请求accessibilityservice服务，以确保只有系统可以绑定到它。 </td></tr><tr><td>132.android.permission.AUTHENTICATE_ACCOUNTS</td><td>允许程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 </td></tr><tr><td>133.com.android.voicemail.permission.ADD_VOICEMAIL</td><td>允许一个应用程序添加语音邮件系统 </td></tr><tr><td>134.android.permission.ACCOUNT_MANAGER</td><td>允许程序获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 </td></tr><tr><td>135.android.permission.ACCESS_WIFI_STATE</td><td>允许程序获取当前WiFi接入的状态以及WLAN热点的信息 </td></tr><tr><td>136.android.permission.ACCESS_SURFACE_FLINGER</td><td>Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 </td></tr><tr><td>137.android.permission.ACCESS_NETWORK_STATE</td><td>允许程序获取网络信息状态，如当前的网络连接是否有效 </td></tr><tr><td>138.android.permission.ACCESS_MOCK_LOCATION</td><td>允许程序获取模拟定位信息，一般用于帮助开发者调试应用 </td></tr><tr><td>139.android.permission.ACCESS_LOCATION_EXTRA_COMMANDS</td><td>允许程序访问额外的定位提供者指令 </td></tr><tr><td>140.android.permission.ACCESS_FINE_LOCATION</td><td>允许程序通过GPS芯片接收卫星的定位信息 </td></tr><tr><td>141.android.permission.ACCESS_COARSE_LOCATION</td><td>允许程序通过WiFi或移动基站的方式获取用户错略的经纬度信息 </td></tr><tr><td>142.android.permission.ACCESS_CHECKIN_PROPERTIES</td><td>允许程序读取或写入登记check-in数据库属性表的权限</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;http://blog.csdn.net/ufo00001/article/details/69397256&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/ufo00001/articl
      
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android运行时权限总结</title>
    <link href="http://yoursite.com/2018/06/22/android/Android%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/22/android/Android运行时权限总结/</id>
    <published>2018-06-22T02:50:27.000Z</published>
    <updated>2018-06-22T03:50:52.271Z</updated>
    
    <content type="html"><![CDATA[<p>###1、android6.0以后的危险权限介绍<br>（注意：Android O  8.0对于权限更加严格，下面会说一下8.0）<br>android6.0以后有些危险权限需要手动去授权，就有了运行时权限的处理。下面的表格就是危险权限组：</p><table><thead><tr><th>权限组名</th><th>权限名</th></tr></thead><tbody><tr><td>CALENDAR  日历</td><td>READ_CALENDAR<br>WRITE_CALENDER</td></tr><tr><td>CAMERA      相机</td><td>CAMERA</td></tr><tr><td>CONTACTS 联系人</td><td>READ_CONTACTS<br>WRITE_CONTACTS<br>GET_ACCOUNTS</td></tr><tr><td>LOCATION  定位</td><td>ACCESS_FINE_LOCATION<br>ACCESS_COARSE_LOCATION</td></tr><tr><td>MICROPHONE 麦克风</td><td>RECORD_AUDIO</td></tr><tr><td>PHONE 电话</td><td>READ_PHONE_STATE<br>CALL_PHONE<br>READ_CALL_LOG<br>WRITE_CALL_LOG<br>ADD_VOICEMAIL<br>USE_SIP<br>PROCESS_OUTGOING_CALLS</td></tr><tr><td>SENSORS 传感器</td><td>BODY_SENSORS</td></tr><tr><td>SMS  短信</td><td>Short Message Service<br>SEND_SMS<br>RECEIVE_SMS<br>READ_SMS<br>RECEIVE_WAP_PUSH<br>RECEIVE_MMS</td></tr><tr><td>STORAGE 数据存储</td><td>READ_EXTRAL_STRORAGE<br>WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><p>申请权限时：<br>1、在清单文件中声明权限（如果不在这张表中，声明完就可以了）<br>2、如果在这张表中的权限需要手动来申请</p><p>这些权限6.0以后需要手动申请，，每一个权限组中的权限只要有一个权限同意授权了，整个权限组中的权限就不用重复申请了。<br><strong>如果如果查看所有的权限，请参考：<a href="https://segmentfault.com/a/1190000012259370" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012259370</a></strong></p><p>###2、运行时权限申请过程：<br>传统的申请过程是：<br>1、在AndroidManifest文件中添加需要的权限。<br>2、检查权限是否授权<br>3、申请权限<br>4、处理授权的结果</p><p>一步步来：<br><strong>1、首先在请单文件中声明，这个不用说</strong><br><strong>2、检查权限是否授权</strong></p><pre><code>if (ContextCompat.checkSelfPermission(thisActivity,            Manifest.permission.READ_CONTACTS)    != PackageManager.PERMISSION_GRANTED) {    //没有授权，编写申请权限代码}else{//已经授权，执行操作代码}    </code></pre><p>   基本上调用checkSelfPermission()函数传入权限参数，返回的结果又两个：<br>如果是已授权的权限，该方法返回结果是 PackageManager.PERMISSION_GRANTED 常量为 0，<br>如果是未授权的权限，该方法返回结果是 PackageManager.PERMISSION_DENIED 常量为 -1。<br>这样就可以判断是否已经授权，来进行下一步的操作。</p><p><strong>3、如果没有授权，需要申请权限</strong><br>    ActivityCompat.requestPermissions(thisActivity,<br>                new String[]{Manifest.permission.READ_CONTACTS},<br>                MY_PERMISSIONS_REQUEST_READ_CONTACTS);<br>  这是一个异步的方法，第一个参数是Context；第二个参数是需要申请的权限的字符串数组（这个是支持同时申请多个权限，系统会逐个询问是否授权）；第三个参数为请求码requestCode，主要用于回调的时候检测。</p><p><strong>4、处理权限申请的回调结果</strong><br>重写Activity或者fragment的 onRequestPermissionsResul()方法<br>      //权限回调方法<br>    @Override<br>    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</p><pre><code>    switch (requestCode){        case 0:            //grantResults数组存储的申请的返回结果，            //PERMISSION_GRANTED 表示申请成功            if (grantResults.length&gt;0&amp;&amp;grantResults[0]== PackageManager.PERMISSION_GRANTED){                //授权成功，                //这里写相应的 操作代码            }else{                //授权失败，可以简单提示用户                Toast.makeText(this, &quot;没有授权继续操作&quot;, Toast.LENGTH_SHORT).show();            }            break;        case 1:            //同上            break;        default:            break;    }}这里稍微说一下，申请的时候是一个一个的申请的话，每次申请都有一个请求码，这里的grantResults数组就只有一个值，所以都是grantResults[0]来和PERMISSION_GRANTED来进行比较如果是一次申请多个权限，grantResults数组返回的值就不止一个，但是，直接遍历它就行，只要全部满足条件才算申请成功，才能进行相应的操作一般的写法是：通过if判断权限是否申请，没有申请，把它加到一个集合里面，把所有的权限都判断一遍以后，去遍历这个集合，只要有一个没有申请的，就需、要去申请权限，    把这个集合转为数组，传到requestPermissions的第二个参数，然后就处理相应 结果就可以了，遍历grantResults数组，判断是不是全部满足条件</code></pre><p>###3、EasyPermissions的使用<br>GitHub地址：<a href="https://github.com/googlesamples/easypermissions" target="_blank" rel="noopener">https://github.com/googlesamples/easypermissions</a><br>   EasyPermissions是谷歌封装的一个运行时权限申请的库，简化了操作的过程。<br>使用过程： 没有什么先后顺序，下面没有按这个顺序。这么做是可以的，当然还有其他的使用方法</p><blockquote><p>1、builde gradle中依赖<br>2、清单文件中声明权限<br>3、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions来<br>4、通过hasPermissions检查权限，或者原生的也行，然后去申请权限<br>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法，成功或失败<br>6、在成功或者失败方法中编写要具体做的事。</p></blockquote><p>GitHub地址：<br><strong>(1)依赖库</strong><br>    dependencies {<br>        compile ‘pub.devrel:easypermissions:1.0.1’<br>    }</p><p><strong>(2)再在清单文件中声明要申请的危险权限</strong><br>如果不声明的话，直接在代码中写也能申请成功，但是好想不会弹出询问框，直接就申请了</p><p><strong>(3)申请权限</strong><br>可以直接申请<br>    EasyPermissions.requestPermissions(<br>                        MainActivity.this,<br>                        “申请权限”,<br>                        0,<br>                        Manifest.permission.WRITE_EXTERNAL_STORAGE,<br>                        Manifest.permission.RECORD_AUDIO);<br>最好还是检查一下权限是否申请：<br><strong>EasyPermissions.hasPermissions(Context context, @NonNull String… perms)</strong>方法来检测一个或者多个权限是否被允许，第二个参数是个可变数组，可以申请多个<br>    String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};<br>    if (EasyPermissions.hasPermissions(this, perms)) {</p><pre><code>    // 已经申请过权限，做想做的事} else {    // 没有申请过权限，现在去申请    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),            RC_CAMERA_AND_LOCATION, perms);}</code></pre><p>下面来说一个申请权限这个方法：<br>EasyPermissions.requestPermissions():<img src="/img/bVZBii" alt="图片描述"></p><p>requestPermissions() 一般用这个四个参数的就可以<br>第一个参数：Context对象<br>第二个参数：权限弹窗上的文字提示语。告诉用户，这个权限用途。<br>第三个参数：这次请求权限的唯一标识请求码，code。<br>第四个参数 : 一些系列的权限。<br>   这里说一下第二个参数，不是第一次申请系统默认弹出的提示语，而是，我们拒绝后，再次点击申请弹出的对话框，，显示我们设置的提示语，下面有两个按钮，确认和取消，我就不贴图了。</p><p>还有六个参数的，多了两个参数就是，修改我们上面那个确认和取消的字样，你可以干成yes 和no. </p><p><strong>4、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions    </strong><br>一行代码就搞定了<br>     @Override<br>    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>        super.onRequestPermissionsResult(requestCode, permissions, grantResults);<br>        EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);<br>    }</p><p><strong>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法</strong><br>    public class MainActivity extends AppCompatActivity implements EasyPermissions.PermissionCallbacks {</p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);}@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {    super.onRequestPermissionsResult(requestCode, permissions, grantResults);    // 把执行结果的操作给EasyPermissions    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);}@Override //申请成功时调用public void onPermissionsGranted(int requestCode, List&lt;String&gt; list) {    //请求成功执行相应的操作    比如，举个例子    switch (requestCode){        case 0:            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();            break;        case 1:            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();            break;    }}@Override //申请失败时调用public void onPermissionsDenied(int requestCode, List&lt;String&gt; list) {    // 请求失败，执行相应操作}}</code></pre><p>接下来就要说一下成功或者失败后的操作了： 申请成功就直接做该做的事就行了，没啥。<br>申请如果失败了，这时候有个方法出现了EasyPermissions.somePermissionPermanentlyDenied(this, perms)<br>这个方法是谷歌建议的。就是在我们点了不在询问并拒绝，会弹出对话框，告诉用户这个权限时干嘛的，很重要，建议不要拒绝哈哈<br>比如这样：  </p><pre><code>@Overridepublic void onPermissionsDenied(int requestCode, List&lt;String&gt; perms) {if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {    new AppSettingsDialog.Builder(this).build().show();    //弹出个对话框}</code></pre><p>}                 </p><p>当然我们可以定制一下这个对话框：<br>    @Override<br>    public void onPermissionsDenied(int requestCode, List<string> perms) {<br>        //处理权限名字字符串<br>        StringBuffer sb = new StringBuffer();<br>        for (String str : perms){<br>            sb.append(str);<br>            sb.append(“\n”);<br>        }<br>        sb.replace(sb.length() - 2,sb.length(),””);</string></p><pre><code>    switch (requestCode){        case 0:            Toast.makeText(this, &quot;已拒绝权限&quot; + perms.get(0), Toast.LENGTH_SHORT).show();            break;        case 1:            Toast.makeText(this, &quot;已拒绝WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;+ perms.get(0), Toast.LENGTH_SHORT).show();            break;    }    if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {        Toast.makeText(this, &quot;已拒绝权限&quot; + sb + &quot;并不再询问&quot; , Toast.LENGTH_SHORT).show();        new AppSettingsDialog                .Builder(this)                .setRationale(&quot;此功能需要&quot; + sb + &quot;权限，否则无法正常使用，是否打开设置&quot;)                .setPositiveButton(&quot;是&quot;)                .setNegativeButton(&quot;否&quot;)                .build()                .show();    }}</code></pre><p><strong>6、(可选)@AfterPermissionGranted()注解</strong></p><p>使用 AfterPermissioonGranted 注解。这是可选的，但是提供出来是为了方便。如果所有的请求的权限都被授予了，被注解的方法将会被执行，这样做是为了简化通常的请求权限成功之后再调用方法的流程。同时也可以在onPermissionsGranted 的回调中添加逻辑操作：<br>比如官网上的这个实例代码：<br>这里的方法名可以自己取，主要是权限都申请完，就调用这个方法，执行里面的操作。<br>其实就相当于在onPermissionsGranted()调用这个方法而已:</p><pre><code>@AfterPermissionGranted(RC_CAMERA_AND_LOCATION)private void methodRequiresTwoPermission() {String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};if (EasyPermissions.hasPermissions(this, perms)) {    // Already have permission, do the thing    // ...} else {    // Do not have permissions, request them now    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),            RC_CAMERA_AND_LOCATION, perms);}}</code></pre><p>基本上介绍完了</p><p>###4、android 8.0运行时权限<br>对于针对Android O的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p><p>例如，假设某个应用在其清单中列出READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE。应用请求READ_EXTERNAL_STORAGE，并且用户授予了该权限，如果该应用针对的是API级别24或更低级别，系统还会同时授予WRITE_EXTERNAL_STORAGE，因为该权限也属于STORAGE权限组并且也在清单中注册过。如果该应用针对的是Android O，则系统此时仅会授予READ_EXTERNAL_STORAGE，不过在该应用以后申请WRITE_EXTERNAL_STORAGE权限时，系统会立即授予该权限，而不会提示用户。<br><strong>注意：如果使用了没有授权的权限，会崩溃的</strong></p><p>所以对于8.0权限，我们要做的处理，是尽量把所用到的危险权限全部申请。但是有的权限在不同版本出现，所以要兼容不同的版本，所以要加一个版本的判断。</p><blockquote><p>归根结底：android M (6.0)以后，申请权限组一个，即表示整个权限组可以用，所以我们干脆，只要api 版本大于23（6.0）,我们申请的权限就是申请整个权限组。这样就兼容了android8.0——————-为了省事的话可以用AndPermission这个第三方框架，或者自己封装一个。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###1、android6.0以后的危险权限介绍&lt;br&gt;（注意：Android O  8.0对于权限更加严格，下面会说一下8.0）&lt;br&gt;android6.0以后有些危险权限需要手动去授权，就有了运行时权限的处理。下面的表格就是危险权限组：&lt;/p&gt;
&lt;table&gt;
&lt;the
      
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
</feed>
