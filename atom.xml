<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术成长之路</title>
  
  <subtitle>Simple technology</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-25T09:19:21.972Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨旭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2018/06/25/android/Android%20%E6%9E%B6%E6%9E%84%E7%BB%84%E5%BB%BA-Lifecycle%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/06/25/android/Android 架构组建-Lifecycle介绍/</id>
    <published>2018-06-25T09:19:21.839Z</published>
    <updated>2018-06-25T09:19:21.972Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、Lifecycle介绍"><a href="#1、Lifecycle介绍" class="headerlink" title="1、Lifecycle介绍"></a>1、Lifecycle介绍</h4><p>lifecycle官方文档地址：<br><a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">https://developer.android.com/topic/libraries/architecture/lifecycle</a></p><h5 id="为什么要使用lifecycle？"><a href="#为什么要使用lifecycle？" class="headerlink" title="为什么要使用lifecycle？"></a>为什么要使用lifecycle？</h5><blockquote><p>activity 和fragment 是有声明周期的，有时候，我们的很多操作需要写在声明周期的方法中，比如，下载，文件操作等，这样很多情况下回导致，我们在activity中的声明周期方法中写越来越多的代码，activity或者fragment 越来越臃肿，代码维护越来越困难。 使用lifecycle就可以很好的解决这类问题。<br>lifecycle代码简洁，我们可以通过实现LifecycleObserver 接口，来监听声明周期，然后我们在activity和fragment中去注册监听。</p><h4 id="2、几个重要的类和接口"><a href="#2、几个重要的类和接口" class="headerlink" title="2、几个重要的类和接口"></a>2、几个重要的类和接口</h4></blockquote><ul><li><p><strong>Lifecycle</strong><br> Lifecycle是一个持有组件生命周期状态（如Activity或Fragment）的信息的类，并允许其他对象观察此状态。</p></li><li><p><strong>Event</strong> ：从框架和Lifecycle类派发的生命周期事件。这些事件映射到活动和片段中的回调事件。</p></li><li><p><strong>State</strong> ：由Lifecycle对象跟踪的组件的当前状态。</p></li><li><strong>LifecycleOwner</strong> （重要）Lifecycle持有者</li><li><p>实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</p></li><li><p><strong>LifecycleObserver</strong>（重要）Lifecycle观察者</p></li><li>实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。</li></ul><h4 id="3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver-的使用"><a href="#3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver-的使用" class="headerlink" title="3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver 的使用"></a>3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver 的使用</h4><h5 id="（1）LifecycleOwner（生命周期持有者接口）"><a href="#（1）LifecycleOwner（生命周期持有者接口）" class="headerlink" title="（1）LifecycleOwner（生命周期持有者接口）"></a>（1）LifecycleOwner（生命周期持有者接口）</h5><blockquote><p>官网介绍：<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>是一个单一的方法接口，表示该类有一个 <a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>。它有一个方法，<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner#getLifecycle%28%29" target="_blank" rel="noopener">getLifecycle()</a>这个方法 必须由这个类来实现。如果您试图管理整个应用程序进程的生命周期，请参阅 <a href="https://developer.android.com/reference/android/arch/lifecycle/ProcessLifecycleOwner" target="_blank" rel="noopener">ProcessLifecycleOwner</a>。该接口从各个类（如Fragment和AppCompatActivity）抽象生命周期的所有权，并允许编写与它们一起工作的组件。<br>任何自定义应用程序类都可以实现LifecycleOwner接口<br>实现LifecycleObserver的组件与实现LifecycleOwner的组件无缝协作，因为所有者可以提供生命周期，观察者可以注册以观看</p></blockquote><p>简单来说，LifecycleOwner就是一个接口，谁继承了它，就持有了lifecycle对象。然后就可以调用getLifecycle()方法获取继承了抽象类Lifecycle的LifecycleRegistry，然后调用 addObserver(@NonNull LifecycleObserver observer) 方法来注册监听。<br>这样，<strong>该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</strong></p><p><strong>注意：Support Library 26.1.0 及其以后的版本，Activity 和Fragment 已经实现了LifecycleOwner 接口，所以，我们可以直接在Activity 和Fragment中使用getLifecycle()方法来获取lifecycle对象，来添加观察者监听。</strong></p><h5 id="（2）LifecycleObserver（生命周期观察者接口）"><a href="#（2）LifecycleObserver（生命周期观察者接口）" class="headerlink" title="（2）LifecycleObserver（生命周期观察者接口）"></a>（2）LifecycleObserver（生命周期观察者接口）</h5><blockquote><p>LifecycleObserver 是一个观察者接口，实现了它，可以通过注解或者继承的方式，来管理声明周期的监听。只要在持有lifecycle的类中注册了它，当声明周期发生变化时，它就能收到，进行我们自定义的操作。</p></blockquote><p>两种实现方式：</p><ol><li>实现DefaultLifecycleObserver接口，然后重写里面生命周期方法；</li><li>直接实现LifecycleObserver接口，然后通过注解的方式来接收生命周期的变化；<br><strong>Lifecycle.java文档中是建议使用第一种方式，因为文档中说明了，随着Java8成为主流，注解的方式会被弃用。</strong><br>GenericLifecycleObserver，FullLifecycleObserver，DefaultLifecycleObserver 这三个接口都是直接或者间接继承的LifecycleObserver</li></ol><h4 id="3、开始使用Lifecycle"><a href="#3、开始使用Lifecycle" class="headerlink" title="3、开始使用Lifecycle"></a>3、开始使用Lifecycle</h4><p>我们写个测试代码，首先，我们要测试一下，到底LifecycleObserver到底能不能监听到声明周期的变化。<br>先写两个简单的Activity，FirstActivity 和SecondActivity, 单纯的一个跳转。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Button</span> firstBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> <span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.first_activity_layout);</span><br><span class="line">        initView();</span><br><span class="line">        initListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initView() &#123;</span><br><span class="line">        firstBtn = findViewById(<span class="type">R</span>.id.first_btn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initListener() &#123;</span><br><span class="line">        firstBtn.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onClick(<span class="type">View</span> v) &#123;</span><br><span class="line">                <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="type">FirstActivity</span>.<span class="keyword">this</span>, <span class="type">SecondActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们要做的是要写一个需要拥有声明周期的类，正常我们自定义控件啊，或者做其他逻辑的类，是没有声明周期的，现在有了LifecycleObserver,我们可以让一个普通的类拥有感知声明周期变化的能力。比如，现在自定义一个，MyObserver类。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">MyObserver</span> <span class="selector-tag">implements</span> <span class="selector-tag">DefaultLifecycleObserver</span>&#123;</span><br><span class="line">    <span class="variable">@Override</span></span><br><span class="line">    public void onCreate(<span class="variable">@NonNull</span> LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="selector-tag">Log</span><span class="selector-class">.d</span>(<span class="string">"TEST-------"</span>,<span class="string">"onCreate"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Override</span></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">onStart</span>(<span class="variable">@NonNull</span> LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="selector-tag">Log</span><span class="selector-class">.d</span>(<span class="string">"TEST-------"</span>,<span class="string">"onStart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Override</span></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">onResume</span>(<span class="variable">@NonNull</span> LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="selector-tag">Log</span><span class="selector-class">.d</span>(<span class="string">"TEST-------"</span>,<span class="string">"onResume"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Override</span></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">onPause</span>(<span class="variable">@NonNull</span> LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="selector-tag">Log</span><span class="selector-class">.d</span>(<span class="string">"TEST-------"</span>,<span class="string">"onPause"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Override</span></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">onStop</span>(<span class="variable">@NonNull</span> LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="selector-tag">Log</span><span class="selector-class">.d</span>(<span class="string">"TEST-------"</span>,<span class="string">"onStop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="selector-tag">Override</span></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">onDestroy</span>(<span class="variable">@NonNull</span> LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="selector-tag">Log</span><span class="selector-class">.d</span>(<span class="string">"TEST-------"</span>,<span class="string">"onDestroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们采取的是，直接继承DefaultLifecycleObserver接口，来实现它所有的方法。我们在里面做了log,来查看，是否这个类，收到了activity声明周期的变化。<br>然后，要做的就是<strong>注册监听</strong><br>在Activity 的OnCreate方法中，调用getLifecycle();</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Button</span> firstBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> <span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.first_activity_layout);</span><br><span class="line">        initView();</span><br><span class="line">        initListener();</span><br><span class="line">        <span class="comment">//添加了这一行代码</span></span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="type">MyObserver</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initView() &#123;</span><br><span class="line">        firstBtn = findViewById(<span class="type">R</span>.id.first_btn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initListener() &#123;</span><br><span class="line">        firstBtn.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onClick(<span class="type">View</span> v) &#123;</span><br><span class="line">                <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="type">FirstActivity</span>.<span class="keyword">this</span>, <span class="type">SecondActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，api26,.1以后，Activity中可以直接 getLifecycle().addObserver(new MyObserver()); 这样，就已经注册了声明周期观察者的监听。运行查看log<br>启动FirstActivity后，MyObserver类已经监听到了Activity的声明周期方法，<img src="https://img-blog.csdn.net/20180531145126631?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>点击跳转到SecondActivity<br><img src="https://img-blog.csdn.net/20180531145506830?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>可以看到，FirstActivity声明周期走了onPause  onStop，MyObserver也成功监听到了，继续返回FirstActivity<br><img src="https://img-blog.csdn.net/2018053114561662?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>最后，点击返回键，退出FirstActivity，<br><img src="https://img-blog.csdn.net/20180531145650938?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>通过这个简单的小例子，我们看到了 我们的类，只要实现了 LifecycleObserver接口，然后，在Activity 或者Fragment中 通过getLifecycle().addObserver()方法，把这个类的对象传入，就可以实现声明周期的感应监听。<br>当然，我们可以再初始化这个类的时候，把Lifecycle对象传入，那我们自定义的类就可以自己去管理声明周期，而不依赖activity或者fragment。 这样，activity在使用此类的时候就不必关系声明周期的问题，因为，在这个类里面我们已经处理了。比如： 给MyObserver类 添加一个构造方法，传入一个Lifecycle对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Lifecycle lifecycle;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Lifecycle lifecycle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//然后再相应的需要处理声明周期的方法中使用下面代码判断</span></span><br><span class="line">    <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123;</span><br><span class="line">            <span class="comment">//这里只是示例，不一定是STARTED</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里用到了Lifecycle类的方法，下面我们看一下Lifecycle的源码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> &#123;</span></span><br><span class="line">    <span class="meta">@MainThread</span>  <span class="comment">//添加将在LifecycleOwner更改状态时通知的LifecycleObserver。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> addObserver(<span class="meta">@NonNull</span> LifecycleObserver observer);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span> <span class="comment">//从观察者列表中删除给定的观察者。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> removeObserver(<span class="meta">@NonNull</span> LifecycleObserver observer);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span> <span class="comment">//返回生命周期的当前状态。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> State getCurrentState();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        ON_CREATE,<span class="comment">//用于onCreate事件的常量LifecycleOwner。</span></span><br><span class="line"></span><br><span class="line">        ON_START,</span><br><span class="line"></span><br><span class="line">        ON_RESUME,</span><br><span class="line"></span><br><span class="line">        ON_PAUSE,</span><br><span class="line"></span><br><span class="line">        ON_STOP,</span><br><span class="line"></span><br><span class="line">        ON_DESTROY,</span><br><span class="line"></span><br><span class="line">        ON_ANY <span class="comment">//一个Event可以用来匹配所有事件的常数。 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED, <span class="comment">//LifecycleOwner的初始化状态。 </span></span><br><span class="line">        CREATED, </span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line"><span class="comment">//比较此状态是否大于或等于给定值state。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isAtLeast(<span class="meta">@NonNull</span> State state) &#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marks a class as a LifecycleObserver. It does not have any methods, instead, relies on</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> OnLifecycleEvent&#125; annotated methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Lifecycle Lifecycle - for samples and usage patterns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleObserver</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个抽象类，注释已经很详细了，应该不用解释了</p><p>最后借用下官网的-生命周期感知组件的最佳实战</p><ol><li>尽可能保持您的UI控制器（活动和片段）尽可能精简。他们不应该试图获取他们自己的数据;相反，使用<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>来做到这一点，并观察一个LiveData对象来反映更改回视图。</li><li>尝试编写数据驱动的用户界面，其中您的用户界面控制器的职责是在数据更改时更新视图，或将用户操作通知给ViewModel。</li><li>把你的数据逻辑放在<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>类中。ViewModel应作为您的UI控制器和其他应用程序之间的连接器。但要小心，ViewModel不负责提取数据（例如，来自网络）。相反，ViewModel应调用相应的组件来获取数据，然后将结果提供给UI控制器。</li><li>使用<a href="https://developer.android.com/topic/libraries/data-binding/" target="_blank" rel="noopener">dataBinding</a>在视图和UI控制器之间保持干净的界面。这使您可以使您的视图更具说明性，并最大限度地减少需要在活动和片段中编写的更新代码。<br>如果你喜欢用Java编程语言来做到这一点，可以使用像Butter Knife这样的库来避免样板代码并且有更好的抽象。</li><li>如果您的UI很复杂，请考虑创建一个演示者类（<a href="http://www.gwtproject.org/articles/mvp-architecture.html#presenter" target="_blank" rel="noopener">presenter</a>）来处理UI修改。这可能是一项艰巨的任务，但它可以使您的UI组件更易于测试。</li><li>避免在ViewModel中引用View或Activity上下文。<br>如果ViewModel超出活动（在配置更改的情况下），则活动会泄漏并且垃圾收集器无法正确处理。</li></ol><p>借用下<a href="https://blog.csdn.net/zhuzp_blog/article/details/78871374" target="_blank" rel="noopener">https://blog.csdn.net/zhuzp_blog/article/details/78871374</a>  作者的两张图，更清晰，对于相信信息，可到作者博客去查看相关讲解<br><img src="https://img-blog.csdn.net/20180531152720780?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180531152910152?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、Lifecycle介绍&quot;&gt;&lt;a href=&quot;#1、Lifecycle介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Lifecycle介绍&quot;&gt;&lt;/a&gt;1、Lifecycle介绍&lt;/h4&gt;&lt;p&gt;lifecycle官方文档地址：&lt;br&gt;&lt;a hre
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dart学习笔记</title>
    <link href="http://yoursite.com/2018/06/25/dart/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/25/dart/Dart学习笔记/</id>
    <published>2018-06-25T08:32:20.000Z</published>
    <updated>2018-06-25T08:40:39.453Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Dart学习笔记" scheme="http://yoursite.com/categories/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Dart学习笔记" scheme="http://yoursite.com/tags/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Android权限列表</title>
    <link href="http://yoursite.com/2018/06/22/android/Android%E6%9D%83%E9%99%90%E5%88%97%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/06/22/android/Android权限列表/</id>
    <published>2018-06-22T05:16:32.000Z</published>
    <updated>2018-06-22T05:17:44.664Z</updated>
    
    <content type="html"><![CDATA[<p>原文链接：<a href="http://blog.csdn.net/ufo00001/article/details/69397256" target="_blank" rel="noopener">http://blog.csdn.net/ufo00001/article/details/69397256</a></p><table><thead><tr><th>1.android.permission.WRITE_USER_DICTIONARY</th><th>允许应用程序向用户词典中写入新词 </th></tr></thead><tbody><tr><td>2.android.permission.WRITE_SYNC_SETTINGS</td><td>写入Google在线同步设置 </td></tr><tr><td>3.android.permission.WRITE_SOCIAL_STREAM</td><td>读取用户的社交信息流 </td></tr><tr><td>4.android.permission.WRITE_SMS</td><td>允许程序写短信 </td></tr><tr><td>5.android.permission.WRITE_SETTINGS</td><td>允许程序读取或写入系统设置 </td></tr><tr><td>6.android.permission.WRITE_SECURE_SETTINGS</td><td>允许应用程序读取或写入安全系统设置 </td></tr><tr><td>7.android.permission.WRITE_PROFILE</td><td>允许程序写入个人资料数据 </td></tr><tr><td>8.com.android.browser.permission.WRITE_HISTORY_BOOKMARKS</td><td>允许一个应用程序写（但不可读）用户的浏览历史和书签 </td></tr><tr><td>9.android.permission.WRITE_GSERVICES</td><td>允许程序修改Google服务地图 </td></tr><tr><td>10.android.permission.WRITE_EXTERNAL_STORAGE</td><td>允许程序写入外部存储，如SD卡上写文件 </td></tr><tr><td>11.android.permission.WRITE_CONTACTS</td><td>写入联系人，但不可读取 </td></tr><tr><td>12.android.permission.WRITE_CALL_LOG</td><td>允许程序写入（但是不能读）用户的联系人数据 </td></tr><tr><td>13.android.permission.WRITE_CALENDAR</td><td>允许程序写入日程，但不可读取 </td></tr><tr><td>14.android.permission.WRITE_APN_SETTINGS</td><td>允许程序写入网络GPRS接入点设置 </td></tr><tr><td>15.android.permission.WAKE_LOCK</td><td>允许程序在手机屏幕关闭后后台进程仍然运行 </td></tr><tr><td>16.android.permission.VIBRATE</td><td>允许程序振动 </td></tr><tr><td>17.android.permission.USE_SIP</td><td>允许程序使用SIP视频服务 </td></tr><tr><td>18.android.permission.USE_CREDENTIALS</td><td>允许程序请求验证从AccountManager </td></tr><tr><td>19.android.permission.UPDATE_DEVICE_STATS</td><td>允许程序更新设备状态 </td></tr><tr><td>20.com.android.launcher.permission.UNINSTALL_SHORTCUT</td><td>删除快捷方式 </td></tr><tr><td>21.android.permission.TRANSMIT_IR</td><td>允许使用设备的红外发射器，如果可用 </td></tr><tr><td>22.android.permission.SYSTEM_ALERT_WINDOW</td><td>允许程序显示系统窗口 </td></tr><tr><td>23.android.permission.SUBSCRIBED_FEEDS_WRITE</td><td>允许程序写入或修改订阅内容的数据库 </td></tr><tr><td>24.android.permission.SUBSCRIBED_FEEDS_READ</td><td>允许程序访问订阅信息的数据库 </td></tr><tr><td>22.android.permission.STATUS_BAR</td><td>允许程序打开、关闭、禁用状态栏 </td></tr><tr><td>23.android.permission.SIGNAL_PERSISTENT_PROCESSES</td><td>允许程序发送一个永久的进程信号 </td></tr><tr><td>24.android.permission.SET_WALLPAPER_HINTS</td><td>允许程序设置壁纸建议 </td></tr><tr><td>25.android.permission.SET_WALLPAPER</td><td>允许程序设置桌面壁纸 </td></tr><tr><td>26.android.permission.SET_TIME_ZONE</td><td>允许程序设置系统时区 </td></tr><tr><td>27.android.permission.SET_TIME</td><td>允许程序设置系统时间 </td></tr><tr><td>28.android.permission.SET_PROCESS_LIMIT</td><td>允许程序设置最大的进程数量的限制 </td></tr><tr><td>29.android.permission.SET_PREFERRED_APPLICATIONS</td><td>允许程序设置应用的参数，<br>已不再工作具体查看addPackageToPreferred（String） 介绍 </td></tr><tr><td>30.android.permission.SET_POINTER_SPEED</td><td>无法被第三方应用获得，系统权限 </td></tr><tr><td>31.android.permission.SET_ORIENTATION</td><td>允许程序设置屏幕方向为横屏或标准方式显示，不用于普通应用 </td></tr><tr><td>32.android.permission.SET_DEBUG_APP</td><td>允许程序设置调试程序，一般用于开发 </td></tr><tr><td>33.android.permission.SET_ANIMATION_SCALE</td><td>允许程序设置全局动画缩放 </td></tr><tr><td>34.android.permission.SET_ALWAYS_FINISH</td><td>允许程序设置程序在后台是否总是退出 </td></tr><tr><td>36.com.android.alarm.permission.SET_ALARM</td><td>允许程序设置闹铃提醒 </td></tr><tr><td>37.android.permission.SET_ACTIVITY_WATCHER</td><td>允许程序设置Activity观察器<br>一般用于monkey测试 </td></tr><tr><td>38.android.permission.SEND_SMS</td><td>允许程序发送短信 </td></tr><tr><td>39.android.permission.SEND_RESPOND_VIA_MESSAGE</td><td>允许用户在来电的时候用你的应用进行即时的短信息回复。 </td></tr><tr><td>40.android.permission.RESTART_PACKAGES</td><td>允许程序结束任务通过<br>restartPackage（String）方法，该方式将在外来放弃</td></tr><tr><td>41.android.permission.REORDER_TASKS</td><td>允许程序重新排序系统Z轴运行中的任务 </td></tr><tr><td>42.android.permission.RECORD_AUDIO</td><td>允许程序录制声音通过手机或耳机的麦克 </td></tr><tr><td>43.android.permission.RECEIVE_WAP_PUSH</td><td>允许程序接收WAP PUSH信息 </td></tr><tr><td>44.android.permission.RECEIVE_SMS</td><td>允许程序接收短信 </td></tr><tr><td>45.android.permission.RECEIVE_MMS</td><td>允许程序接收彩信 </td></tr><tr><td>46.android.permission.RECEIVE_BOOT_COMPLETED</td><td>允许程序开机自动运行 </td></tr><tr><td>47.android.permission.REBOOT</td><td>允许程序重新启动设备 </td></tr><tr><td>48.android.permission.READ_USER_DICTIONARY</td><td>从一个提供器中获取数据，针对对应的提供器，应用程序需要“读访问权限” </td></tr><tr><td>49.android.permission.READ_SYNC_STATS</td><td>允许程序读取同步状态，获得Google在线同步状态 </td></tr><tr><td>50.android.permission.READ_SYNC_SETTINGS</td><td>允许程序读取同步设置，读取Google在线同步设置 </td></tr><tr><td>51.android.permission.READ_SOCIAL_STREAM</td><td>读取用户的社交信息流 </td></tr><tr><td>52.android.permission.READ_SMS</td><td>允许程序读取短信内容 </td></tr><tr><td>53.android.permission.READ_PROFILE</td><td>访问用户个人资料 </td></tr><tr><td>54.android.permission.READ_PHONE_STATE</td><td>允许程序访问电话状态 </td></tr><tr><td>55.android.permission.READ_LOGS</td><td>允许程序读取系统底层日志 </td></tr><tr><td>56.android.permission.READ_INPUT_STATE</td><td>允许程序读取当前键的输入状态，仅用于系统 </td></tr><tr><td>57.com.android.browser.permission.READ_HISTORY_BOOKMARKS</td><td>允许程序读取浏览器收藏夹和历史记录 </td></tr><tr><td>58.android.permission.READ_FRAME_BUFFER</td><td>允许程序读取帧缓存用于屏幕截图 </td></tr><tr><td>59.android.permission.READ_EXTERNAL_STORAGE</td><td>程序可以读取设备外部存储空间（内置SDcard和外置SDCard）的文件，如果您的App已经添加<br>了“WRITE_EXTERNAL_STORAGE ”权限 ，则就没必要添加读的权限了，写权限已经包含了读权限了。 </td></tr><tr><td>60.android.permission.READ_CONTACTS</td><td>允许程序访问联系人通讯录信息 </td></tr><tr><td>61.android.permission.READ_CALL_LOG</td><td>读取通话记录 </td></tr><tr><td>62.android.permission.READ_CALENDAR</td><td>允许程序读取用户的日程信息 </td></tr><tr><td>63.android.permission.PROCESS_OUTGOING_CALLS</td><td>允许程序监视，修改或放弃播出电话 </td></tr><tr><td>64.android.permission.PERSISTENT_ACTIVITY</td><td>允许程序创建一个永久的Activity，该功能标记为将来将被移除 </td></tr><tr><td>65.android.permission.NFC</td><td>允许程序执行NFC近距离通讯操作，用于移动支持 </td></tr><tr><td>66.android.permission.MOUNT_UNMOUNT_FILESYSTEMS</td><td>允许程序挂载、反挂载外部文件系统 </td></tr><tr><td>67.android.permission.MOUNT_FORMAT_FILESYSTEMS</td><td>允许程序格式化可移动文件系统，比如格式化清空SD卡 </td></tr><tr><td>68.android.permission.MODIFY_PHONE_STATE</td><td>允许程序修改电话状态，如飞行模式，但不包含替换系统拨号器界面 </td></tr><tr><td>69.android.permission.MODIFY_AUDIO_SETTINGS</td><td>允许程序修改声音设置信息 </td></tr><tr><td>70.android.permission.MEDIA_CONTENT_CONTROL</td><td>允许一个应用程序知道什么是播放和控制其内容。不被第三方应用使用。 </td></tr><tr><td>71.android.permission.MASTER_CLEAR</td><td>允许程序执行软格式化，删除系统配置信息 </td></tr><tr><td>72.android.permission.MANAGE_DOCUMENTS</td><td>允许一个应用程序来管理文档的访问，通常是一个文档选择器部分 </td></tr><tr><td>73.android.permission.MANAGE_APP_TOKENS</td><td>管理创建、摧毁、Z轴顺序，仅用于系统 </td></tr><tr><td>74.android.permission.MANAGE_ACCOUNTS</td><td>允许程序管理AccountManager中的账户列表 </td></tr><tr><td>75.android.permission.LOCATION_HARDWARE</td><td>允许一个应用程序中使用定位功能的硬件，不使用第三方应用 </td></tr><tr><td>76.android.permission.KILL_BACKGROUND_PROCESSES</td><td>允许程序调用killBackgroundProcesses（String）。方法结束后台进程 </td></tr><tr><td>77.android.permission.INTERNET</td><td>允许程序访问网络连接，可能产生GPRS流量 </td></tr><tr><td>78.android.permission.INTERNAL_SYSTEM_WINDOW</td><td>允许程序打开内部窗口，不对第三方应用程序开放此权限 </td></tr><tr><td>79.com.android.launcher.permission.INSTALL_SHORTCUT</td><td>创建快捷方式 </td></tr><tr><td>80.android.permission.INSTALL_PACKAGES</td><td></td></tr><tr><td>81.android.permission.INSTALL_LOCATION_PROVIDER</td><td>允许程序安装定位提供 </td></tr><tr><td>82.android.permission.INJECT_EVENTS</td><td>允许程序访问本程序的底层事件，获取按键、轨迹球的事件流 </td></tr><tr><td>83.android.permission.HARDWARE_TEST</td><td>允许程序访问硬件辅助设备，用于硬件测试 </td></tr><tr><td>84.android.permission.GLOBAL_SEARCH</td><td>允许程序允许全局搜索 </td></tr><tr><td>85.android.permission.GET_TOP_ACTIVITY_INFO</td><td>允许一个应用程序检索私有信息是当前最顶级的活动，不被第三方应用使用 </td></tr><tr><td>86.android.permission.GET_TASKS</td><td>允许程序获取任务信息 </td></tr><tr><td>87.android.permission.GET_PACKAGE_SIZE</td><td>允许程序获取应用的文件大小 </td></tr><tr><td>88.android.permission.GET_ACCOUNTS</td><td>允许程序访问账户Gmail列表 </td></tr><tr><td>89.android.permission.FORCE_BACK</td><td>允许程序强制使用back后退按键，无论Activity是否在顶层 </td></tr><tr><td>90.android.permission.FLASHLIGHT</td><td>允许访问闪光灯 </td></tr><tr><td>91.android.permission.FACTORY_TEST</td><td>允许程序运行工厂测试模式 </td></tr><tr><td>92.android.permission.EXPAND_STATUS_BAR</td><td>允许程序扩展或收缩状态栏 </td></tr><tr><td>93.android.permission.DUMP</td><td>允许程序获取系统dump信息从系统服务 </td></tr><tr><td>94.android.permission.DISABLE_KEYGUARD</td><td>允许程序禁用键盘锁 </td></tr><tr><td>95.android.permission.DIAGNOSTIC</td><td>允许程序到RW到诊断资源 </td></tr><tr><td>96.android.permission.DEVICE_POWER</td><td>允许程序访问底层电源管理 </td></tr><tr><td>97.android.permission.DELETE_PACKAGES</td><td>允许程序删除应用 </td></tr><tr><td>98.android.permission.DELETE_CACHE_FILES</td><td>允许程序删除缓存文件 </td></tr><tr><td>99.android.permission.CONTROL_LOCATION_UPDATES</td><td>允许程序获得移动网络定位信息改变 </td></tr><tr><td>100.android.permission.CLEAR_APP_USER_DATA</td><td>允许程序清除用户数据 </td></tr><tr><td>101.android.permission.CLEAR_APP_CACHE</td><td>允许程序清除应用缓存 </td></tr><tr><td>102.android.permission.CHANGE_WIFI_STATE</td><td>允许程序改变WiFi状态 </td></tr><tr><td>103.android.permission.CHANGE_WIFI_MULTICAST_STATE</td><td>允许程序改变WiFi多播状态 </td></tr><tr><td>104.android.permission.CHANGE_NETWORK_STATE</td><td>允许程序改变网络状态，如是否联网 </td></tr><tr><td>105.android.permission.CHANGE_CONFIGURATION</td><td>允许当前应用改变配置，如定位 </td></tr><tr><td>106.android.permission.CHANGE_COMPONENT_ENABLED_STATE</td><td>改变组件是否启用状态 </td></tr><tr><td>107.android.permission.CAPTURE_VIDEO_OUTPUT</td><td>允许一个应用程序捕获视频输出，不被第三方应用使用 </td></tr><tr><td>108.android.permission.CAPTURE_SECURE_VIDEO_OUTPUT</td><td>允许一个应用程序捕获视频输出。不被第三方应用使用 </td></tr><tr><td>109.android.permission.CAPTURE_AUDIO_OUTPUT</td><td>允许一个应用程序捕获音频输出。不被第三方应用使用 </td></tr><tr><td>110.android.permission.CAMERA</td><td>允许程序访问摄像头进行拍照 </td></tr><tr><td>111.android.permission.CALL_PRIVILEGED</td><td>允许程序拨打电话，替换系统的拨号器界面 </td></tr><tr><td>112.android.permission.CALL_PHONE</td><td>允许程序从非系统拨号器里拨打电话 </td></tr><tr><td>113.android.permission.BROADCAST_WAP_PUSH</td><td>WAP PUSH服务收到后触发一个广播 </td></tr><tr><td>114.android.permission.BROADCAST_STICKY</td><td>允许程序收到广播后快速收到下一个广播 </td></tr><tr><td>115.android.permission.BROADCAST_SMS</td><td>允许程序当收到短信时触发一个广播 </td></tr><tr><td>116.android.permission.BROADCAST_PACKAGE_REMOVED</td><td>允许程序删除时广播 </td></tr><tr><td>117.android.permission.BRICK</td><td>能够禁用手机，非常危险，顾名思义就是让手机变成砖头 </td></tr><tr><td>118.android.permission.BLUETOOTH_PRIVILEGED</td><td>允许应用程序配对蓝牙设备，而无需用户交互。这不是第三方应用程序可用。 </td></tr><tr><td>119.android.permission.BLUETOOTH_ADMIN</td><td>允许程序进行发现和配对新的蓝牙设备 </td></tr><tr><td>120.android.permission.BLUETOOTH</td><td>允许程序连接配对过的蓝牙设备 </td></tr><tr><td>121.android.permission.BIND_WALLPAPER</td><td>必须通过WallpaperService服务来请求，只有系统才能用 </td></tr><tr><td>122.android.permission.BIND_VPN_SERVICE</td><td>绑定VPN服务必须通过VpnService服务来请求，只有系统才能用 </td></tr><tr><td>123.android.permission.BIND_TEXT_SERVICE</td><td>必须要求textservice（例如吗 spellcheckerservice），以确保只有系统可以绑定到它。 </td></tr><tr><td>124.android.permission.BIND_REMOTEVIEWS</td><td>必须通过RemoteViewsService服务来请求，只有系统才能用 </td></tr><tr><td>125.android.permission.BIND_PRINT_SERVICE</td><td>必须要求由printservice，以确保只有系统可以绑定到它。 </td></tr><tr><td>126.android.permission.BIND_NOTIFICATION_LISTENER_SERVICE</td><td>必须要求由notificationlistenerservice，以确保只有系统可以绑定到它。 </td></tr><tr><td>127.android.permission.BIND_NFC_SERVICE</td><td>由hostapduservice或offhostapduservice必须确保只有系统可以绑定到它。 </td></tr><tr><td>128.android.permission.BIND_INPUT_METHOD</td><td>请求InputMethodService服务，只有系统才能使用 </td></tr><tr><td>129.android.permission.BIND_DEVICE_ADMIN</td><td>请求系统管理员接收者receiver，只有系统才能使用 </td></tr><tr><td>130.android.permission.BIND_APPWIDGET</td><td>允许程序告诉appWidget服务需要访问小插件的数据库，只有非常少的应用才用到此权限 </td></tr><tr><td>131.android.permission.BIND_ACCESSIBILITY_SERVICE</td><td>请求accessibilityservice服务，以确保只有系统可以绑定到它。 </td></tr><tr><td>132.android.permission.AUTHENTICATE_ACCOUNTS</td><td>允许程序通过账户验证方式访问账户管理ACCOUNT_MANAGER相关信息 </td></tr><tr><td>133.com.android.voicemail.permission.ADD_VOICEMAIL</td><td>允许一个应用程序添加语音邮件系统 </td></tr><tr><td>134.android.permission.ACCOUNT_MANAGER</td><td>允许程序获取账户验证信息，主要为GMail账户信息，只有系统级进程才能访问的权限 </td></tr><tr><td>135.android.permission.ACCESS_WIFI_STATE</td><td>允许程序获取当前WiFi接入的状态以及WLAN热点的信息 </td></tr><tr><td>136.android.permission.ACCESS_SURFACE_FLINGER</td><td>Android平台上底层的图形显示支持，一般用于游戏或照相机预览界面和底层模式的屏幕截图 </td></tr><tr><td>137.android.permission.ACCESS_NETWORK_STATE</td><td>允许程序获取网络信息状态，如当前的网络连接是否有效 </td></tr><tr><td>138.android.permission.ACCESS_MOCK_LOCATION</td><td>允许程序获取模拟定位信息，一般用于帮助开发者调试应用 </td></tr><tr><td>139.android.permission.ACCESS_LOCATION_EXTRA_COMMANDS</td><td>允许程序访问额外的定位提供者指令 </td></tr><tr><td>140.android.permission.ACCESS_FINE_LOCATION</td><td>允许程序通过GPS芯片接收卫星的定位信息 </td></tr><tr><td>141.android.permission.ACCESS_COARSE_LOCATION</td><td>允许程序通过WiFi或移动基站的方式获取用户错略的经纬度信息 </td></tr><tr><td>142.android.permission.ACCESS_CHECKIN_PROPERTIES</td><td>允许程序读取或写入登记check-in数据库属性表的权限</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;原文链接：&lt;a href=&quot;http://blog.csdn.net/ufo00001/article/details/69397256&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://blog.csdn.net/ufo00001/articl
      
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android运行时权限总结</title>
    <link href="http://yoursite.com/2018/06/22/android/Android%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9D%83%E9%99%90%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/22/android/Android运行时权限总结/</id>
    <published>2018-06-22T02:50:27.000Z</published>
    <updated>2018-06-22T03:50:52.271Z</updated>
    
    <content type="html"><![CDATA[<p>###1、android6.0以后的危险权限介绍<br>（注意：Android O  8.0对于权限更加严格，下面会说一下8.0）<br>android6.0以后有些危险权限需要手动去授权，就有了运行时权限的处理。下面的表格就是危险权限组：</p><table><thead><tr><th>权限组名</th><th>权限名</th></tr></thead><tbody><tr><td>CALENDAR  日历</td><td>READ_CALENDAR<br>WRITE_CALENDER</td></tr><tr><td>CAMERA      相机</td><td>CAMERA</td></tr><tr><td>CONTACTS 联系人</td><td>READ_CONTACTS<br>WRITE_CONTACTS<br>GET_ACCOUNTS</td></tr><tr><td>LOCATION  定位</td><td>ACCESS_FINE_LOCATION<br>ACCESS_COARSE_LOCATION</td></tr><tr><td>MICROPHONE 麦克风</td><td>RECORD_AUDIO</td></tr><tr><td>PHONE 电话</td><td>READ_PHONE_STATE<br>CALL_PHONE<br>READ_CALL_LOG<br>WRITE_CALL_LOG<br>ADD_VOICEMAIL<br>USE_SIP<br>PROCESS_OUTGOING_CALLS</td></tr><tr><td>SENSORS 传感器</td><td>BODY_SENSORS</td></tr><tr><td>SMS  短信</td><td>Short Message Service<br>SEND_SMS<br>RECEIVE_SMS<br>READ_SMS<br>RECEIVE_WAP_PUSH<br>RECEIVE_MMS</td></tr><tr><td>STORAGE 数据存储</td><td>READ_EXTRAL_STRORAGE<br>WRITE_EXTERNAL_STORAGE</td></tr></tbody></table><p>申请权限时：<br>1、在清单文件中声明权限（如果不在这张表中，声明完就可以了）<br>2、如果在这张表中的权限需要手动来申请</p><p>这些权限6.0以后需要手动申请，，每一个权限组中的权限只要有一个权限同意授权了，整个权限组中的权限就不用重复申请了。<br><strong>如果如果查看所有的权限，请参考：<a href="https://segmentfault.com/a/1190000012259370" target="_blank" rel="noopener">https://segmentfault.com/a/1190000012259370</a></strong></p><p>###2、运行时权限申请过程：<br>传统的申请过程是：<br>1、在AndroidManifest文件中添加需要的权限。<br>2、检查权限是否授权<br>3、申请权限<br>4、处理授权的结果</p><p>一步步来：<br><strong>1、首先在请单文件中声明，这个不用说</strong><br><strong>2、检查权限是否授权</strong></p><pre><code>if (ContextCompat.checkSelfPermission(thisActivity,            Manifest.permission.READ_CONTACTS)    != PackageManager.PERMISSION_GRANTED) {    //没有授权，编写申请权限代码}else{//已经授权，执行操作代码}    </code></pre><p>   基本上调用checkSelfPermission()函数传入权限参数，返回的结果又两个：<br>如果是已授权的权限，该方法返回结果是 PackageManager.PERMISSION_GRANTED 常量为 0，<br>如果是未授权的权限，该方法返回结果是 PackageManager.PERMISSION_DENIED 常量为 -1。<br>这样就可以判断是否已经授权，来进行下一步的操作。</p><p><strong>3、如果没有授权，需要申请权限</strong><br>    ActivityCompat.requestPermissions(thisActivity,<br>                new String[]{Manifest.permission.READ_CONTACTS},<br>                MY_PERMISSIONS_REQUEST_READ_CONTACTS);<br>  这是一个异步的方法，第一个参数是Context；第二个参数是需要申请的权限的字符串数组（这个是支持同时申请多个权限，系统会逐个询问是否授权）；第三个参数为请求码requestCode，主要用于回调的时候检测。</p><p><strong>4、处理权限申请的回调结果</strong><br>重写Activity或者fragment的 onRequestPermissionsResul()方法<br>      //权限回调方法<br>    @Override<br>    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>        super.onRequestPermissionsResult(requestCode, permissions, grantResults);</p><pre><code>    switch (requestCode){        case 0:            //grantResults数组存储的申请的返回结果，            //PERMISSION_GRANTED 表示申请成功            if (grantResults.length&gt;0&amp;&amp;grantResults[0]== PackageManager.PERMISSION_GRANTED){                //授权成功，                //这里写相应的 操作代码            }else{                //授权失败，可以简单提示用户                Toast.makeText(this, &quot;没有授权继续操作&quot;, Toast.LENGTH_SHORT).show();            }            break;        case 1:            //同上            break;        default:            break;    }}这里稍微说一下，申请的时候是一个一个的申请的话，每次申请都有一个请求码，这里的grantResults数组就只有一个值，所以都是grantResults[0]来和PERMISSION_GRANTED来进行比较如果是一次申请多个权限，grantResults数组返回的值就不止一个，但是，直接遍历它就行，只要全部满足条件才算申请成功，才能进行相应的操作一般的写法是：通过if判断权限是否申请，没有申请，把它加到一个集合里面，把所有的权限都判断一遍以后，去遍历这个集合，只要有一个没有申请的，就需、要去申请权限，    把这个集合转为数组，传到requestPermissions的第二个参数，然后就处理相应 结果就可以了，遍历grantResults数组，判断是不是全部满足条件</code></pre><p>###3、EasyPermissions的使用<br>GitHub地址：<a href="https://github.com/googlesamples/easypermissions" target="_blank" rel="noopener">https://github.com/googlesamples/easypermissions</a><br>   EasyPermissions是谷歌封装的一个运行时权限申请的库，简化了操作的过程。<br>使用过程： 没有什么先后顺序，下面没有按这个顺序。这么做是可以的，当然还有其他的使用方法</p><blockquote><p>1、builde gradle中依赖<br>2、清单文件中声明权限<br>3、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions来<br>4、通过hasPermissions检查权限，或者原生的也行，然后去申请权限<br>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法，成功或失败<br>6、在成功或者失败方法中编写要具体做的事。</p></blockquote><p>GitHub地址：<br><strong>(1)依赖库</strong><br>    dependencies {<br>        compile ‘pub.devrel:easypermissions:1.0.1’<br>    }</p><p><strong>(2)再在清单文件中声明要申请的危险权限</strong><br>如果不声明的话，直接在代码中写也能申请成功，但是好想不会弹出询问框，直接就申请了</p><p><strong>(3)申请权限</strong><br>可以直接申请<br>    EasyPermissions.requestPermissions(<br>                        MainActivity.this,<br>                        “申请权限”,<br>                        0,<br>                        Manifest.permission.WRITE_EXTERNAL_STORAGE,<br>                        Manifest.permission.RECORD_AUDIO);<br>最好还是检查一下权限是否申请：<br><strong>EasyPermissions.hasPermissions(Context context, @NonNull String… perms)</strong>方法来检测一个或者多个权限是否被允许，第二个参数是个可变数组，可以申请多个<br>    String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};<br>    if (EasyPermissions.hasPermissions(this, perms)) {</p><pre><code>    // 已经申请过权限，做想做的事} else {    // 没有申请过权限，现在去申请    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),            RC_CAMERA_AND_LOCATION, perms);}</code></pre><p>下面来说一个申请权限这个方法：<br>EasyPermissions.requestPermissions():<img src="/img/bVZBii" alt="图片描述"></p><p>requestPermissions() 一般用这个四个参数的就可以<br>第一个参数：Context对象<br>第二个参数：权限弹窗上的文字提示语。告诉用户，这个权限用途。<br>第三个参数：这次请求权限的唯一标识请求码，code。<br>第四个参数 : 一些系列的权限。<br>   这里说一下第二个参数，不是第一次申请系统默认弹出的提示语，而是，我们拒绝后，再次点击申请弹出的对话框，，显示我们设置的提示语，下面有两个按钮，确认和取消，我就不贴图了。</p><p>还有六个参数的，多了两个参数就是，修改我们上面那个确认和取消的字样，你可以干成yes 和no. </p><p><strong>4、重写onRequestPermissionsResult()方法，把执行操作给easyPermissions    </strong><br>一行代码就搞定了<br>     @Override<br>    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {<br>        super.onRequestPermissionsResult(requestCode, permissions, grantResults);<br>        EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);<br>    }</p><p><strong>5、实现EasyPermissions.PermissionCallbacks接口，重写两个方法</strong><br>    public class MainActivity extends AppCompatActivity implements EasyPermissions.PermissionCallbacks {</p><pre><code>@Overrideprotected void onCreate(Bundle savedInstanceState) {    super.onCreate(savedInstanceState);    setContentView(R.layout.activity_main);}@Overridepublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {    super.onRequestPermissionsResult(requestCode, permissions, grantResults);    // 把执行结果的操作给EasyPermissions    EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this);}@Override //申请成功时调用public void onPermissionsGranted(int requestCode, List&lt;String&gt; list) {    //请求成功执行相应的操作    比如，举个例子    switch (requestCode){        case 0:            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();            break;        case 1:            Toast.makeText(this, &quot;已获取WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;, Toast.LENGTH_SHORT).show();            break;    }}@Override //申请失败时调用public void onPermissionsDenied(int requestCode, List&lt;String&gt; list) {    // 请求失败，执行相应操作}}</code></pre><p>接下来就要说一下成功或者失败后的操作了： 申请成功就直接做该做的事就行了，没啥。<br>申请如果失败了，这时候有个方法出现了EasyPermissions.somePermissionPermanentlyDenied(this, perms)<br>这个方法是谷歌建议的。就是在我们点了不在询问并拒绝，会弹出对话框，告诉用户这个权限时干嘛的，很重要，建议不要拒绝哈哈<br>比如这样：  </p><pre><code>@Overridepublic void onPermissionsDenied(int requestCode, List&lt;String&gt; perms) {if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {    new AppSettingsDialog.Builder(this).build().show();    //弹出个对话框}</code></pre><p>}                 </p><p>当然我们可以定制一下这个对话框：<br>    @Override<br>    public void onPermissionsDenied(int requestCode, List<string> perms) {<br>        //处理权限名字字符串<br>        StringBuffer sb = new StringBuffer();<br>        for (String str : perms){<br>            sb.append(str);<br>            sb.append(“\n”);<br>        }<br>        sb.replace(sb.length() - 2,sb.length(),””);</string></p><pre><code>    switch (requestCode){        case 0:            Toast.makeText(this, &quot;已拒绝权限&quot; + perms.get(0), Toast.LENGTH_SHORT).show();            break;        case 1:            Toast.makeText(this, &quot;已拒绝WRITE_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE权限&quot;+ perms.get(0), Toast.LENGTH_SHORT).show();            break;    }    if (EasyPermissions.somePermissionPermanentlyDenied(this, perms)) {        Toast.makeText(this, &quot;已拒绝权限&quot; + sb + &quot;并不再询问&quot; , Toast.LENGTH_SHORT).show();        new AppSettingsDialog                .Builder(this)                .setRationale(&quot;此功能需要&quot; + sb + &quot;权限，否则无法正常使用，是否打开设置&quot;)                .setPositiveButton(&quot;是&quot;)                .setNegativeButton(&quot;否&quot;)                .build()                .show();    }}</code></pre><p><strong>6、(可选)@AfterPermissionGranted()注解</strong></p><p>使用 AfterPermissioonGranted 注解。这是可选的，但是提供出来是为了方便。如果所有的请求的权限都被授予了，被注解的方法将会被执行，这样做是为了简化通常的请求权限成功之后再调用方法的流程。同时也可以在onPermissionsGranted 的回调中添加逻辑操作：<br>比如官网上的这个实例代码：<br>这里的方法名可以自己取，主要是权限都申请完，就调用这个方法，执行里面的操作。<br>其实就相当于在onPermissionsGranted()调用这个方法而已:</p><pre><code>@AfterPermissionGranted(RC_CAMERA_AND_LOCATION)private void methodRequiresTwoPermission() {String[] perms = {Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION};if (EasyPermissions.hasPermissions(this, perms)) {    // Already have permission, do the thing    // ...} else {    // Do not have permissions, request them now    EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale),            RC_CAMERA_AND_LOCATION, perms);}}</code></pre><p>基本上介绍完了</p><p>###4、android 8.0运行时权限<br>对于针对Android O的应用，此行为已被纠正。系统只会授予应用明确请求的权限。然而一旦用户为应用授予某个权限，则所有后续对该权限组中权限的请求都将被自动批准。</p><p>例如，假设某个应用在其清单中列出READ_EXTERNAL_STORAGE和WRITE_EXTERNAL_STORAGE。应用请求READ_EXTERNAL_STORAGE，并且用户授予了该权限，如果该应用针对的是API级别24或更低级别，系统还会同时授予WRITE_EXTERNAL_STORAGE，因为该权限也属于STORAGE权限组并且也在清单中注册过。如果该应用针对的是Android O，则系统此时仅会授予READ_EXTERNAL_STORAGE，不过在该应用以后申请WRITE_EXTERNAL_STORAGE权限时，系统会立即授予该权限，而不会提示用户。<br><strong>注意：如果使用了没有授权的权限，会崩溃的</strong></p><p>所以对于8.0权限，我们要做的处理，是尽量把所用到的危险权限全部申请。但是有的权限在不同版本出现，所以要兼容不同的版本，所以要加一个版本的判断。</p><blockquote><p>归根结底：android M (6.0)以后，申请权限组一个，即表示整个权限组可以用，所以我们干脆，只要api 版本大于23（6.0）,我们申请的权限就是申请整个权限组。这样就兼容了android8.0——————-为了省事的话可以用AndPermission这个第三方框架，或者自己封装一个。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###1、android6.0以后的危险权限介绍&lt;br&gt;（注意：Android O  8.0对于权限更加严格，下面会说一下8.0）&lt;br&gt;android6.0以后有些危险权限需要手动去授权，就有了运行时权限的处理。下面的表格就是危险权限组：&lt;/p&gt;
&lt;table&gt;
&lt;the
      
    
    </summary>
    
      <category term="android" scheme="http://yoursite.com/categories/android/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags/android/"/>
    
  </entry>
  
</feed>
