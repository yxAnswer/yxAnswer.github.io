<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术成长之路</title>
  
  <subtitle>Simple technology</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-23T15:27:39.376Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>杨旭</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringBoot入门笔记12——springboot devtool热部署的使用</title>
    <link href="http://yoursite.com/2018/10/16/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B012%E2%80%94%E2%80%94devtool%E7%83%AD%E9%83%A8%E7%BD%B2%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/16/springboot/SpringBoot入门笔记12——devtool热部署的使用/</id>
    <published>2018-10-15T16:00:00.000Z</published>
    <updated>2018-10-23T15:27:39.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringBoot-热部署实战"><a href="#SpringBoot-热部署实战" class="headerlink" title="SpringBoot 热部署实战"></a>SpringBoot 热部署实战</h3><p>spring为开发者提供了一个名为spring-boot-devtools的模块来使Spring Boot应用支持热部署，提高开发者的开发效率，无需手动重启Spring Boot应用。</p><h4 id="热部署的原理"><a href="#热部署的原理" class="headerlink" title="热部署的原理"></a>热部署的原理</h4><p>深层原理是使用了两个ClassLoader，一个Classloader加载那些不会改变的类（第三方Jar包），另一个ClassLoader加载会更改的类，称为restart ClassLoader,这样在有代码更改的时候，原来的restart ClassLoader 被丢弃，重新创建一个restart ClassLoader，由于需要加载的类相比较少，所以实现了较快的重启时间。</p><h4 id="如何使用devtool"><a href="#如何使用devtool" class="headerlink" title="如何使用devtool"></a>如何使用devtool</h4><p>springboot 使用devtool特别简单，首先看官网的地址</p><p><a href="https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools</a> </p><p>在项目的pom.xml文件下添加依赖，</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//核心依赖包</span></span><br><span class="line"><span class="params">&lt;dependency&gt;</span>  </span><br><span class="line">  <span class="params">&lt;groupId&gt;</span>org.springframework.boot<span class="params">&lt;/groupId&gt;</span>  </span><br><span class="line">  <span class="params">&lt;artifactId&gt;</span>spring-boot-devtools<span class="params">&lt;/artifactId&gt;</span>  </span><br><span class="line">  <span class="params">&lt;optional&gt;</span>true<span class="params">&lt;/optional&gt;</span>  </span><br><span class="line"><span class="params">&lt;/dependency&gt;</span></span><br></pre></td></tr></table></figure><p>由于DevTools监视类路径资源，因此触发重新启动的唯一方法是更新类路径。导致更新类路径的方式取决于您使用的IDE。在eclipse中保存文件就会重启。idea中如果设置自动保存，每自动保存一次就会触发启动一次。</p><h4 id="记录条件评估中的更改"><a href="#记录条件评估中的更改" class="headerlink" title="记录条件评估中的更改"></a>记录条件评估中的更改</h4><p>默认情况下，每次应用程序重新启动时，都会记录一个显示条件评估增量的报告。该报告显示了在进行更改（例如添加或删除Bean以及设置配置属性）时对应用程序的自动配置所做的更改。</p><p>要禁用报告的日志记录，请设置以下属性：</p><p><code>spring.devtools.restart.log-condition-evaluation-delta=false</code></p><h3 id="不包括资源（Excluding-Resources）"><a href="#不包括资源（Excluding-Resources）" class="headerlink" title="不包括资源（Excluding Resources）"></a>不包括资源（Excluding Resources）</h3><p>某些资源在更改时不一定需要触发重启。例如，可以就地编辑Thymeleaf模板。默认情况下，更改/ META-INF / maven，/ META-INF / resources，/ resources，/ static，/ public或/ templates中的资源不会触发重新启动，但会触发实时重新加载。如果要自定义这些排除项，可以使用spring.devtools.restart.exclude属性。</p><p>例如，要仅排除/ static和/ public，您需要设置以下属性：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.devtools</span><span class="selector-class">.restart</span><span class="selector-class">.exclude</span>=static<span class="comment">/**,public/**</span></span><br></pre></td></tr></table></figure><p>如果要保留这些默认值并添加其他排除项，请改用<code>spring.devtools.restart.additional-exclude</code>属性。</p><h3 id="禁用重启"><a href="#禁用重启" class="headerlink" title="禁用重启"></a>禁用重启</h3><p>如果您不想使用重启功能，可以使用<code>spring.devtools.restart.enabled</code>属性将其禁用。在大多数情况下，您可以在<code>application.properties中</code>设置此属性（这样做仍会初始化重新启动的类加载器，但它不会监视文件更改）。</p><p>如果需要完全禁用重新启动支持（例如，因为它不能与特定库一起使用），则需要在调用SpringApplication.run（…）之前将spring.devtools.restart.enabled System属性设置为false，如如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.setProperty(<span class="string">"spring.devtools.restart.enabled"</span>, <span class="string">"false"</span>);</span><br><span class="line">SpringApplication.run(MyApp.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用触发器文件（Using-a-Trigger-File）"><a href="#使用触发器文件（Using-a-Trigger-File）" class="headerlink" title="使用触发器文件（Using a Trigger File）"></a>使用触发器文件（Using a Trigger File）</h4><p>这个应该很有用，创建一个触发器文件来进行热部署</p><p>如果使用不断编译已更改文件的IDE，则可能更喜欢仅在特定时间触发重新启动。为此，您可以使用“触发器文件”，这是一个特殊文件，当您想要实际触发重新启动检查时必须对其进行修改。更改文件只会触发检查，只有在Devtools检测到必须执行某些操作时才会重新启动。触发器文件可以手动更新，也可以使用IDE插件更新。</p><p>要使用触发器文件，请将<code>spring.devtools.restart.trigger-file</code>属性设置为触发器文件的路径。</p><p>您可能希望将<code>spring.devtools.restart.trigger</code>文件设置为全局设置，以便所有项目的行为方式相同</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>还有很多功能，还是看官方文档，用到的时候再去查。对于devtool的使用我觉得，使用eclipse 很简单，ctrl+s就可以了。对于使用Idea 兄弟我觉得使用触发器文件是个非常好的方式。</p><p>首先在application.properties配置文件下配置 触发器文件的路径，比如</p><p><code>spring.devtools.restart.trigger-file=trigger.txt</code></p><p>我们在resources文件夹的根目录创建了一个txt文件 trigger.txt</p><p>里面内容比如 version=1 其实没什么，，只要这个配置文件更改了，就会触发devtool去重新检查启动。</p><p>比如我们更改完我们的代码，想使用热部署，就把1改一下，比如改为2 这个时候就会自动重启。当然还可以用插件，自行百度吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SpringBoot-热部署实战&quot;&gt;&lt;a href=&quot;#SpringBoot-热部署实战&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 热部署实战&quot;&gt;&lt;/a&gt;SpringBoot 热部署实战&lt;/h3&gt;&lt;p&gt;spring为开发者提供了一
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记13——pageHelper分页插件使用</title>
    <link href="http://yoursite.com/2018/10/16/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B013%E2%80%94%E2%80%94pageHelper%20%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2018/10/16/springboot/SpringBoot入门笔记13——pageHelper 分页插件使用/</id>
    <published>2018-10-15T16:00:00.000Z</published>
    <updated>2018-10-23T15:37:45.401Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringBoot入门笔记13——pageHelper分页插件的使用"><a href="#SpringBoot入门笔记13——pageHelper分页插件的使用" class="headerlink" title="SpringBoot入门笔记13——pageHelper分页插件的使用"></a>SpringBoot入门笔记13——pageHelper分页插件的使用</h3><p>实现方式有好几种，无非就是 spring的还是springboot的，是注解的还是配置的。</p><p>比如：</p><p>1、引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页插件依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   2、增加配置文件</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBatisConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PageHelper <span class="title">pageHelper</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PageHelper pageHelper = <span class="keyword">new</span> PageHelper();</span><br><span class="line">        Properties p = <span class="keyword">new</span> Properties();</span><br><span class="line">        p.setProperty(<span class="string">"offsetAsPageNum"</span>,<span class="string">"true"</span>);</span><br><span class="line">        p.setProperty(<span class="string">"rowBoundsWithCount"</span>,<span class="string">"true"</span>);</span><br><span class="line">        p.setProperty(<span class="string">"reasonable"</span>,<span class="string">"true"</span>);</span><br><span class="line">        pageHelper.setProperties(p);</span><br><span class="line">        <span class="keyword">return</span> pageHelper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、包装类</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PageHelper.startPage(page, <span class="built_in">size</span>);</span><br><span class="line"></span><br><span class="line">PageInfo&lt;VideoOrder&gt; pageInfo = <span class="keyword">new</span> PageInfo&lt;&gt;(<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure><p>4、基本原理    </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="title">sqlsessionFactory</span> -&gt;</span> <span class="function"><span class="title">sqlSession</span>-&gt;</span> <span class="function"><span class="title">executor</span> -&gt;</span> mybatis sql statement</span><br><span class="line">通过mybatis plugin 增加拦截器，然后拼装分页</span><br><span class="line">org.apache.ibatis.plugin.Interceptor</span><br></pre></td></tr></table></figure><p>上面是一种，还有比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!--pagehelper--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#pagehelper</span></span><br><span class="line">pagehelper.<span class="attribute">helperDialect</span>=mysql</span><br><span class="line">pagehelper.<span class="attribute">reasonable</span>=<span class="literal">true</span></span><br><span class="line">pagehelper.<span class="attribute">supportMethodsArguments</span>=<span class="literal">true</span></span><br><span class="line">pagehelper.<span class="attribute">params</span>=count=countSql</span><br><span class="line"></span><br><span class="line">然后使用：</span><br><span class="line">PageHelper.startPage(page, size);</span><br><span class="line">PageInfo&lt;VideoOrder&gt; pageInfo = new PageInfo&lt;&gt;(list);</span><br></pre></td></tr></table></figure><p>总的来说使用过程就是，1、引入依赖 2、配置（其实也就是配置拦截器）3、PageHelper.startPage(page, size);<br>PageInfo<videoorder> pageInfo = new PageInfo&lt;&gt;(list); 两行代码，开启分页拦截，用pageInfo包装数据，然后用PageInfo再取出来就有了分页信息和数据。</videoorder></p><p>之所以没有详细的讲解每一步怎么使用，因为这个插件在github上面已经有很详细的中文文档了，不想再抄一遍了。</p><p><a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md" target="_blank" rel="noopener">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md</a></p><p>详细配置：</p><p><a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md" target="_blank" rel="noopener">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md</a></p><p>集成springboot</p><p><a href="https://github.com/abel533/MyBatis-Spring-Boot" target="_blank" rel="noopener">https://github.com/abel533/MyBatis-Spring-Boot</a></p><p>并且上面还有例子，不会用的时候查两遍就ok了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SpringBoot入门笔记13——pageHelper分页插件的使用&quot;&gt;&lt;a href=&quot;#SpringBoot入门笔记13——pageHelper分页插件的使用&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot入门笔记13——page
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记11——springboot定时任务和异步任务</title>
    <link href="http://yoursite.com/2018/10/15/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B011%E2%80%94%E2%80%94springboot%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/10/15/springboot/SpringBoot入门笔记11——springboot定时任务和异步任务/</id>
    <published>2018-10-14T16:00:00.000Z</published>
    <updated>2018-10-16T11:04:59.427Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Springboot-定时任务和异步任务"><a href="#Springboot-定时任务和异步任务" class="headerlink" title="Springboot 定时任务和异步任务"></a>Springboot 定时任务和异步任务</h3><h3 id="java-中常用的定时任务"><a href="#java-中常用的定时任务" class="headerlink" title="java 中常用的定时任务"></a>java 中常用的定时任务</h3><blockquote><p>1、常见定时任务 Java自带的java.util.Timer类<br>​            timer:配置比较麻烦，时间延后问题<br>​            timertask:不推荐<br>2、Quartz框架<br>​        配置更简单<br>​        xml或者注解<br>3、SpringBoot使用注解方式开启定时任务<br>​        1）启动类里面 @EnableScheduling开启定时任务，自动扫描<br>​        2）定时任务业务类 加注解 @Component被容器扫描<br>​        3）定时执行的方法加上注解 @Scheduled(fixedRate=2000) 定期执行一次</p></blockquote><p>其中Quartz可以用来做复杂的定时任务。SpringBoot 内部自带的定时任务使用更加简单方便。</p><h3 id="最简单的定时任务快速体验"><a href="#最简单的定时任务快速体验" class="headerlink" title="最简单的定时任务快速体验"></a>最简单的定时任务快速体验</h3><blockquote><p>在写这篇文章的时候，新建了一个项目studyf4用来存储接下来学习过程中写的demo，以便复习。</p><p>体验定时任务就三步：</p><p>1）启动类里面 @EnableScheduling开启定时任务，自动扫描<br>​        2）定时任务业务类 加注解 @Component被容器扫描<br>​        3）定时执行的方法加上注解 @Scheduled(fixedRate=2000) 定期执行一次</p></blockquote><p>看代码：</p><p>启动类：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableScheduling;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件名: MainApplication.java</span></span><br><span class="line"><span class="comment"> * 描述：启动类</span></span><br><span class="line"><span class="comment"> * Create by Google on 2018/10/15 22:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">@EnableScheduling</span> <span class="comment">//允许开启定时任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> MainApplication &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(MainApplication.<span class="keyword">class</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定时任务测试类：</p><p>TestTask:</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.study.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件名: TestTask.java</span></span><br><span class="line"><span class="comment"> * 描述：定时任务类业务类</span></span><br><span class="line"><span class="comment"> * Create by Google on 2018/10/15 22:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@Component</span><span class="comment">//次注解可以被springboot扫描到</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestTask &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每一秒执行一次</span></span><br><span class="line">    <span class="keyword">@Scheduled</span>(fixedDelay = <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> sum()&#123;</span><br><span class="line">        i++;</span><br><span class="line">        SimpleDateFormat sf=<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd hh:mm:ss"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"定时任务执行了"</span>+i+<span class="string">"次"</span>+sf.format(<span class="keyword">new</span> Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看输出结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">定时任务执行了294次2018<span class="selector-tag">-10-15</span> 10<span class="selector-pseudo">:53</span><span class="selector-pseudo">:36</span></span><br><span class="line">定时任务执行了295次2018<span class="selector-tag">-10-15</span> 10<span class="selector-pseudo">:53</span><span class="selector-pseudo">:37</span></span><br><span class="line">定时任务执行了296次2018<span class="selector-tag">-10-15</span> 10<span class="selector-pseudo">:53</span><span class="selector-pseudo">:38</span></span><br><span class="line">定时任务执行了297次2018<span class="selector-tag">-10-15</span> 10<span class="selector-pseudo">:53</span><span class="selector-pseudo">:39</span></span><br><span class="line">定时任务执行了298次2018<span class="selector-tag">-10-15</span> 10<span class="selector-pseudo">:53</span><span class="selector-pseudo">:40</span></span><br><span class="line">定时任务执行了299次2018<span class="selector-tag">-10-15</span> 10<span class="selector-pseudo">:53</span><span class="selector-pseudo">:41</span></span><br><span class="line">定时任务执行了300次2018<span class="selector-tag">-10-15</span> 10<span class="selector-pseudo">:53</span><span class="selector-pseudo">:42</span></span><br><span class="line">定时任务执行了301次2018<span class="selector-tag">-10-15</span> 10<span class="selector-pseudo">:53</span><span class="selector-pseudo">:43</span></span><br><span class="line">定时任务执行了302次2018<span class="selector-tag">-10-15</span> 10<span class="selector-pseudo">:53</span><span class="selector-pseudo">:44</span></span><br><span class="line">定时任务执行了303次2018<span class="selector-tag">-10-15</span> 10<span class="selector-pseudo">:53</span><span class="selector-pseudo">:45</span></span><br><span class="line">太多了不展示了，太简单了</span><br></pre></td></tr></table></figure><h3 id="定时任务稍微高级点的玩法"><a href="#定时任务稍微高级点的玩法" class="headerlink" title="定时任务稍微高级点的玩法"></a>定时任务稍微高级点的玩法</h3><h4 id="使用定时任务表达式"><a href="#使用定时任务表达式" class="headerlink" title="使用定时任务表达式"></a>使用定时任务表达式</h4><blockquote><pre><code>1、cron 定时任务表达式 @Scheduled(cron=&quot;*/1 * * * * *&quot;) 表示每秒</code></pre><p>​            1）crontab 工具  <a href="https://tool.lu/crontab/" target="_blank" rel="noopener">https://tool.lu/crontab/</a><br>​        2、fixedRate: 定时多久执行一次（上一次开始执行时间点后xx秒再次执行；）<br>​        3、fixedDelay: 上一次执行结束时间点后xx秒再次执行<br>​        4、fixedDelayString:  字符串形式，可以通过配置文件指定</p></blockquote><p>上面这几种使用方式在Scheduled源码中都有说明</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2002-2018 the original author or authors.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> org.springframework.scheduling.<span class="keyword">annotation</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="keyword">annotation</span>.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="keyword">annotation</span>.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="keyword">annotation</span>.Repeatable;</span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="keyword">annotation</span>.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="keyword">annotation</span>.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="keyword">annotation</span>.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An annotation that marks a method to be scheduled. Exactly one of</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@link</span> #cron()&#125;, &#123;<span class="doctag">@link</span> #fixedDelay()&#125;, or &#123;<span class="doctag">@link</span> #fixedRate()&#125;</span></span><br><span class="line"><span class="comment"> * attributes must be specified.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The annotated method must expect no arguments. It will typically have</span></span><br><span class="line"><span class="comment"> * a &#123;<span class="doctag">@code</span> void&#125; return type; if not, the returned value will be ignored</span></span><br><span class="line"><span class="comment"> * when called through the scheduler.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Processing of &#123;<span class="doctag">@code</span> <span class="doctag">@Scheduled</span>&#125; annotations is performed by</span></span><br><span class="line"><span class="comment"> * registering a &#123;<span class="doctag">@link</span> ScheduledAnnotationBeanPostProcessor&#125;. This can be</span></span><br><span class="line"><span class="comment"> * done manually or, more conveniently, through the &#123;<span class="doctag">@code</span> &lt;task:annotation-driven/&gt;&#125;</span></span><br><span class="line"><span class="comment"> * element or @&#123;<span class="doctag">@link</span> EnableScheduling&#125; annotation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This annotation may be used as a &lt;em&gt;meta-annotation&lt;/em&gt; to create custom</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;composed annotations&lt;/em&gt; with attribute overrides.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Mark Fisher</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Chris Beams</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableScheduling</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ScheduledAnnotationBeanPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Schedules</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable(Schedules.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scheduled &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A cron-like expression, extending the usual UN*X definition to include</span></span><br><span class="line"><span class="comment"> * triggers on the second as well as minute, hour, day of month, month</span></span><br><span class="line"><span class="comment"> * and day of week.  e.g. &#123;<span class="doctag">@code</span> "0 * * * * MON-FRI"&#125; means once per minute on</span></span><br><span class="line"><span class="comment"> * weekdays (at the top of the minute - the 0th second).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an expression that can be parsed to a cron schedule</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.scheduling.support.CronSequenceGenerator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String cron() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A time zone for which the cron expression will be resolved. By default, this</span></span><br><span class="line"><span class="comment"> * attribute is the empty String (i.e. the server's local time zone will be used).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a zone id accepted by &#123;<span class="doctag">@link</span> java.util.TimeZone#getTimeZone(String)&#125;,</span></span><br><span class="line"><span class="comment"> * or an empty String to indicate the server's default time zone</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.scheduling.support.CronTrigger#CronTrigger(String, java.util.TimeZone)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> java.util.TimeZone</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String zone() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the annotated method with a fixed period in milliseconds between the</span></span><br><span class="line"><span class="comment"> * end of the last invocation and the start of the next.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the delay in milliseconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">long fixedDelay() <span class="keyword">default</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the annotated method with a fixed period in milliseconds between the</span></span><br><span class="line"><span class="comment"> * end of the last invocation and the start of the next.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the delay in milliseconds as a String value, e.g. a placeholder</span></span><br><span class="line"><span class="comment"> * or a &#123;<span class="doctag">@link</span> java.time.Duration#parse java.time.Duration&#125; compliant value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String fixedDelayString() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the annotated method with a fixed period in milliseconds between</span></span><br><span class="line"><span class="comment"> * invocations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the period in milliseconds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">long fixedRate() <span class="keyword">default</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the annotated method with a fixed period in milliseconds between</span></span><br><span class="line"><span class="comment"> * invocations.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the period in milliseconds as a String value, e.g. a placeholder</span></span><br><span class="line"><span class="comment"> * or a &#123;<span class="doctag">@link</span> java.time.Duration#parse java.time.Duration&#125; compliant value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String fixedRateString() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of milliseconds to delay before the first execution of a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #fixedRate()&#125; or &#123;<span class="doctag">@link</span> #fixedDelay()&#125; task.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial delay in milliseconds</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">long initialDelay() <span class="keyword">default</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of milliseconds to delay before the first execution of a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #fixedRate()&#125; or &#123;<span class="doctag">@link</span> #fixedDelay()&#125; task.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the initial delay in milliseconds as a String value, e.g. a placeholder</span></span><br><span class="line"><span class="comment"> * or a &#123;<span class="doctag">@link</span> java.time.Duration#parse java.time.Duration&#125; compliant value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String initialDelayString() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1、cron（）的使用"><a href="#1、cron（）的使用" class="headerlink" title="1、cron（）的使用"></a>1、cron（）的使用</h4><p>网上的资料：</p><p>和linux 的cron差不多，比如<a href="https://tool.lu/crontab/" target="_blank" rel="noopener">https://tool.lu/crontab/</a> cron表达式在线工具</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Linux</span><br><span class="line"><span class="symbol">*</span>    <span class="symbol">*</span>    <span class="symbol">*</span>    <span class="symbol">*</span>    <span class="symbol">*</span>    <span class="symbol">*</span></span><br><span class="line">-    -    -    -    -    -</span><br><span class="line">|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    + year [optional]</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    +----- day of week (0 - 7) (Sunday=0 or 7)</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    +---------- month (1 - 12)</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">    +--------------- day of month (1 - 31)</span></span><br><span class="line">|<span class="string">    +-------------------- hour (0 - 23)</span></span><br><span class="line"><span class="string">+------------------------- min (0 - 59)</span></span><br><span class="line"></span><br><span class="line"><span class="string">Java(Spring)</span></span><br><span class="line"><span class="string">*    *    *    *    *    *    *</span></span><br><span class="line"><span class="string">-    -    -    -    -    -    -</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|</span><br><span class="line">|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    + year [optional]</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    +----- day of week (0 - 7) (Sunday=0 or 7)</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    +---------- month (1 - 12)</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">    </span>|<span class="string">    +--------------- day of month (1 - 31)</span></span><br><span class="line">|<span class="string">    </span>|<span class="string">    +-------------------- hour (0 - 23)</span></span><br><span class="line">|<span class="string">    +------------------------- min (0 - 59)</span></span><br><span class="line"><span class="string">+------------------------------ second (0 - 59)</span></span><br></pre></td></tr></table></figure><p>Cron表达式是一个字符串，字符串以5或6个空格隔开，分开工6或7个域，每一个域代表一个含义,Cron有如下两种语法 </p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Seconds Minutes Hours DayofMonth <span class="built_in">Month</span> DayofWeek <span class="built_in">Year</span> 或 </span><br><span class="line">Seconds Minutes Hours DayofMonth <span class="built_in">Month</span> DayofWeek</span><br></pre></td></tr></table></figure><p>执行顺序</p><blockquote><p>按顺序依次为：</p><p>秒（0~59）<br>分钟（0~59）<br>小时（0~23）<br>天（0~31）<br>月（0~11）<br>星期（1~7 1=SUN 或 SUN，MON，TUE，WED，THU，FRI，SAT）<br>年份(1970-2099)</p><p>Seconds:可出现,-  <em>  / 四个字符，有效范围为0-59的整数<br>Minutes:可出现,-  </em>  / 四个字符，有效范围为0-59的整数<br>Hours:可出现,-  <em>  / 四个字符，有效范围为0-23的整数<br>DayofMonth:可出现,-  </em>  / ? L W C八个字符，有效范围为0-31的整数<br>Month:可出现,-  <em>  / 四个字符，有效范围为1-12的整数或JAN-DEC<br>DayofWeek:可出现,-  </em>  / ? L C #四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推<br>Year:可出现,-  *  / 四个字符，有效范围为1970-2099年​ ​ </p></blockquote><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(1)*：表示匹配该域的任意值，假如在Minutes域使用*,即表示每分钟都会触发事件。   </span><br><span class="line">  </span><br><span class="line"><span class="section">(2)?:只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13  13 15 20 * ?,其中最后一位只能用？，而不能使用*，如果使用*表示不管星期几都会触发，实际上并不是这样。</span></span><br><span class="line"><span class="string">"?"</span> 与&#123;日期&#125;互斥，即意味着若明确指定&#123;日期&#125;触发，则表示&#123;星期&#125;无意义，以免引起冲突和混乱</span><br><span class="line">  </span><br><span class="line"><span class="section">(3)-:表示范围，例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次   </span></span><br><span class="line">  </span><br><span class="line">(4)/：表示起始时间开始触发，然后每隔固定时间触发一次，例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次.   </span><br><span class="line">  </span><br><span class="line"><span class="section">(5),:表示列出枚举值值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。   </span></span><br><span class="line">  </span><br><span class="line"><span class="section">(6)L:表示最后，只能出现在DayofWeek和DayofMonth域，如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。   </span></span><br><span class="line">  </span><br><span class="line"><span class="section">(7)W:表示有效工作日(周一到周五),只能出现在DayofMonth域，系统将在离指定日期的最近的有效工作日触发事件。例如：在 DayofMonth使用5W，如果5日是星期六，则将在最近的工作日：星期五，即4日触发。如果5日是星期天，则在6日触发；如果5日在星期一到星期五中的一天，则就在5日触发。另外一点，W的最近寻找不会跨过月份   </span></span><br><span class="line">  </span><br><span class="line"><span class="section">(8)LW:这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。   </span></span><br><span class="line">  </span><br><span class="line"><span class="section">(9)#:用于确定每个月第几个星期几，只能出现在DayofMonth域。例如在4#2，表示某月的第二个星期三。</span></span><br></pre></td></tr></table></figure><p>例子：</p><p>比如<code>@Scheduled(cron = &quot;*/30 * 7-22 * * *&quot;)</code></p><p>表示的是每天7点到22点之间，每隔30秒执行一次。</p><p>另外fixedRate和fixedDelay、 fixedDelayString  使用方式是一样的</p><p><code>@Scheduled（fixedRate=2000）</code></p><p><code>@Scheduled（fixedDelay=2000）</code></p><p>这两个的区别注意一下，fixedRate 是从上次开始执行时间算起，执行两秒后，再执行第二次</p><p>而fixedDelay是从上次结束执行时算起，执行两秒后，再执行第二次</p><p>fixedDelayString:  字符串形式，可以通过配置文件指定，比如：</p><p><code>@Scheduled(fixedDelayString=&quot;2000&quot;)</code> 我们可以再配置文件中指定定时的时间，然后再这里用字符串的方式引用。</p><h2 id="但是要注意的是："><a href="#但是要注意的是：" class="headerlink" title="但是要注意的是："></a>但是要注意的是：</h2><p><strong>spring的schedule值支持6个域的表达式，也就是不能设定年，如果超过六个则会报错 </strong> 看源码：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Parse the given pattern expression.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> parse(<span class="keyword">String</span> expression) <span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line"><span class="keyword">String</span>[] fields = StringUtils.tokenizeToStringArray(expression, <span class="string">" "</span>);</span><br><span class="line"><span class="keyword">if</span> (!areValidCronFields(fields)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="keyword">String</span>.format(</span><br><span class="line"><span class="string">"Cron expression must consist of 6 fields (found %d in \"%s\")"</span>, fields.length, expression));</span><br><span class="line">&#125;</span><br><span class="line">setNumberHits(<span class="keyword">this</span>.seconds, fields[<span class="number">0</span>], <span class="number">0</span>, <span class="number">60</span>);</span><br><span class="line">setNumberHits(<span class="keyword">this</span>.minutes, fields[<span class="number">1</span>], <span class="number">0</span>, <span class="number">60</span>);</span><br><span class="line">setNumberHits(<span class="keyword">this</span>.hours, fields[<span class="number">2</span>], <span class="number">0</span>, <span class="number">24</span>);</span><br><span class="line">setDaysOfMonth(<span class="keyword">this</span>.daysOfMonth, fields[<span class="number">3</span>]);</span><br><span class="line">setMonths(<span class="keyword">this</span>.months, fields[<span class="number">4</span>]);</span><br><span class="line">setDays(<span class="keyword">this</span>.daysOfWeek, replaceOrdinals(fields[<span class="number">5</span>], <span class="string">"SUN,MON,TUE,WED,THU,FRI,SAT"</span>), <span class="number">8</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.daysOfWeek.<span class="built_in">get</span>(<span class="number">7</span>)) &#123;</span><br><span class="line"><span class="comment">// Sunday can be represented as 0 or 7</span></span><br><span class="line"><span class="keyword">this</span>.daysOfWeek.<span class="built_in">set</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>.daysOfWeek.<span class="built_in">clear</span>(<span class="number">7</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">boolean</span> areValidCronFields(<span class="keyword">String</span>[] fields) &#123;</span><br><span class="line"><span class="keyword">return</span> (fields != <span class="keyword">null</span> &amp;&amp; fields.length == <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="各域支持的数据类型"><a href="#各域支持的数据类型" class="headerlink" title="各域支持的数据类型"></a>各域支持的数据类型</h4><pre><code>秒：可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数  分：可出现&quot;, - * /&quot;四个字符，有效范围为0-59的整数  时：可出现&quot;, - * /&quot;四个字符，有效范围为0-23的整数  每月第几天：可出现&quot;, - * / ? L W C&quot;八个字符，有效范围为0-31的整数  月：可出现&quot;, - * /&quot;四个字符，有效范围为1-12的整数或JAN-DEc  星期：可出现&quot;, - * / ? L C #&quot;四个字符，有效范围为1-7的整数或SUN-SAT两个范围。1表示星期天，2表示星期一， 依次类推</code></pre><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  * : 表示匹配该域的任意值，比如在秒*, 就表示每秒都会触发事件。；</span><br><span class="line"></span><br><span class="line">    ? : 只能用在每月第几天和星期两个域。表示不指定值，当2个子表达式其中之一被指定了值以后，为了避免冲突，需要将另一个子表达式的值设为“?”；</span><br><span class="line"></span><br><span class="line">    - : 表示范围，例如在分域使用5-20，表示从5分到20分钟每分钟触发一次  </span><br><span class="line"></span><br><span class="line">    / : 表示起始时间开始触发，然后每隔固定时间触发一次，例如在分域使用5/20,则意味着5分，25分，45分，分别触发一次.  </span><br><span class="line"></span><br><span class="line">    , : 表示列出枚举值。例如：在分域使用5,20，则意味着在5和20分时触发一次。  </span><br><span class="line"></span><br><span class="line">    L : 表示最后，只能出现在星期和每月第几天域，如果在星期域使用1<span class="type">L</span>,意味着在最后的一个星期日触发。  </span><br><span class="line"></span><br><span class="line">    W : 表示有效工作日(周一到周五),只能出现在每月第几日域，系统将在离指定日期的最近的有效工作日触发事件。注意一点，W的最近寻找不会跨过月份  </span><br><span class="line"></span><br><span class="line">    LW : 这两个字符可以连用，表示在某个月最后一个工作日，即最后一个星期五。  </span><br><span class="line"></span><br><span class="line">    # : 用于确定每个月第几个星期几，只能出现在每月第几天域。例如在1#3，表示某月的第三个星期日。</span><br></pre></td></tr></table></figure><h3 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h3><h4 id="简单的体验异步任务"><a href="#简单的体验异步任务" class="headerlink" title="简单的体验异步任务"></a>简单的体验异步任务</h4><p>1、首先在启动类里面添加注解<code>@EnableAsync //开启异步任务</code></p><p>2、在需要作为异步执行的类加上<code>@Component</code>标记组件被容器扫描</p><p>3、异步类或者方法上添加 <code>@Async</code>注解，表示这个类或者方法是一个异步的</p><p>4、在其他地方调用这些方法，所有的方法会异步执行。</p><p>注意点：</p><blockquote><pre><code>注意点：</code></pre><p>​        1）要把异步任务封装到类里面，不能直接写到Controller<br>​        2）增加Future<string> 返回结果 AsyncResult<string>(“task执行完成”);<br>​        3）如果需要拿到结果 需要判断全部的 task.isDone()<br>​    </string></string></p></blockquote><p>如果要返回结果，比如</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Async</span><br><span class="line"><span class="keyword">public</span> Future&lt;<span class="keyword">String</span>&gt; task3() throws InterruptedException &#123;</span><br><span class="line">      <span class="keyword">long</span> <span class="built_in">begin</span> = System.currentTimeMillis();</span><br><span class="line">      Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">      <span class="keyword">long</span> <span class="built_in">end</span> = System.currentTimeMillis();</span><br><span class="line">      System.out.<span class="built_in">println</span>(<span class="string">"任务3耗时---"</span>+(<span class="built_in">end</span>-<span class="built_in">begin</span>));</span><br><span class="line">      <span class="built_in">return</span> <span class="keyword">new</span> AsyncResult&lt;&gt;(<span class="string">"任务3"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Future<v>  返回异步的结果</v></p><p>AsyncResult&lt;&gt;</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;String&gt; stringFuture = asyncTask.task3()<span class="comment">;</span></span><br><span class="line">stringFuture.isDone()<span class="comment">;//表示是否执行完</span></span><br><span class="line">stringFuture.cancel()<span class="comment">;//是否取消</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Springboot-定时任务和异步任务&quot;&gt;&lt;a href=&quot;#Springboot-定时任务和异步任务&quot; class=&quot;headerlink&quot; title=&quot;Springboot 定时任务和异步任务&quot;&gt;&lt;/a&gt;Springboot 定时任务和异步任务&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记10——SpringBoot使用配置文件整合mybatis</title>
    <link href="http://yoursite.com/2018/10/07/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B010%E2%80%94%E2%80%94springboot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E5%90%88mytatis/"/>
    <id>http://yoursite.com/2018/10/07/springboot/SpringBoot入门笔记10——springboot配置文件整合mytatis/</id>
    <published>2018-10-06T16:00:00.000Z</published>
    <updated>2018-10-15T14:09:24.935Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Springboot使用配置文件的方式来整合mybatis"><a href="#Springboot使用配置文件的方式来整合mybatis" class="headerlink" title="Springboot使用配置文件的方式来整合mybatis"></a>Springboot使用配置文件的方式来整合mybatis</h3><p>mybatis 有两种使用方式，一种是配置文件xml的方式来进行使用，springboot整合mybatis，注解的方式简化  了这种方式，前面已经讲过了springboot如何通过注解的方式来增删改查，接下来，我们试一下使用配置文件的方式来进行增删改查的操作入门。</p><blockquote><p>这里先不详细讲解mybatis 的使用，只是介绍springboot 如何使用xml方式来进行操作，因为复杂的操作springboot已经替我们做了，如果我们还是写复杂了，那就不用springboot了。</p></blockquote><h4 id="springboot-整合mytais-步骤-–配置篇"><a href="#springboot-整合mytais-步骤-–配置篇" class="headerlink" title="springboot 整合mytais 步骤 –配置篇"></a>springboot 整合mytais 步骤 –配置篇</h4><p>1、添加mybatis 依赖</p><p>2、数据库配置</p><p>3、mapper的配置文件</p><p>4、编写mapper类和映射文件</p><h4 id="1、添加mytatis依赖"><a href="#1、添加mytatis依赖" class="headerlink" title="1、添加mytatis依赖"></a>1、添加mytatis依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入第三方数据源 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2、数据库配置"><a href="#2、数据库配置" class="headerlink" title="2、数据库配置"></a>2、数据库配置</h4><p>最简单的直接在application.properties配置文件中声明 数据库的地址 用户名密码等，还可以设置其他连接属性，这里就不说了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.type</span>=com<span class="selector-class">.alibaba</span><span class="selector-class">.druid</span><span class="selector-class">.pool</span><span class="selector-class">.DruidDataSource</span></span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.url</span>=jdbc:mysql:<span class="comment">//localhost:3306/movie?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.username</span>=root</span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.password</span>=<span class="number">112233</span></span><br></pre></td></tr></table></figure><p>以上配置好就可以连接数据库进行操作了</p><h4 id="3、Mapper-的配置文件"><a href="#3、Mapper-的配置文件" class="headerlink" title="3、Mapper 的配置文件"></a>3、Mapper 的配置文件</h4><p>xml方式使用mybatis，需要在application.properties中声明两个配置属性,例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#mybatis</span><br><span class="line">mybatis.mapper-locations= classpath:mybatis/mapper<span class="comment">/**/</span>*.xml</span><br><span class="line">mybatis.config-location= classpath:mybatis/mybatis-config.xml</span><br></pre></td></tr></table></figure><p><code>mybatis.mapper-locations</code> 表示mapper类映射的xml的位置，不然你写的那些sql都找不到，怎么使用</p><p><code>mybatis.config-location</code>表示mybatis的配置文件</p><p>以上配置如下结构：</p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/181009/4FDGggacie.png?imageslim" alt="mark"></p><p>简单的目录结构是这样的。和之前我们用注解的方式没什么区别，springboot使用配置文件只是service层或者是mapper层不一样。</p><p>首先，我们创建了UserMapper,这个接口类，里面声明了一些操作数据库的方法，然后再我们配置文件中<code>mybatis.mapper-locations</code>指定的位置创建相应的xml文件，然后里面编写 sql语句操作数据，进行映射。</p><p><code>mybatis-config.xml</code> 是配置mybatis的配置文件，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个可以去官方文档复制，然后改一改里面的<settings> 就好，上面的配置表示的是，mybatis 忽略大小写，避免驼峰命名法和数据库字段大小写不一致。</settings></p><h4 id="4、编写mapper类和映射xml文件"><a href="#4、编写mapper类和映射xml文件" class="headerlink" title="4、编写mapper类和映射xml文件"></a>4、编写mapper类和映射xml文件</h4><p>比如UserMapper.class ,一个最简单的方法</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有用户</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;User&gt; getAll();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，编写相应的xml映射文件UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span> <span class="meta">?&gt;</span></span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAll"</span> <span class="attr">resultType</span>=<span class="string">"com.mybatis.domain.User"</span>&gt;</span></span><br><span class="line">    select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里只是一个简单的实例，使用起来也很简单。</p><p><code>namespace</code> 表示当前xml是映射的那个mapper类，后面要跟上<strong>全类名</strong></p><p>然后是增删改查，<insert>,<delete>,<update>,<select></select></update></delete></insert></p><p>使用方法都差不多，就是先声明这个操作标签，比如 </p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">"getAll"</span> resultType=<span class="string">"com.mybatis.domain.User"</span>&gt;</span><br><span class="line">    <span class="comment">//id 表示mapper类中的方法，getAll()方法</span></span><br><span class="line">    <span class="comment">// resultType 是这个方法的返回值类型，返回对象或者集合时，表明类的全类名。</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure><p>最后再 <select> 标签中编写sql语句，</select></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * <span class="keyword">from</span> user  <span class="comment">//这是一个简单的实例 </span></span><br><span class="line"></span><br><span class="line">当然还有很多复杂的，和注解方式一样，也是用#&#123;&#125;，#&#123;&#125; 的这种方式去一一对应数据库和实体类</span><br></pre></td></tr></table></figure><h4 id="5、添加-mapper注解或者使用-mapperScan的方式，让springboot扫描到mapper类"><a href="#5、添加-mapper注解或者使用-mapperScan的方式，让springboot扫描到mapper类" class="headerlink" title="5、添加@mapper注解或者使用@mapperScan的方式，让springboot扫描到mapper类"></a>5、添加@mapper注解或者使用@mapperScan的方式，让springboot扫描到mapper类</h4><p>这一步操作什么时候都行，这里放到最后重点提醒，</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@SpringBootApplication</span></span><br><span class="line"><span class="variable">@MapperScan</span>(<span class="string">"com.mybatis.mapper"</span>)</span><br><span class="line">public class MainApplication &#123;</span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">static</span> <span class="selector-tag">void</span> <span class="selector-tag">main</span>(String[] args) &#123;</span><br><span class="line">        <span class="selector-tag">SpringApplication</span><span class="selector-class">.run</span>(MainApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，在启动类里面，加入@mapperScan注解，指明所有的mapper，这样只写一次就可以了。</p><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>本篇只是记录了下springboot的xml使用方式，</p><p>重点：</p><p>1、application.properties 配置文件中声明位置</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#mybatis</span><br><span class="line">mybatis.mapper-locations= classpath:mybatis/mapper<span class="comment">/**/</span>*.xml</span><br><span class="line">mybatis.config-location= classpath:mybatis/mybatis-config.xml</span><br></pre></td></tr></table></figure><p>2、把原来卸载mapper类中的注解 sql语句，写到 xml的配置文件中</p><p>3、<code>namespace</code>  <code>select</code>等标签的意思要熟悉，    至于映射的全类名和 方法名就可以了</p><p>详细的内容由于时间原因，不想写了，因为官方文档都有，忘记了就去官方文档找</p><p><a href="http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html" target="_blank" rel="noopener">http://www.mybatis.org/mybatis-3/zh/sqlmap-xml.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Springboot使用配置文件的方式来整合mybatis&quot;&gt;&lt;a href=&quot;#Springboot使用配置文件的方式来整合mybatis&quot; class=&quot;headerlink&quot; title=&quot;Springboot使用配置文件的方式来整合mybatis&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记09——属性配置文件详解以及多环境配置</title>
    <link href="http://yoursite.com/2018/10/07/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B009%E2%80%94%E2%80%94%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/10/07/springboot/SpringBoot入门笔记09——属性配置文件详解以及多环境配置/</id>
    <published>2018-10-06T16:00:00.000Z</published>
    <updated>2018-10-06T17:42:44.389Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SpringBoot的外部配置"><a href="#SpringBoot的外部配置" class="headerlink" title="SpringBoot的外部配置"></a>SpringBoot的外部配置</h3><p>  Spring Boot允许将配置外部化（externalize） ，这样你就能够在不同的环境下使用相同的代码。你可以使用properties文件，YAML文件，环境变量和命令行参数来外部化配置。使用@Value注解，可以直接将属性值注入到beans中，然后通过Spring的 Environment 抽象或通过 @ConfigurationProperties 绑定到结构化对象来<br>访问。<br>Spring Boot设计了一个非常特别的 PropertySource 顺序，以允许对属性值进行合理的覆盖，属性会以如下的顺序进行设值：</p><ol><li><p>home目录下的devtools全局设置属性（ ~/.spring-bootdevtools.properties ，如果devtools激活） 。</p></li><li><p>测试用例上的@TestPropertySource注解。</p></li><li><p>测试用例上的@SpringBootTest#properties注解。</p></li><li><p>命令行参数</p></li><li><p>来自 SPRING_APPLICATION_JSON 的属性（环境变量或系统属性中内嵌的内联JSON） 。</p></li><li><p>ServletConfig 初始化参数。</p></li><li><p>ServletContext 初始化参数。</p></li><li><p>来自于 java:comp/env 的JNDI属性。</p></li><li><p>Java系统属性（System.getProperties()） 。</p></li><li><p>操作系统环境变量。</p></li><li><p>RandomValuePropertySource，只包含 random.* 中的属性。</p></li><li><p>没有打进jar包的Profile-specific应用属性（ application-{profile}.properties 和YAML变量） 。</p></li><li><p>打进jar包中的Profile-specific应用属性（ application-{profile}.properties 和YAML变量） 。</p></li><li><p>没有打进jar包的应用配置（ application.properties 和YAML变量） 。</p></li><li><p>打进jar包中的应用配置（ application.properties 和YAML变量） 。</p></li><li><p>@Configuration 类上的 @PropertySource 注解。</p></li><li><p>默认属性（使用 SpringApplication.setDefaultProperties 指定） 。<br>下面是具体的示例，假设你开发一个使用name属性的 @Component ：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.*</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.*</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> </span>&#123;</span><br><span class="line"><span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;name&#125;</span>"</span>)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以将一个 application.properties 放到应用的classpath下，为 name 提供一个合适的默认属性值。当在新的环境中运行时，可以在jar包外提供一个 application.properties 覆盖 name 属性。对于一次性的测试，你可以使用特定的命令行开关启动应用（比如， java -jar app.jar –name=”Spring” ） 。<br>注 SPRING_APPLICATION_JSON 属性可以通过命令行的环境变量设置，例如，在一个UNIX shell中可以这样：<br><code>$ SPRING_APPLICATION_JSON=&#39;{&quot;foo&quot;:{&quot;bar&quot;:&quot;spam&quot;}}&#39; java -jar myapp.jar</code><br>本示例中，如果是Spring Environment ，你可以以 foo.bar=spam 结尾；如果在一个系统变量中，可以提供作为 spring.application.json 的JSON字符串：<br><code>$ java -Dspring.application.json=&#39;{&quot;foo&quot;:&quot;bar&quot;}&#39; -jar myapp.jar</code><br>或命令行参数：<br><code>$ java -jar myapp.jar --spring.application.json=&#39;{&quot;foo&quot;:&quot;bar&quot;}&#39;</code><br>或作为一个JNDI变量<code>java:comp/env/spring.application.json</code> 。</p></li></ol><h3 id="自定义属性与加载"><a href="#自定义属性与加载" class="headerlink" title="自定义属性与加载"></a>自定义属性与加载</h3><p>我们在使用Spring Boot的时候，通常也需要定义一些自己使用的属性，我们可以如下方式直接定义：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com<span class="selector-class">.text</span><span class="selector-class">.name</span><span class="selector-class">.name</span>=姓名</span><br><span class="line">com<span class="selector-class">.text</span><span class="selector-class">.title</span>=Spring Boot标题</span><br></pre></td></tr></table></figure><p>然后通过<code>@Value(&quot;${属性名}&quot;)</code>注解来加载对应的配置属性，具体如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlogProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;com.text.name&#125;</span>"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;com.text.title&#125;</span>"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略getter和setter</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数间的引用"><a href="#参数间的引用" class="headerlink" title="参数间的引用"></a>参数间的引用</h2><p>在<code>application.properties</code>中的各个参数之间也可以直接引用来使用，就像下面的设置：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">web.upload-path=<span class="string">D:</span>/images</span><br><span class="line">spring.resources.<span class="keyword">static</span>-locations=<span class="string">classpath:</span><span class="string">file:</span>$&#123;web.upload-path&#125;</span><br></pre></td></tr></table></figure><p>spring.resources.static-locations参数引用了上文中定义的web.upload-path属性</p><h2 id="使用随机数"><a href="#使用随机数" class="headerlink" title="使用随机数"></a>使用随机数</h2><p>在一些情况下，有些参数我们需要希望它不是一个固定的值，比如密钥、服务端口等。Spring Boot的属性配置文件中可以通过<code>${random}</code>来产生int值、long值或者string字符串，来支持属性的随机值。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//随机字符串</span></span><br><span class="line">my.secret=$&#123;random.value&#125;</span><br><span class="line"><span class="comment">//随机int</span></span><br><span class="line">my.number=$&#123;random.int&#125;</span><br><span class="line"><span class="comment">//随机long</span></span><br><span class="line">my.bignumber=$&#123;random.long&#125;</span><br><span class="line"><span class="comment">//10以内的随机数</span></span><br><span class="line">my<span class="selector-class">.number</span><span class="selector-class">.less</span><span class="selector-class">.than</span><span class="selector-class">.ten</span>=$&#123;random.int(<span class="number">10</span>)&#125;</span><br><span class="line"><span class="comment">//1024--65535</span></span><br><span class="line">my<span class="selector-class">.number</span><span class="selector-class">.in</span><span class="selector-class">.range</span>=$&#123;random<span class="selector-class">.int</span>[<span class="number">1024</span>,<span class="number">65536</span>]&#125;</span><br></pre></td></tr></table></figure><p>random.int* 语法是 OPEN value (,max) CLOSE ，此处 OPEN，CLOSE 可以是任何字符，并且 value，max 是整数。如果提供 max ，那么 value 是最小值， max 是最大值（不包含在内） 。 </p><h2 id="通过命令行设置属性值"><a href="#通过命令行设置属性值" class="headerlink" title="通过命令行设置属性值"></a>通过命令行设置属性值</h2><p>默认情况下， SpringApplication 会将所有命令行配置参数（以’–’开头，比如 –server.port=9000 ） 转化成一个 property ，并将其添加到SpringEnvironment 中。连续的两个减号<code>--</code>就是对<code>application.properties</code>中的属性值进行赋值的标识。正如以上章节提过的，命令行属性总是优先于其他属性源。</p><p>通过命令行来修改属性值固然提供了不错的便利性，但是通过命令行就能更改应用运行的参数，那岂不是很不安全？是的，所以Spring Boot也贴心的提供了屏蔽命令行访问属性的设置，只需要这句设置就能屏蔽：<code>SpringApplication.setAddCommandLineProperties(false)</code>。</p><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><blockquote><p>  SpringApplication 将从以下位置加载 application.properties 文件，并把<br>它们添加到Spring Environment 中：</p><ol><li>当前目录下的 /config 子目录。</li><li>当前目录。</li><li>classpath下的 /config 包。</li><li>classpath根路径（root） 。<br>该列表是按优先级排序的（列表中位置高的路径下定义的属性将覆盖位置低的） 。</li></ol></blockquote><p>我们在开发Spring Boot应用时，通常同一套程序会被应用和安装到几个不同的环境，比如：开发、测试、生产等。其中每个环境的数据库地址、服务器端口等等配置都会不同，如果在为不同环境打包时都要频繁修改配置文件的话，那必将是个非常繁琐且容易发生错误的事。</p><p>对于多环境的配置，各种项目构建工具或是框架的基本思路是一致的，通过配置多份不同环境的配置文件，再通过打包命令指定需要打包的内容之后进行区分打包，Spring Boot也不例外，或者说更加简单。</p><p>在Spring Boot中多环境配置文件名需要满足<code>application-{profile}.properties</code>的格式，其中<code>{profile}</code>对应你的环境标识，比如：</p><ul><li><code>application-dev.properties</code>：开发环境</li><li><code>application-test.properties</code>：测试环境</li><li><code>application-prod.properties</code>：生产环境</li></ul><p>至于哪个具体的配置文件会被加载，需要在<code>application.properties</code>文件中通过<code>spring.profiles.active</code>属性来设置，其值对应<code>{profile}</code>值。</p><p>如：<code>spring.profiles.active=test</code>就会加载<code>application-test.properties</code>配置文件内容</p><p>下面，以不同环境配置不同的服务端口为例，进行样例实验。</p><ul><li>针对各环境新建不同的配置文件<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code></li><li>在这三个文件均都设置不同的<code>server.port</code>属性，如：dev环境设置为1111，test环境设置为2222，prod环境设置为3333</li><li>application.properties中设置<code>spring.profiles.active=dev</code>，就是说默认以dev环境设置</li><li>测试不同配置的加载<ul><li>执行<code>java -jar xxx.jar</code>，可以观察到服务端口被设置为<code>1111</code>，也就是默认的开发环境（dev）</li><li>执行<code>java -jar xxx.jar --spring.profiles.active=test</code>，可以观察到服务端口被设置为<code>2222</code>，也就是测试环境的配置（test）</li><li>执行<code>java -jar xxx.jar --spring.profiles.active=prod</code>，可以观察到服务端口被设置为<code>3333</code>，也就是生产环境的配置（prod）</li></ul></li></ul><p>按照上面的实验，可以如下总结多环境的配置思路：</p><ul><li><code>application.properties</code>中配置通用内容，并设置<code>spring.profiles.active=dev</code>，以开发环境为默认配置</li><li><code>application-{profile}.properties</code>中配置各个环境不同的内容</li><li>通过命令行方式去激活不同环境的配置</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;SpringBoot的外部配置&quot;&gt;&lt;a href=&quot;#SpringBoot的外部配置&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot的外部配置&quot;&gt;&lt;/a&gt;SpringBoot的外部配置&lt;/h3&gt;&lt;p&gt;  Spring Boot允许将配置
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记08——Mybatis逆向工程之IDE自动生成实体类</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B008%E2%80%94%E2%80%94Mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E4%B9%8BIDE%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%AE%9E%E4%BD%93%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记08——Mybatis逆向工程之IDE自动生成实体类/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:26:32.082Z</updated>
    
    <content type="html"><![CDATA[<h3 id="这里只是介绍一种最简单的逆向生成java实体类的方法"><a href="#这里只是介绍一种最简单的逆向生成java实体类的方法" class="headerlink" title="这里只是介绍一种最简单的逆向生成java实体类的方法"></a>这里只是介绍一种最简单的逆向生成java实体类的方法</h3><p>mybatis提供了一种逆向工程，网上有很多，大多通过配置文件的方式和依赖的方式，稍微有一点繁琐。我们的Intellij idea  已经集成了自动生成pojo类的工具，直接使用更加方便。</p><h3 id="idea连接数据库"><a href="#idea连接数据库" class="headerlink" title="idea连接数据库"></a>idea连接数据库</h3><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180910/GidBI2FB89.png?imageslim" alt="mark"><br><img src="http://oima95jt3.bkt.clouddn.com/blog/180910/3E1c6480jg.png?imageslim" alt="mark"></p><h3 id="修改生成脚本"><a href="#修改生成脚本" class="headerlink" title="修改生成脚本"></a>修改生成脚本</h3><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180910/lfdD1D59hc.png?imageslim" alt="mark"></p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180910/KFDfciab9E.png?imageslim" alt="mark"><br><strong>当然很重要的一点要记得修改我们的包名，图片忘记标记了</strong></p><h3 id="快速生成实体类"><a href="#快速生成实体类" class="headerlink" title="快速生成实体类"></a>快速生成实体类</h3><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180910/LflB6GAi6i.png?imageslim" alt="mark"><br>然后选择相应的文件路径，打开自动生成的javabean ，可以稍作修改，直接拷贝到相应包中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;这里只是介绍一种最简单的逆向生成java实体类的方法&quot;&gt;&lt;a href=&quot;#这里只是介绍一种最简单的逆向生成java实体类的方法&quot; class=&quot;headerlink&quot; title=&quot;这里只是介绍一种最简单的逆向生成java实体类的方法&quot;&gt;&lt;/a&gt;这里只是介绍一种
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Springboot入门笔记01——环境配置</title>
    <link href="http://yoursite.com/2018/10/06/springboot/Springboot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B001%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/10/06/springboot/Springboot入门笔记01——环境配置/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:25:21.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Springboot-简介"><a href="#Springboot-简介" class="headerlink" title="Springboot 简介"></a>Springboot 简介</h3><blockquote><p>简化Spring应用开发的一个框架；<br>整个Spring技术栈的一个大整合；<br>J2EE开发的一站式解决方案；</p></blockquote><p>###1、SpringBoot2.x依赖环境和版本新特性说明</p><blockquote><p>1、依赖版本jdk8以上, Springboot2.x用JDK8, 因为底层是 Spring framework5,<br>​    2、安装maven最新版本，maven3.2以上版本，下载地址 ：<a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a><br>​    3、springbootGitHub地址：<a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot</a><br>​    4、springboot官方文档：<a href="https://spring.io/guides/gs/spring-boot/" target="_blank" rel="noopener">https://spring.io/guides/gs/spring-boot/</a><br>我自己使用的是 jdk8、maven 3.5.3、 开发工具为 Intellij Idea </p></blockquote><p>###2、基础环境搭建和maven、idea的使用（从头搭建一个简单的web项目）</p><p>####1、安装jdk 1.8，配置环境变量</p><p>####2、安装maven 3.5.3 ,配置环境变量</p><p>####3、idea的相关配置，比如jdk，maven等（ 这些就不讲了）</p><p>####4、创建一个简单的maven 管理的web 项目</p><p>#####（1）创建一个maven 项目，File——New——Project<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/1BfBhK5eag.png?imageslim" alt="mark"></p><p>#####(2)定义项目的坐标，然后一直next 到finish<br>groupId：项目名称，定义为组织名+项目名，一般用公司的域名反写，这个按照一定规范些就行<br>artifactid :这个一般是项目名或者模块的名称<br>version:当前项目或者moudle 的版本号<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/cliJ5JAgcb.png?imageslim" alt="mark"><br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/CeeDCFLim6.png?imageslim" alt="mark"></p><p>#####（3）maven 项目结构说明<br>使用maven创建的工程我们称他们为maven 工程，maven 工程具有一定的目录规范，如下：<br>src/main/java—— 存放项目的.java 文件<br>src/main/resources —— 存放项目资源文件，如spring，mybatis配置文件<br>src/test/java —— 存放所有单元测试的.java 文件，如 JUnit测试类<br>src/test/resources —— 测试用的资源文件<br>target —— 项目输出位置，编译后的.class 文件会输出到此目录<br>pom.xml —— maven 项目的核心配置文件  *<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/jLb9IAJ5KC.png?imageslim" alt="mark"></p><p>#####（4）为刚才创建的项目添加web 支持，因为刚才我们创建的是一个普通的maven 项目，如果想要被外部访问，需要添加web支持。<br>快捷键 ctrl+alt+shift+s   或者file ——project structure打开 项目的设置面板<br>左边选择moudle, 然后点击+号，添加web 支持<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/HhA47gj54h.png?imageslim" alt="mark"><br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/F8H19h78kE.png?imageslim" alt="mark"></p><p>根据自己项目实际情况，其实就是指定到src \main\webapp下<br>需要修改资源文件路径为  D:\ideWorkspace\practice\src\main\webapp<br>修改描述文件路径为 D:\ideWorkspace\practice\src\main\webapp\WEB-INF\web.xml<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/I7dece74k2.png?imageslim" alt="mark"></p><p>可以看到现在下面有个警告，我们还没有添加Artifacts，可以直接点击右边的创建按钮，也可以再左侧点击Artifacts进行添加<br>如下：<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/e2a58j0216.png?imageslim" alt="mark"><br>选择自己刚才创建的，点击ok 就添加完成了。<br><strong>这样一个web项目就创建完成了，在这里我们不再演示创建一个servlet 和一个静态页面，去访问资源了。由于我们是springboot 学习，接下来就要直接上springboot了，以上是对maven 项目的一个简单介绍以及 idea 的使用。 （传统web项目以及tomcat、servlet 等可以自行百度）</strong></p><p>###3、springboot 项目的环境搭建以及包的依赖<br>可以参考官方的例子，这里只简单说下步骤<br><a href="https://spring.io/guides/gs/rest-service/" target="_blank" rel="noopener">https://spring.io/guides/gs/rest-service/</a><br>修改pom.xml文件 添加相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.gongsi.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>practice<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--依赖父工程，使用springboot必须加--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--添加相关依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用Spring MVC构建Web（包括RESTful）应用程序的入门者。使用Tomcat作为默认嵌入式容器--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用JUnit，Hamcrest和Mockito等库来测试Spring Boot应用程序的--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.jayway.jsonpath<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>json-path<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>spring-releases<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repo.spring.io/libs-release<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">pluginRepository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引入依赖后，工程就已经是一个springboot的项目了，可以写相关代码，用内置的tomcat运行</p><p><strong>关于maven 库的依赖</strong><br><a href="http://mvnrepository.com/" target="_blank" rel="noopener">http://mvnrepository.com/</a><br>可以从这个仓库进行搜索，然后把相关的xml依赖 添加到 pom.xml下的  dependencies 标签下</p><p><strong>更快的创建springboot项目的方法</strong><br><a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a><br>相当于是个在线的插件，输入相关参数，下载配置好的springboot 工程<br><strong>更更方便的创建springboot项目的方法</strong><br>使用idea 已经内置的创建插件<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/im9L66je2B.png?imageslim" alt="mark"><br>点击创建，然后选择 spring initializr 然后一步步填写相关信息，进行创建。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Springboot-简介&quot;&gt;&lt;a href=&quot;#Springboot-简介&quot; class=&quot;headerlink&quot; title=&quot;Springboot 简介&quot;&gt;&lt;/a&gt;Springboot 简介&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;简化Spring应用开发的
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记03——文件上传</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B003%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记03——文件上传/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:27:07.530Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><blockquote><p>文件上传主要用到了MultipartFile 这个类，它源自 SpringMVC ，可以提高对文件保存的效率</p></blockquote><p>1、创建FileController 开始写文件上传的接口</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.controller;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.domain.JsonData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> final <span class="keyword">String</span>  filePath=<span class="string">"D:/ideWorkspace/practice/src/main/resources/static/images/"</span>;</span><br><span class="line">    @RequestMapping(<span class="string">"/v1/upload"</span>)</span><br><span class="line">    <span class="keyword">public</span> Object upLoad(@RequestParam(<span class="string">"head_img"</span>) MultipartFile  file)&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//判空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file.getSize()&gt;<span class="number">100000</span>)&#123;</span><br><span class="line">            <span class="comment">//大小限制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前文件名</span></span><br><span class="line">        <span class="keyword">String</span> name = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//后缀名</span></span><br><span class="line">        <span class="keyword">String</span> substring = name.substring(name.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        <span class="comment">//重新生成唯一文件名</span></span><br><span class="line">        <span class="keyword">String</span> fileName = UUID.randomUUID() + substring;</span><br><span class="line">        File <span class="keyword">new</span><span class="type">File</span>=<span class="keyword">new</span> <span class="type">File</span>(filePath+fileName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(<span class="keyword">new</span><span class="type">File</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="type">JsonData</span>(<span class="string">"1"</span>,<span class="string">"ok"</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="type">JsonData</span>(<span class="string">"0"</span>,<span class="string">"上传失败"</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类中，还是用我们最简单的注解方式@RestController  +@RequestMapping<br>然后指定访问路径，主要的区别在于，方法参数使用的是MultipartFile   这个类型，然后给参数指定了一个key.<br>（1）先对文件进行一些基本的校验，是否为空，文件大小限制<br>（2）然后获取文件现在名称，通过UUID或者时间戳 重命名这个文件<br>（3） 重点来了，通过 file.transferTo(newFile); 这行代码将文件写入到相应位置，MultipartFile 对象的transferTo方法，用于文件保存（效率和操作比原先用FileOutStream方便和高效）<br>（4）对结果进行一些处理和返回状态</p><p>2、这里用到了一个JsonData的 java类，代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonData</span> <span class="title">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = <span class="number">4185756603091671454</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String  result;</span><br><span class="line">    <span class="keyword">private</span> String  message;</span><br><span class="line">    <span class="keyword">private</span> Object  <span class="keyword">data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JsonData(String result, String message, Object <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getResult() &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setResult(String result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String getMessage() &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setMessage(String message) &#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> void setData(Object <span class="keyword">data</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里只是一个简单的实例，实际开发中根据规范和实际需求制定。然后以json的方式返回。</p><p>3、测试接口<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180831/AbhIhh43Bl.png?imageslim" alt="mark"><br><img src="http://oima95jt3.bkt.clouddn.com/blog/180831/Ea885D3dAA.png?imageslim" alt="mark"></p><p>当然也可以多文件进行上传，处理都一样都是使用了 MutipartFile  ,通过transferTo进行写入</p><p>4、如何对上传大小进行限制<br>可以再启动类中进行配置。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.MultipartConfigFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.MultipartConfigElement;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置文件大小限制</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function">MultipartConfigElement <span class="title">multipartConfigElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MultipartConfigFactory factory = <span class="keyword">new</span> MultipartConfigFactory();</span><br><span class="line">        <span class="comment">//单个文件最大  -----这里的硬编码应该放到配置文件中进行配置，这里只演示下</span></span><br><span class="line">        factory.setMaxFileSize(<span class="string">"10240KB"</span>); <span class="comment">//KB,MB  </span></span><br><span class="line">        <span class="comment">/// 设置总上传数据总大小  </span></span><br><span class="line">        factory.setMaxRequestSize(<span class="string">"1024000KB"</span>);</span><br><span class="line">        <span class="function"><span class="keyword">return</span> factory.<span class="title">createMultipartConfig</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在启动类中加入上面代码，，自定义相关大小限制。常规应该把大小的描述放到配置文件中，然后进行引用，这里只是一个示范。<br>但是这只是在本地，上传到项目文件夹。。接下来应该打包程序，指定文件路径。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件上传&quot;&gt;&lt;a href=&quot;#文件上传&quot; class=&quot;headerlink&quot; title=&quot;文件上传&quot;&gt;&lt;/a&gt;文件上传&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;文件上传主要用到了MultipartFile 这个类，它源自 SpringMVC ，可以提高对文件
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Springboot入门笔记05——springboot 注解整合mybatis</title>
    <link href="http://yoursite.com/2018/10/06/springboot/Springboot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B005%E2%80%94%E2%80%94springboot%20%E6%B3%A8%E8%A7%A3%E6%95%B4%E5%90%88mybatis/"/>
    <id>http://yoursite.com/2018/10/06/springboot/Springboot入门笔记05——springboot 注解整合mybatis/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:27:26.506Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、springboot-持久化数据方式介绍"><a href="#1、springboot-持久化数据方式介绍" class="headerlink" title="1、springboot 持久化数据方式介绍"></a>1、springboot 持久化数据方式介绍</h3><blockquote><p>1、原始java访问数据库<br>​        开发流程麻烦<br>​        （1）注册驱动/加载驱动<br>​            Class.forName(“com.mysql.jdbc.Driver”)<br>​        （2）建立连接<br>​            Connection con = DriverManager.getConnection(“jdbc:mysql://localhost:3306/dbname”,”root”,”root”);<br>​        （3）创建Statement<br>​        （4）执行SQL语句<br>​        （5）处理结果集<br>​          (6)关闭连接，释放资源<br>​    2、apache dbutils框架<br>​        比上一步简单点<br>​        官网:<a href="https://commons.apache.org/proper/commons-dbutils/" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-dbutils/</a><br>​    3、jpa框架<br>​        spring-data-jpa<br>​        jpa在复杂查询的时候性能不是很好<br>​    4、Hiberante   解释：ORM：对象关系映射Object Relational Mapping<br>​        企业大都喜欢使用hibernate<br>​    5、Mybatis框架<br>​        互联网行业通常使用mybatis<br>​        不提供对象和关系模型的直接映射,半ORM</p></blockquote><p>###springboot 集成mybatis 的步骤<br>1、pom.xml添加依赖<br>2、配置文件配置 jdbc  数据库连接地址、以及数据源等等<br>3、分包进行分层，编码结构清晰<br>4、创建表和相应的pojo类<br>5、实现mapper或者叫dao 层的功能编码，sql注入<br>6、实现service层的编码，调用dao层实现操作数据库<br>7、实现controller 层的代码，编写外部调用接口，内部调用service层方法处理mapper层的数据<br>8、添加@MapperScan注解，运行程序，调试bug,可能会修改配置比如mysql serverTimezone的影响，测试</p><p>####1、首先来添加mybatis的相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入starter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">&lt;!-- MySQL的JDBC驱动包--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 引入第三方数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>####2、修改配置文件application.properties<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#可以自动识别,所以下面这行可写可不写</span><br><span class="line"><span class="selector-id">#spring</span><span class="selector-class">.datasource</span><span class="selector-class">.driver-class-name</span> =com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span></span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.driver-class-name</span> =com<span class="selector-class">.mysql</span><span class="selector-class">.cj</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span></span><br><span class="line">#数据库的连接地址，用户名，密码</span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.url</span>=jdbc:mysql:<span class="comment">//localhost:3306/movie?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.username</span> =root</span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.password</span> =<span class="number">112233</span></span><br><span class="line">#数据源</span><br><span class="line">#如果不使用默认的数据源 （com<span class="selector-class">.zaxxer</span><span class="selector-class">.hikari</span><span class="selector-class">.HikariDataSource</span>）</span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.type</span> =com<span class="selector-class">.alibaba</span><span class="selector-class">.druid</span><span class="selector-class">.pool</span><span class="selector-class">.DruidDataSource</span></span><br></pre></td></tr></table></figure></p><p>这里简单讲解下配置文件：<br>1、首先，声明jdbc的驱动这个可以写也可以不写，springboot 会自动识别当前的jdbc,这里仅供参考<br>2、配置好数据库的连接地址：修改为自己的本地或者远程数据库，这里注意，如果你的表里有time字段，最好设置下serverTimezone ，不设置的话 可能会有错误。。然后是数据库用户名和密码<br>3、数据源：这个可以改也可以不改，默认的是com.zaxxer.hikari.HikariDataSource；但是如果想改的话也可以改为<br>淘宝的这个。</p><p>###3、分包<br>一般写代码都要进行分层，这里最起码我们简单分一下包</p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180831/Ca5EdLj1BH.png?imageslim" alt="mark"><br>一个简单的项目，打开分为这么几个包，<br>controller：主要方我们的api接口<br>domain:放一些实体类，同javaBean 、pojo 都可以，是我们的module层。<br>mapper:是存放所有访问数据库的接口，同dao.<br>service :业务逻辑层，我们的业务代码都放在这，service 又可以分为 接口 和实现类 两个包进行分类<br>utils:是我们的工具类<br>大家可以根据自己的习惯进行分一下包，然后就开始创建相关类了。</p><p>###4、创建表和相应的pojo类<br>创建表，就打开数据库创建就行了。不管用什么方法，图形界面，命令行都可以。我们这里创建了一个movie数据库，一个user表。 有 id 、name 、create_time、age、phone   这几个字段<br>可以这样建  mysql -u root -p   密码 连接数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> movie;</span><br><span class="line"><span class="keyword">use</span> movie;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span>(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">32</span>) primary <span class="keyword">key</span> auto_increment,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">32</span>) ,</span><br><span class="line">age  <span class="built_in">int</span>(<span class="number">32</span>),</span><br><span class="line">phone <span class="built_in">varchar</span>(<span class="number">32</span>),</span><br><span class="line">create_time  datetime</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后创建相应的javaBean User,字段类型一定要和表相对应</p><p>###5、实现mapper或者叫dao 层的功能编码，sql注入<br>在mapper包下创建 UserMapper 类，主要来操作User这个表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.mapper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mybatis.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Options;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 访问数据库的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 注意： 这里的#&#123;&#125;内容必须和User 类的属性一一对应；推荐使用#&#123;&#125;取值，不要用$&#123;&#125;,因为存在注入的风险</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">"INSERT INTO USER(name,phone,create_time,age) VALUES(#&#123;name&#125;,#&#123;phone&#125;,#&#123;createTime&#125;,#&#123;age&#125;)"</span>)</span><br><span class="line">    <span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>, keyProperty = <span class="string">"id"</span>, keyColumn = <span class="string">"id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Insert（）注解可以将sql 映射user类，然后将数据写入user表   sql语句 values() 值以 #{属性名} 进行一一匹配<br>@Options 配置，主键id是自增长的，我们如果要想把id映射到user类中，需要表明使用主键true，属性名和列名<br>//useGeneratedKeys=true 表示使用主键，true就可以返回。  keyProperty java对象的属性；keyColumn表示数据库的字段<br>mapper方法写完后，就可以写service 层方法进行调用</p><p>###6、实现service层的编码，调用dao层实现操作数据库<br>一般先创建一个UserService 的接口，声明操作数据库的方法，比如需要有增删改查的方法，就在接口中声明。<br>然后创建一个impl 包，用来存放具体实现service的实现类 。比如现在创建一个 UserServiceImpl.java 类。<br>这两个类的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.service;</span><br><span class="line"><span class="keyword">import</span> com.mybatis.domain.User;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">//其他方法。</span></span><br><span class="line">    <span class="comment">//删</span></span><br><span class="line">    <span class="comment">//改</span></span><br><span class="line">    <span class="comment">//查</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserServiceImpl ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.service.impl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mybatis.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.mybatis.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> com.mybatis.service.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userMapper.insert(user);</span><br><span class="line">        <span class="keyword">int</span> id = user.getId();</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>UserServiceImpl 首先实现了 UserService 接口，重写了操作方法<br>有两个注解 @Service 和 @Autowired   通过注解声明，springmvc就能扫描到这个类，@Autowired封装了自动装配UserMapper  。调用 mapper层的insert() 方法进行注入，还可以拿到id </p><p>###7、实现controller 层的代码，编写外部调用接口，内部调用service层方法处理mapper层的数据</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mybatis.domain.JsonData;</span><br><span class="line"><span class="keyword">import</span> com.mybatis.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.mybatis.service.impl.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/api/v1/user"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserServiceImpl userService;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述: user 保存接口</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">"add"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object add() &#123;</span><br><span class="line"></span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setAge(<span class="number">22</span>);</span><br><span class="line">        user.setCreateTime(new Date());</span><br><span class="line">        user.setName(<span class="string">"我最帅"</span>);</span><br><span class="line">        user.setPhone(<span class="string">"17615881722"</span>);</span><br><span class="line">        int id = userService.add(user);</span><br><span class="line">        <span class="keyword">return</span> JsonData.buildSuccess(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面一样，@RestController<br>@RequestMapping指定路径<br>方法get post根据情况自己定，这里就简单的将一个user对象写入user 表， 至于结果返回 自己定吧。</p><p>###8、添加@MapperScan注解，运行主程序，进行测试，调用接口，查看数据库表。<br><strong>必须在主程序中添加注解@MapperScan(“com.mybatis.mapper”)</strong><br>告诉程序要扫描mapper包，不然写的dao层的代码无法找到</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mybatis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.mybatis.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionApplication</span>  &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)&#123;</span><br><span class="line">        SpringApplication.run(ActionApplication.<span class="keyword">class</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、springboot-持久化数据方式介绍&quot;&gt;&lt;a href=&quot;#1、springboot-持久化数据方式介绍&quot; class=&quot;headerlink&quot; title=&quot;1、springboot 持久化数据方式介绍&quot;&gt;&lt;/a&gt;1、springboot 持久化数据方式
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记02——简单http接口开发实战</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B002%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95http%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记02——简单http接口开发实战/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:27:15.852Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h3><p>###一、创建一个简单的接口，返回json<br>1、创建相应的包和类<br>​     一般我们会分包进行创建，我这里简单创建了一个controller 的包，里面写相关的接口controller<br>​     然后再test包下我创建了一个Application 类，这个名词可以自己起。这个类是运行springboot的入口，需要进行配置下。<br>​     <img src="http://oima95jt3.bkt.clouddn.com/blog/180830/Kab0Ld50cf.png?imageslim" alt="mark"><br>​     Application 代码如下：<br>​<br>2、Application  类代码讲解<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args)&#123;</span><br><span class="line">        SpringApplication.run(Application.<span class="keyword">class</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>@SpringBootApplication 注解：</p><blockquote><p>@SpringBootApplication注解一般放在项目的一个启动类上，用来把启动类注入到容器中，用来定义容器扫描的范围，用来加载classpath环境中一些bean<br>@SpringBootApplication = @Configuration+@EnableAutoConfiguration+@ComponentScan<br>springboot 把这几个注解整合了。只需要写一个就可以</p></blockquote><p>然后在main方法中添加SpringApplication.run(Application.class,args); 来启动应用程序</p><p>3、TestController类讲解</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试用的集合</span></span><br><span class="line">    Map&lt;String,Object&gt; params=new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一个接口测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/test"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object getTest(String name)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"name"</span>,name);</span><br><span class="line">        <span class="keyword">return</span>  params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到了两个注解，@RestController、 @RequestMapping<br><strong>@RestController and @RequestMapping是springMVC的注解，不是springboot特有的    </strong><br><strong>（1）@RestController</strong><br>@RestController 是spring4 新加入的注解，相当于@Controller +@ResponseBody  两个注解的功能和<br>@Controller的作用表示该类是一个控制器，可以接受用户的输入并调用模型和视图去完成用户的需求。控制器本身不输出也不处理任何东西。 我们写的接口也就是控制器里面的方法。<br>@ResponseBody 表示 请求以json映射的方式返回。<br>所以@RestController 注解的类就可以 接受请求——返回json<br><strong>2、@RequestMapping</strong><br> 这个注解可以加载类和方法上，我理解是表示资源的映射吧，为web请求指明路径。可以定义不同的映射规则<br> 注解在方法上表示当前方法时一个web请求的处理方法，注解在类上，应该是常用的请求地址或路由啥的</p><p>上面方法中再@RequestMapping(“/test”)  方法中的”/test” 就是外部访问的接口地址，暂时我们没有指定请求方法<br>这样外部就能通过 <a href="http://localhost:8080/test?name=张三" target="_blank" rel="noopener">http://localhost:8080/test?name=张三</a>  来进行调用这个接口。<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180830/a2miG3Dbid.png?imageslim" alt="mark"></p><p>###二、 get、post请求实战<br><strong>(1) get请求实战</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从路径中取值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cityID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(path = <span class="meta-string">"/&#123;city_id&#125;/&#123;user_id&#125;"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object getUserID(<span class="meta">@PathVariable(<span class="meta-string">"city_id"</span>)</span> String cityID,</span><br><span class="line">                            <span class="meta">@PathVariable(<span class="meta-string">"user_id"</span>)</span> String userID) &#123;</span><br><span class="line"></span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"cityID"</span>, cityID);</span><br><span class="line">        params.put(<span class="string">"userID"</span>, userID);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试<span class="doctag">@GetMapping</span>注解，以get方式请求接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(value = <span class="meta-string">"/v1/getUser"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object getMappingTest(String id, String name) &#123;</span><br><span class="line"></span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"name"</span>, name);</span><br><span class="line">        params.put(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试，设置参数默认值，别名、以及是否必传参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/v1/getUser1"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object getMyappingTest1(<span class="meta">@RequestParam(defaultValue = <span class="meta-string">"888"</span>,name = <span class="meta-string">"uid"</span>)</span> String id, <span class="meta">@RequestParam(required = true)</span> String username)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"username"</span>, username);</span><br><span class="line">        params.put(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：bean对象传参</span></span><br><span class="line"><span class="comment">     * 注意：1、注意需要指定http头为 content-type为application/json</span></span><br><span class="line"><span class="comment">     * 2、使用body传输数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/v1/save_user"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object saveUser(<span class="meta">@RequestBody</span> User user)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"user"</span>, user);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：测试获取http头信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> accessToken</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/v1/get_header"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object getHeader(<span class="meta">@RequestHeader(<span class="meta-string">"access_token"</span>)</span> String accessToken, String id)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"access_token"</span>, accessToken);</span><br><span class="line">        params.put(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以HttpServletRequest获取所有请求数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(<span class="meta-string">"/v1/test_request"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object testRequest(HttpServletRequest request)&#123;</span><br><span class="line">        </span><br><span class="line">        params.clear();</span><br><span class="line">        String id = request.getParameter(<span class="string">"id"</span>);</span><br><span class="line">        params.put(<span class="string">"id"</span>,id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(<span class="meta-string">"/v1/login"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object login(<span class="meta">@RequestParam(required = true)</span> String  userName, <span class="meta">@RequestParam(required = true)</span>String passWrod)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"name"</span>,userName);</span><br><span class="line">        params.put(<span class="string">"pwd"</span>,passWrod);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@PostMapping(<span class="meta-string">"/v1/class"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object loginTest(User user)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"name"</span>,user.getName);</span><br><span class="line">        params.put(<span class="string">"pwd"</span>,user.getPassword);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping(<span class="meta-string">"/v1/put"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object put(String id)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(<span class="meta-string">"/v1/del"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object del(String id)&#123;</span><br><span class="line">        params.clear();</span><br><span class="line">        params.put(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="keyword">return</span> params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">注解简介：<span class="number">1</span>、单一参数<span class="meta">@RequestMapping(path = <span class="meta-string">"/&#123;id&#125;"</span>, method = RequestMethod.GET)</span></span><br><span class="line"><span class="number">1</span>) <span class="keyword">public</span> String getUser(<span class="meta">@PathVariable</span> String id ) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>）<span class="meta">@RequestMapping(path = <span class="meta-string">"/&#123;depid&#125;/&#123;userid&#125;"</span>, method = RequestMethod.GET)</span> 可以同时指定多个提交方法</span><br><span class="line">getUser(<span class="meta">@PathVariable(<span class="meta-string">"depid"</span>)</span> String departmentID,<span class="meta">@PathVariable(<span class="meta-string">"userid"</span>)</span> String userid)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>）<span class="keyword">get</span>、post、put、delete四种注解的封装</span><br><span class="line"><span class="meta">@GetMapping</span> = <span class="meta">@RequestMapping(method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@PostMapping</span> = <span class="meta">@RequestMapping(method = RequestMethod.POST)</span></span><br><span class="line"><span class="meta">@PutMapping</span> = <span class="meta">@RequestMapping(method = RequestMethod.PUT)</span></span><br><span class="line"><span class="meta">@DeleteMapping</span> = <span class="meta">@RequestMapping(method = RequestMethod.DELETE)</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>）<span class="meta">@RequestParam(value = <span class="meta-string">"name"</span>, required = true)</span></span><br><span class="line">可以设置默认值，可以设置别名name=<span class="string">""</span>，可以设置是否必传 requeid=<span class="literal">true</span>或<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>)<span class="meta">@RequestBody</span> 请求体映射实体类,以json映射javaBean</span><br><span class="line">需要指定http头为 content-type为application/json charset=utf<span class="number">-8</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>）<span class="meta">@RequestHeader</span> 请求头，比如鉴权,可以获取请求头</span><br><span class="line"><span class="meta">@RequestHeader(<span class="meta-string">"access_token"</span>)</span> String accessToken</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>）HttpServletRequest request自动注入获取参数，可以拿到任何请求数据</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开始写代码&quot;&gt;&lt;a href=&quot;#开始写代码&quot; class=&quot;headerlink&quot; title=&quot;开始写代码&quot;&gt;&lt;/a&gt;开始写代码&lt;/h3&gt;&lt;p&gt;###一、创建一个简单的接口，返回json&lt;br&gt;1、创建相应的包和类&lt;br&gt;​     一般我们会分包进行创建，我
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记07——Mybatis增删改查以及事务示例，打印sql</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B007%E2%80%94%E2%80%94Mybatis%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5%E4%BB%A5%E5%8F%8A%E4%BA%8B%E5%8A%A1%E7%A4%BA%E4%BE%8B%EF%BC%8C%E6%89%93%E5%8D%B0sql/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记07——Mybatis增删改查以及事务示例，打印sql/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:26:39.329Z</updated>
    
    <content type="html"><![CDATA[<h3 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h3><p>1、实现打印sql语句以及切换数据源<br>2、springboot 整合mybatis增删改查实例<br>3、整合事务示例（简单事务介绍）</p><p>###1、实现打印sql语句以及切换数据源<br>（1）添加打印sql 配置<br>每次通过接口往数据库写入信息，如果我们想查看mybatis实际编译的sql语句，可以使用如下方法：<br>在配置文件application.properties 文件中添加如下代码<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#增加打印sql语句，一般用于本地开发测试</span><br><span class="line">mybatis<span class="selector-class">.configuration</span><span class="selector-class">.log-impl</span>=org<span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.logging</span><span class="selector-class">.stdout</span><span class="selector-class">.StdOutImpl</span></span><br></pre></td></tr></table></figure></p><p><img src="http://oima95jt3.bkt.clouddn.com/TIM%E6%88%AA%E5%9B%BE20180906102545.png?imageslim" alt="mark"><br>（2）切换数据源<br>可以再配置文件中设置数据源，默认使用的是HikariDataSource ，我们也可以改为 阿里巴巴的 DruidDataSource数据源<br>配置文件如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#数据源</span><br><span class="line">#如果不使用默认的数据源 （com<span class="selector-class">.zaxxer</span><span class="selector-class">.hikari</span><span class="selector-class">.HikariDataSource</span>）</span><br><span class="line">spring<span class="selector-class">.datasource</span><span class="selector-class">.type</span>=com<span class="selector-class">.alibaba</span><span class="selector-class">.druid</span><span class="selector-class">.pool</span><span class="selector-class">.DruidDataSource</span></span><br></pre></td></tr></table></figure></p><p>如果使用阿里巴巴的数据源 需要在pom文件中添加依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 引入第三方数据源 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>###2、springboot 整合mybatis增删改查实例</p><p>直接上代码：</p><p>####UserMapper类<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">package</span> <span class="selector-tag">code</span><span class="selector-class">.mapper</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">code</span><span class="selector-class">.domain</span><span class="selector-class">.User</span>;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.ibatis</span><span class="selector-class">.annotations</span>.*;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.List</span>;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">UserMapper</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Insert</span>(<span class="string">"insert into user(name,create_time,age,phone) values(#&#123;name&#125;,#&#123;createTime&#125;,#&#123;age&#125;,#&#123;phone&#125;)"</span>)</span><br><span class="line">    <span class="variable">@Options</span>(useGeneratedKeys = true,keyProperty = <span class="string">"id"</span>,keyColumn = <span class="string">"id"</span>)</span><br><span class="line">    int insert(User user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：查找全部</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@Select</span>(<span class="string">"SELECT * FROM user"</span>)</span><br><span class="line">    <span class="variable">@Results</span>(&#123;</span><br><span class="line">            <span class="variable">@Result</span>(column = <span class="string">"create_time"</span>,property = <span class="string">"createTime"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    List&lt;User&gt; getAll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable">@Select</span>(<span class="string">"SELECT * FROM user WHERE id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="variable">@Results</span>(&#123;</span><br><span class="line">            <span class="variable">@Result</span>(column = <span class="string">"create_time"</span>,property = <span class="string">"createTime"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    User findById(long id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：更新对象</span></span><br><span class="line"><span class="comment">     * @param user</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@Update</span>(<span class="string">"UPDATE user SET name=#&#123;name&#125; WHERE id =#&#123;id&#125;"</span>)</span><br><span class="line">    void update(User user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能描述：根据id删除用户</span></span><br><span class="line"><span class="comment">     * @param userId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="variable">@Delete</span>(<span class="string">"DELETE FROM user WHERE id =#&#123;userId&#125;"</span>)</span><br><span class="line">    void delete(long userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里用到了几个注解@Insert、 @Select 、@Update  、@Delete 看名字就能看出来是增删改查的操作，然后后面跟上sql语句，没什么难的。<br>还有一个注解要注意下@Results   ,当数据表的字段和 User 类的属性名称不完全一致的时候，需要说明下映射<br>比如这里，数据库user表是 create_time ,而user类使用的是驼峰命名，createTime,这个时候如果不添加映射，数据就写不进去。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Results</span>(&#123;</span><br><span class="line">            <span class="variable">@Result</span>(column = <span class="string">"create_time"</span>,property = <span class="string">"createTime"</span>)</span><br><span class="line">            <span class="comment">//这里可以添加多个字段的映射</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>当然还可以设置id，因为如果多个地方都用到，每次写一遍就太麻烦了，所以，就写一次，声明id，然后直接引用id。这个看下面其他的例子把，下面贴一下网上总结的用法：</p><p>#####@Results用法总结<br>MyBatis中使用@Results注解来映射查询结果集到实体类属性。</p><p>（1）@Results的基本用法。当数据库字段名与实体类对应的属性名不一致时，可以使用@Results映射来将其对应起来。column为数据库字段名，porperty为实体类属性名，jdbcType为数据库字段数据类型，id为是否为主键。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="variable">@Results</span>(&#123;</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=true),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"name"</span>, property=<span class="string">"name"</span>, jdbcType=JdbcType.VARCHAR),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"class_id "</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;Student&gt; selectAll();</span><br></pre></td></tr></table></figure><p>如上所示的数据库字段名class_id与实体类属性名classId，就通过这种方式建立了映射关系。</p><p>（2）@ResultMap的用法。当这段@Results代码需要在多个方法用到时，为了提高代码复用性，我们可以为这个@Results注解设置id，然后使用@ResultMap注解来复用这段代码。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="variable">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=true),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"name"</span>, property=<span class="string">"name"</span>, jdbcType=JdbcType.VARCHAR),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"class_id "</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER)</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;Student&gt; selectAll();</span><br><span class="line"> </span><br><span class="line"><span class="variable">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student where id = #&#123;id&#125;"</span>&#125;)</span><br><span class="line"><span class="variable">@ResultMap</span>(value=<span class="string">"studentMap"</span>)</span><br><span class="line">Student selectById(integer id);</span><br></pre></td></tr></table></figure><p>（3）@One的用法。当我们需要通过查询到的一个字段值作为参数，去执行另外一个方法来查询关联的内容，而且两者是一对一关系时，可以使用@One注解来便捷的实现。比如当我们需要查询学生信息以及其所属班级信息时，需要以查询到的class_id为参数，来执行ClassesMapper中的selectById方法，从而获得学生所属的班级信息。可以使用如下代码。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="variable">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=true),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"name"</span>, property=<span class="string">"name"</span>, jdbcType=JdbcType.VARCHAR),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"class_id "</span>, property=<span class="string">"myClass"</span>, javaType=MyClass.class,</span><br><span class="line">        one=<span class="variable">@One</span>(select=<span class="string">"com.my.mybatis.mapper.MyClassMapper.selectById"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;Student&gt; selectAllAndClassMsg();</span><br></pre></td></tr></table></figure><p>（4）@Many的用法。与@One类似，只不过如果使用@One查询到的结果是多行，会抛出TooManyResultException异常，这种时候应该使用的是@Many注解，实现一对多的查询。比如在需要查询学生信息和每次考试的成绩信息时。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable">@Select</span>(&#123;<span class="string">"select id, name, class_id from my_student"</span>&#125;)</span><br><span class="line"><span class="variable">@Results</span>(id=<span class="string">"studentMap"</span>, value=&#123;</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"id"</span>, jdbcType=JdbcType.INTEGER, id=true),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"name"</span>, property=<span class="string">"name"</span>, jdbcType=JdbcType.VARCHAR),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"class_id "</span>, property=<span class="string">"classId"</span>, jdbcType=JdbcType.INTEGER),</span><br><span class="line">    <span class="variable">@Result</span>(column=<span class="string">"id"</span>, property=<span class="string">"gradeList"</span>, javaType=List.class,</span><br><span class="line">        many=<span class="variable">@Many</span>(select=<span class="string">"com.my.mybatis.mapper.GradeMapper.selectByStudentId"</span>))</span><br><span class="line">&#125;)</span><br><span class="line">List&lt;Student&gt; selectAllAndGrade();</span><br></pre></td></tr></table></figure><h3 id="还有一种更简单的方式来映射实体类"><a href="#还有一种更简单的方式来映射实体类" class="headerlink" title="还有一种更简单的方式来映射实体类"></a>还有一种更简单的方式来映射实体类</h3><p>直接在清单文件中添加配置，就可以忽略驼峰命名参数<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#数据库字段下划线和Java实体类映射</span><br><span class="line">  # mybatis 下划线转驼峰配置,两者都可以</span><br><span class="line">#mybatis.<span class="keyword">configuration</span>.mapUnderscoreToCamelCase=<span class="literal">true</span></span><br><span class="line">mybatis.<span class="keyword">configuration</span>.<span class="keyword">map</span>-underscore-<span class="keyword">to</span>-camel-<span class="keyword">case</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>####UserController类</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package code.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> code.domain.JsonData;</span><br><span class="line"><span class="keyword">import</span> code.domain.User;</span><br><span class="line"><span class="keyword">import</span> code.mapper.UserMapper;</span><br><span class="line"><span class="keyword">import</span> code.services.interfaces.UserService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.<span class="keyword">factory</span>.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="built_in">List</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/insert"</span>)</span><br><span class="line">    public <span class="built_in">Object</span> insertUser(<span class="meta">@RequestParam</span>(required = <span class="keyword">true</span>) <span class="built_in">String</span> name, <span class="meta">@RequestParam</span>(required = <span class="keyword">true</span>) <span class="built_in">int</span> age, <span class="meta">@RequestParam</span>(required = <span class="keyword">true</span>) <span class="built_in">String</span> phone) &#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setAge(age);</span><br><span class="line">        user.setPhone(phone);</span><br><span class="line">        user.setCreateTime(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="built_in">int</span> id = userService.insert(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData().buildSuccess(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get_all"</span>)</span><br><span class="line">    public <span class="built_in">Object</span>  getAll()&#123;</span><br><span class="line">        <span class="built_in">List</span>&lt;User&gt; all = userMapper.getAll();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData().buildSuccess(all,<span class="string">"200"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/find_by_id"</span>)</span><br><span class="line">    public <span class="built_in">Object</span> findById(<span class="meta">@RequestParam</span>(name = <span class="string">"user_id"</span>,required = <span class="keyword">true</span>) long id)&#123;</span><br><span class="line"></span><br><span class="line">        User byId = userMapper.findById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData().buildSuccess(byId,<span class="string">"200"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/delete"</span>)</span><br><span class="line">    public <span class="built_in">Object</span> deleteById(<span class="built_in">int</span> id)&#123;</span><br><span class="line">        userMapper.delete(id);</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> JsonData().buildSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line">    public <span class="built_in">Object</span> updateById(<span class="built_in">String</span> name,<span class="built_in">int</span> id)&#123;</span><br><span class="line">        User user=<span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(name);</span><br><span class="line">        userMapper.update(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonData().buildSuccess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###3、整合事务示例（简单事务介绍）</p><p>####事务简介<br>    1、事务基本上分为单机事务 、分布式事务。我们常见的是单机事务，比如买东西付款，开启事务，一方扣款，一方收款，全部完成操作，此次事务才算解说。。如果是分布式事务就相当复杂了，多个数据库和服务器，所以需要用消息队列进行处理了。</p><pre><code>2、讲解场景的隔离级别    Serializable： 最严格，串行处理，消耗资源大    Repeatable Read：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据    Read Committed：大多数主流数据库的默认事务等级    Read Uncommitted：保证了读取过程中不会读取到非法数据。3、讲解常见的传播行为    PROPAGATION_REQUIRED--支持当前事务，如果当前没有事务，就新建一个事务,最常见的选择。    PROPAGATION_SUPPORTS--支持当前事务，如果当前没有事务，就以非事务方式执行。    PROPAGATION_MANDATORY--支持当前事务，如果当前没有事务，就抛出异常。    PROPAGATION_REQUIRES_NEW--新建事务，如果当前存在事务，把当前事务挂起, 两个事务之间没有关系，一个异常，一个提交，不会同时回滚    PROPAGATION_NOT_SUPPORTED--以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。    PROPAGATION_NEVER--以非事务方式执行，如果当前存在事务，则抛出异常</code></pre><p>####简单的开启事务实战。<br>我们使用最常见的传播行为，<code>propagation=Propagation.REQUIRED</code><br>由于上面我们直接controller层调用mapper层，没有经过service层写代码，因为操作简单，所以没必要再写一遍。<br>现在我们试一下通过service层 添加事务<br>UserServiceImpl类中添加如下代码，，并且再UserService中已经添加了接口<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">@Transactional(propagation=Propagation.REQUIRED)</span><br><span class="line">public int addAccount() &#123;</span><br><span class="line">    User <span class="keyword">user</span> = new User();</span><br><span class="line">    <span class="keyword">user</span>.<span class="built_in">set</span>Age(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">user</span>.<span class="built_in">set</span>CreateTime(new Date());</span><br><span class="line">    <span class="keyword">user</span>.<span class="built_in">set</span>Name(<span class="string">"事务测试"</span>);</span><br><span class="line">    <span class="keyword">user</span>.<span class="built_in">set</span>Phone(<span class="string">"110110110"</span>);</span><br><span class="line">    <span class="keyword">user</span>Mapper.insert(<span class="keyword">user</span>);</span><br><span class="line">    int i = <span class="number">100</span>/<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码是开启了事务，然后王数据库添加信息，然后执行异常，这样测试下数据库到底有没有写入信息。<br>UserController:<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="comment">//测试事务</span></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"transac"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function">Object <span class="title">transac</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> id = userService.addAccount();</span><br><span class="line">    <span class="function"><span class="keyword">return</span> JsonData.<span class="title">buildSuccess</span><span class="params">(id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行程序，查看log和 数据表</p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180906/6EF6i3GICg.png?imageslim" alt="mark"><br><img src="http://oima95jt3.bkt.clouddn.com/blog/180906/bHKK3L16lF.png?imageslim" alt="mark"></p><p>如果不加事务，虽然也会报错，但是确实已经执行了sql，写入了数据库</p><p>以上只是一个简单的增删该查的实例，可以直观的了解springboot整合mybatis，通过sql语句对数据库进行操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;大纲&quot;&gt;&lt;a href=&quot;#大纲&quot; class=&quot;headerlink&quot; title=&quot;大纲&quot;&gt;&lt;/a&gt;大纲&lt;/h3&gt;&lt;p&gt;1、实现打印sql语句以及切换数据源&lt;br&gt;2、springboot 整合mybatis增删改查实例&lt;br&gt;3、整合事务示例（简单事务介绍）
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记04——文件路径配置以及SpringBoot打包方式讲解</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B004%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8ASpringBoot%E6%89%93%E5%8C%85%E6%96%B9%E5%BC%8F%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记04——文件路径配置以及SpringBoot打包方式讲解/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:26:58.104Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、文件路径的配置"><a href="#1、文件路径的配置" class="headerlink" title="1、文件路径的配置"></a>1、文件路径的配置</h3><p>由于我们上一节直接将上传的文件写到了静态资源文件夹下面，如果我们打成jar包运行到服务器上，是无法拿到这个路径的。所以我们需要主动去指定这个文件路径，然后去访问资源。（正常我们需要在配置文件中进行配置，然后引用资源文件读取配置文件）</p><p>（1）首先在resources资源文件夹下创建配置文件  命名为 application.properties   应用程序会默认读取配置文件的信息，<br>可以配置端口，数据库地址以及各种。。。<br>（2）声明文件路径<br>例如：<code>web.images-path=D:/test/images</code><br>映射名称web.images-path  这个名字随便起，自己来定，， 后面指定的是你要将图片存储的路径<br>（3）将声明的文件路径添加为外部可以访问的资源文件声明 ，添加配置</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.<span class="keyword">static</span>-locations=<span class="string">classpath:</span><span class="regexp">/META-INF/</span>resources<span class="regexp">/,classpath:/</span>resources<span class="regexp">/,classpath:/</span><span class="keyword">static</span><span class="regexp">/,classpath:/</span><span class="keyword">public</span>/</span><br><span class="line">,<span class="string">file:</span>$&#123;web.images-path&#125;</span><br></pre></td></tr></table></figure><p>以上代码添加到配置文件中。这里简单介绍下springboot 项目的资源文件目录</p><blockquote><p>src/main/java：存放代码<br>src/main/resources 存放资源文件<br>​         static: 存放静态文件，比如 css、js、image, （访问方式 <a href="http://localhost:8080/js/main.js）" target="_blank" rel="noopener">http://localhost:8080/js/main.js）</a><br>​         config:存放配置文件,application.properties<br>​         resources:<br>​         public<br>​         templates:存放静态页面jsp,html,tpl     <strong>此文件加需要添加接口映射才能跳转访问</strong>spring-boot-starter-thymeleaf</p></blockquote><p>springboot 资源文件的默认查找顺序为：<strong>META/resources &gt; resources &gt; static &gt; public  里面找是否存在相应的资源，如果有则直接返回。</strong><br>静态资源配置官网：<br><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-static-content</a></p><p>默认配置</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.<span class="keyword">static</span>-locations = <span class="keyword">classpath</span>:<span class="regexp">/META-INF/</span>resources<span class="regexp">/,classpath:/</span>resources<span class="regexp">/,classpath:/</span><span class="keyword">static</span><span class="regexp">/,classpath:/</span><span class="keyword">public</span><span class="regexp">/</span></span><br></pre></td></tr></table></figure><p>如果需要我们自定义一个文件夹，就需要在上面的配置中添加我们的文件夹说明，比如，在后面添加一个<code>,classpath:/test/</code>  这样就把test文件夹添加到配置中了。在resources文件夹下创建test 文件夹，就可以访问这个文件夹了。</p><p>小结：我们给图片配置路径就是把我们自定义的路径<code>web.images-path=D:/test/images</code> 添加到 <code>spring.resources.static-locations</code> 的配置说明中，file:${自己定义的名字} 指定路径。<br>然后修改FileController 的路径要和配置文件一致；并且指定的文件夹要存在’<br>接下来，我们不用硬编码，用配置文件注入的方式动态拿到指定的地址<br><strong>我们已经在配置文件中指定了文件路径，当然可以重新写一个，只要符合格式</strong><br>1、添加<code>@PropertySource({&quot;classpath:application.properties&quot;})</code>spring会自动扫描配置文件<br>2、修改路径，将硬编码改为动态获取配置文件值<br><code>@Value(&quot;${web.upload-path}&quot;)​    private String filePath;</code><br>​    注意这里的{}内的名称要和配置文件中指定的key值 完全一致<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.controller;</span><br><span class="line"><span class="keyword">import</span> com.test.domain.JsonData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.ResponseBody;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.<span class="keyword">annotation</span>.RestController;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;<span class="meta-string">"classpath:application.properties"</span>&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">   <span class="comment">//public static final String  filePath="D:/test/images/";</span></span><br><span class="line">    <span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;web.upload-path&#125;</span>"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> String filePath;</span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/v1/upload"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> Object upLoad(<span class="meta">@RequestParam(<span class="meta-string">"head_img"</span>)</span> MultipartFile  file)&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//判空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (file.getSize()&gt;<span class="number">100000</span>)&#123;</span><br><span class="line">            <span class="comment">//大小限制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前文件名</span></span><br><span class="line">        String name = file.getOriginalFilename();</span><br><span class="line">        <span class="comment">//后缀名</span></span><br><span class="line">        String substring = name.substring(name.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">        <span class="comment">//重新生成唯一文件名</span></span><br><span class="line">        String fileName = UUID.randomUUID() + substring;</span><br><span class="line">        File newFile=new File(filePath+fileName);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.transferTo(newFile);</span><br><span class="line">            <span class="keyword">return</span> new JsonData(<span class="string">"1"</span>,<span class="string">"ok"</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  new JsonData(<span class="string">"0"</span>,<span class="string">"上传失败"</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 多个文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = <span class="meta-string">"uploads"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> JsonData uploads(HttpServletRequest request, <span class="meta">@RequestParam(<span class="meta-string">"head_img"</span>)</span> MultipartFile... file) &#123;</span><br><span class="line"></span><br><span class="line">        int num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (MultipartFile f : file) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取文件名</span></span><br><span class="line">            String fileName = f.getOriginalFilename();</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"上传的文件名为："</span> + fileName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取文件的后缀名,比如图片的jpeg,png</span></span><br><span class="line">            String suffixName = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"上传的后缀名为："</span> + suffixName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 文件上传后的路径</span></span><br><span class="line">            fileName = UUID.randomUUID() + suffixName;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"转换后的名称:"</span> + fileName);</span><br><span class="line"></span><br><span class="line">            File dest = new File(filePath + fileName);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                f.transferTo(dest);</span><br><span class="line">                num++;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num == file.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> new JsonData(<span class="string">"1"</span>,<span class="string">"ok"</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> new JsonData(<span class="string">"0"</span>,<span class="string">"上传失败"</span>,<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###测试文件上传下载<br>运行springboot，然后调用接口，如：<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180905/BK4HFgH59c.png?imageslim" alt="mark"></p><p>然后再浏览器直接获取图片，因为我们已经在配置文件中指明了路径，也配置了。结果如下，直接使用地址+文件名就可以访问<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180905/0bGJ72Df7h.png?imageslim" alt="mark"></p><p>###3、springboot 打成jar运行<br>光配置完文件路径还不可以，需要进行springboot 的打包。<br>当然可以用maven 命令直接打包，但是如果不添加一个maven 插件的话，会报错no main manifest attribute, in XXX.jar。<br>因为maven没有在清单文件中写入，进行启动文件的指定<br>（1）在pom.xml文件中添加maven插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--使用maven打包需要添加这个插件，不然运行没有配置文件 MAINFEST.MF--&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）使用maven 进行打包<br>   可以使用命令  mvn spring-boot:run 直接启动， 或者mvn  package 打包，<br>   默认是打成jar包，由于springboot 内置了tomcat容器，直接运行jar 包就可以开发服务。<br>   可以指定最后打包的包名：<br>   在build 标签下 添加 finalname<br>   比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>practice<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--使用maven打包需要添加这个插件，不然运行没有配置文件 MAINFEST.MF--&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180831/aclDgLkiiK.png?imageslim" alt="mark"><br>在idea工具中，可以点击maven 生命周期下的 相关命令，双击直接执行。</p><p>（3）直接运行jar   执行命令 <code>java  -jar  parctice.jar</code>   即：java -jar  包名.jar<br>如果是访问我们上传的图片，就  localhost:8080/图片名  就能访问当，如果是服务器就把localhost换位服务器ip<br>但是如果是打成war 包 访问以及上传都需要加上包名。</p><p>以上是打成jar 包。 如果我们需要用一个外置的Tomcat容器来部署服务的话，那我们就可以直接打成war包，，直接扔到服务器上就tomcat  下的webapps 目录下，只要启动tomcat服务器，就会自动部署</p><p>###3、springboot 打成war部署服务器<br>（1）需要添加spring-boot-starter-tomcat依赖<br> 因为是要使用外部的tomcat，所以就需要修改pom.xml 的依赖如下<br> 修改tomcat 的作用域。 当然也有其他方法<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--因配置外部TOMCAT 而配置--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>当然也有其他方法  比如移除内置tomcat 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 移除嵌入式tomcat插件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我使用第一种，直接修改tomcat的作用域 为 provided ,表示仅仅在编译时使用，最终不会打到包里面</p><p>（2）修改pom.xml文件指明 打包方式为 war<br><code>&lt;packaging&gt;war&lt;/packaging&gt;</code><br>不加默认打包方式为jar包，，修改为war,比如我的项目，添加一行代码<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.gongsi.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>practice<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>（3）最关键的，修改启动类创建的Application。继承SpringBootServletInitializer并且重写configure方法<br> 代码如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.<span class="type">SpringApplication</span>;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.<span class="type">SpringBootApplication</span>;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.<span class="type">SpringApplicationBuilder</span>;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.<span class="type">MultipartConfigFactory</span>;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.web.servlet.support.<span class="type">SpringBootServletInitializer</span>;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.<span class="type">Bean</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.<span class="type">MultipartConfigElement</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">SpringBootServletInitializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">SpringApplicationBuilder</span> configure(<span class="type">SpringApplicationBuilder</span> builder) &#123;</span><br><span class="line">        <span class="keyword">return</span> builder.sources(<span class="type">Application</span>.<span class="keyword">class</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(<span class="type">String</span>[] args)&#123;</span><br><span class="line">        <span class="type">SpringApplication</span>.run(<span class="type">Application</span>.<span class="keyword">class</span>,args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置文件大小限制</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    public <span class="type">MultipartConfigElement</span> multipartConfigElement() &#123;</span><br><span class="line">        <span class="type">MultipartConfigFactory</span> factory = <span class="keyword">new</span> <span class="type">MultipartConfigFactory</span>();</span><br><span class="line">        <span class="comment">//单个文件最大  -----这里的硬编码应该放到配置文件中进行配置，这里只演示下</span></span><br><span class="line">        factory.setMaxFileSize(<span class="string">"10240KB"</span>); <span class="comment">//KB,MB</span></span><br><span class="line">        <span class="comment">/// 设置总上传数据总大小</span></span><br><span class="line">        factory.setMaxRequestSize(<span class="string">"1024000KB"</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.createMultipartConfig();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总共需要做两步操作，先继承 SpringBootServletInitializer ，然后重写 configure(SpringApplicationBuilder builder) 方法，<br>return  builder.sources(Application.class);  注意： 这个Appication 为你自己定义的类。</p><p>（4） mvn  package  进行打包，，并将打成的war 包丢到 tomcat 容器的 webapps路径下，启动tomcat  等待部署完成。</p><p>请求接口的时候，比如，我这里的war包 名为practice ,调用接口就需要 <a href="http://ip地址:8080/practice/接口名" target="_blank" rel="noopener">http://ip地址:8080/practice/接口名</a></p><p><strong>如果并发量多或者多个应用，可以用fastdfs，阿里云oss，或者用nginx搭建一个简单的文件服务器，将我们的资源和应用程序分离开来</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、文件路径的配置&quot;&gt;&lt;a href=&quot;#1、文件路径的配置&quot; class=&quot;headerlink&quot; title=&quot;1、文件路径的配置&quot;&gt;&lt;/a&gt;1、文件路径的配置&lt;/h3&gt;&lt;p&gt;由于我们上一节直接将上传的文件写到了静态资源文件夹下面，如果我们打成jar包运行到服
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot入门笔记06——配置文件的介绍</title>
    <link href="http://yoursite.com/2018/10/06/springboot/SpringBoot%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B006%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2018/10/06/springboot/SpringBoot入门笔记06——配置文件的介绍/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:26:47.763Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、springboot-配置文件分类"><a href="#一、springboot-配置文件分类" class="headerlink" title="一、springboot 配置文件分类"></a>一、springboot 配置文件分类</h3><p>•application.properties<br>•application.yml<br>YAML Ain’t Markup Language  yaml不是一种标记语言<br>springboot 有两种配置文件，可以是properties,也可以是yml，各有各的好处。本人打算使用properties方式，纯属个人爱好<br>对比下：</p><pre><code>1)YAML（Yet Another Markup Language）            写 YAML 要比写 XML 快得多(无需关注标签或引号)            使用空格 Space 缩进表示分层，不同层次之间的缩进可以使用不同的空格数目            注意：key后面的冒号，后面一定要跟一个空格,树状结构        application.properties示例            server.port=8090              server.session-timeout=30              server.tomcat.max-threads=0              server.tomcat.uri-encoding=UTF-8         application.yml示例            server:                    port: 8090                    session-timeout: 30                    tomcat.max-threads: 0                    tomcat.uri-encoding: UTF-8 </code></pre><p>####二、最简单的方式，官网直接复制，需要用啥就复制啥，然后改改</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="regexp">//</span>docs.spring.io<span class="regexp">/spring-boot/</span>docs<span class="regexp">/2.1.0.BUILD-SNAPSHOT/</span>reference<span class="regexp">/htmlsingle/</span><span class="comment">#common-application-properties</span></span><br></pre></td></tr></table></figure><p>####1、 properties这样写<br><code>server.port=8080</code></p><p>####2、YAML这样写<br><strong>在yml中缩进一定不能使用TAB，否则会报很奇怪的错误；（缩进特么只能用空格！！！！） </strong><br><strong>每个k的冒号后面一定都要加一个空格；</strong><br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">server:</span></span><br><span class="line"><span class="symbol">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="symbol">path:</span> /hello</span><br></pre></td></tr></table></figure></p><p> k:(空格)v：表示一对键值对（空格必须有）；<br>以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的—–属性和值也是大小写敏感</p><p>#####值的写法<br><strong>（1）字面量：普通的值（数字，字符串，布尔）</strong><br>k: v：字面直接来写；<br>字符串默认不用加上单引号或者双引号；<br>“”：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思<br>name: “zhangsan \n lisi”：输出；zhangsan 换行 lisi<br>‘’：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据<br>name: ‘zhangsan \n lisi’：输出；zhangsan \n lisi<br><strong>（2）对象、Map（属性和值）（键值对）：</strong></p><p>k: v：在下一行来写对象的属性和值的关系；注意缩进<br>对象还是k: v的方式<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">friends:</span></span><br><span class="line"><span class="symbol">lastName:</span> zhangsan</span><br><span class="line"><span class="symbol">age:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></p><p>行内写法<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">friends</span>: &#123;<span class="attribute">lastName</span>: zhangsan,age: <span class="number">18</span>&#125;</span><br></pre></td></tr></table></figure></p><p><strong>（3）数组（List、Set）</strong><br>用- 值表示数组中的一个元素<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pet<span class="variable">s:</span></span><br><span class="line">‐ <span class="keyword">cat</span></span><br><span class="line">‐ dog</span><br><span class="line">‐ pig</span><br></pre></td></tr></table></figure></p><p>行内写法<br><code>pets: [cat,dog,pig]</code></p><p>####3、配置文件值注入<br>配置文件如下：例如<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">person</span>:</span><br><span class="line"><span class="attribute">lastName</span>: hello</span><br><span class="line"><span class="attribute">age</span>: <span class="number">18</span></span><br><span class="line"><span class="attribute">boss</span>: false</span><br><span class="line"><span class="attribute">birth</span>: <span class="number">2017</span>/<span class="number">12</span>/<span class="number">12</span></span><br><span class="line"><span class="attribute">maps</span>: &#123;<span class="attribute">k1</span>: v1,<span class="attribute">k2</span>: <span class="number">12</span>&#125;</span><br><span class="line"><span class="attribute">lists</span>:</span><br><span class="line">‐ zhoumao</span><br><span class="line">‐ zhangyue</span><br><span class="line"><span class="attribute">dog</span>:</span><br><span class="line"><span class="attribute">name</span>: 德华</span><br><span class="line"><span class="attribute">age</span>: <span class="number">12</span></span><br></pre></td></tr></table></figure></p><p>javaBean：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 将配置文件中配置的每一个属性的值，映射到这个组件中</span><br><span class="line">* <span class="title">@ConfigurationProperties</span>：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；</span><br><span class="line">* <span class="keyword">prefix</span> = <span class="string">"person"</span>：配置文件中哪个下面的所有属性进行一一映射</span><br><span class="line">* *</span><br><span class="line">只有这个组件是容器中的组件，才能容器提供的<span class="title">@ConfigurationProperties</span>功能；</span><br><span class="line">* *</span><br><span class="line">/</span><br><span class="line"><span class="title">@Component</span></span><br><span class="line"><span class="title">@ConfigurationProperties</span>(<span class="keyword">prefix</span> = <span class="string">"person"</span>)</span><br><span class="line">public class Person &#123;</span><br><span class="line"><span class="keyword">private</span> String lastName<span class="comment">;</span></span><br><span class="line"><span class="comment">private Integer age;</span></span><br><span class="line"><span class="comment">private Boolean boss;</span></span><br><span class="line"><span class="comment">private Date birth;</span></span><br><span class="line"><span class="comment">private Map&lt;String,Object&gt; maps;</span></span><br><span class="line"><span class="comment">private List&lt;Object&gt; lists;</span></span><br><span class="line"><span class="comment">private Dog dog;</span></span><br></pre></td></tr></table></figure><p>以上配置文件的注入以对象的方式，只需要在javaBean 上添加两个注解，@Component标记类  然后@ConfigurationProperties(prefix = “person”)指定前缀   然后只要javaBean的属性和配置文件一致就可以直接映射。</p><p>使用时，需要在使用的类上指定配置文件@PropertySource({“classpath:application.yml”})</p><p>小结：可以使用yaml也可以使用properties方式，基本语法也差不太多，习惯用哪个用哪个，官网有例子，使用的时候直接复制。<br>所有的配置其实都会被注入成map,都是键值对的方式，取的时候都是根据key 获取value.<br>所以获取配置文件的方式暂时会一种就可以。</p><h3 id="三、配置文件自动映射属性和实体类"><a href="#三、配置文件自动映射属性和实体类" class="headerlink" title="三、配置文件自动映射属性和实体类"></a>三、配置文件自动映射属性和实体类</h3><p>配置文件加载有两种方式，一种直接在Controller类中添加注解，以value的形式直接使用配置文件。另一种，是注入实体类的方式。</p><p><strong>第一种：Controller类加载配置信息</strong><br>就拿我们文件的例子来看 application.proterties文件如下</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">web.upload-path=<span class="string">D:</span><span class="regexp">/ideWorkspace/</span>StudyProject<span class="regexp">/HelloWorld/</span>src<span class="regexp">/main/</span>resources<span class="regexp">/static/</span>images</span><br><span class="line">spring.resources.<span class="keyword">static</span>-locations=<span class="string">classpath:</span><span class="regexp">/META-INF/</span>resources<span class="regexp">/,classpath:/</span>resources<span class="regexp">/,classpath:/</span><span class="keyword">static</span><span class="regexp">/,classpath:/</span><span class="keyword">public</span>/,<span class="string">file:</span>$&#123;web.upload-path&#125;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个文件路径，当然也可以是其他的。只要是key-value形式定义就可以。<br>然后，需要在使用配置文件的类中添加注解。<br>（1）类上添加<code>@PropertySource({&quot;classpath:application.properties&quot;})</code><br>（2）变量名使用</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;web.upload-path&#125;</span>"</span>)</span></span><br><span class="line"><span class="keyword">private</span> String filePath;</span><br></pre></td></tr></table></figure><p>这样就可以了。其实就是通过@PropertySource注解将配置文件路径添加进来，这样spring 就会扫描到这个配置文件，并且映射成map到这个类中，接下来通过@Value注解，以key-value的形式，通过定义的key拿到配置文件中的值。这样就避免了硬编码。（以上是在有@Controller 注解的类中使用）</p><p><strong>第二种  注入配置实体类</strong><br>接下来用个实例讲解下。<br>首先在配置文件中配置了两个属性，比如服务器的地址和名称</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test.<span class="attribute">domain</span>=www.answerme.xyz</span><br><span class="line">test.<span class="attribute">name</span>=springboot</span><br></pre></td></tr></table></figure><p>如果要把他们映射到实体类，需要建一个javaBean 比如：ServerSetting.java<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.<span class="keyword">annotation</span>.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.<span class="keyword">annotation</span>.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器配置</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&#123;<span class="meta-string">"classpath:application.properties"</span>&#125;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerSettings</span> </span>&#123;</span><br><span class="line"><span class="comment">//名称</span></span><br><span class="line"><span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;test.name&#125;</span>"</span>)</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="meta">@Value(<span class="meta-string">"<span class="subst">$&#123;test.domain&#125;</span>"</span>)</span></span><br><span class="line"><span class="keyword">private</span> String domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String getName() &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> void setName(String name) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String getDomain() &#123;</span><br><span class="line"><span class="keyword">return</span> domain;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> void setDomain(String domain) &#123;</span><br><span class="line"><span class="keyword">this</span>.domain = domain;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后写一个controller方法测试下：<br>自动注入<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ServerSetting serverSetting;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping(<span class="meta-string">"/v1/server"</span>)</span></span><br><span class="line"><span class="keyword">public</span> Object  serverTest()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> serverSetting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果如下：<code>{&quot;name&quot;: &quot;springboot&quot;,&quot;domain&quot;: &quot;www.answerme.xyz&quot;}</code><br>说明，这种方式可以获取到配置文件的信息。<br>当然每次都要将属性和配置文件的key一一对应有点麻烦，所以有更方便的写法。<br>我们可以再@ConfigurationProperties() 注解中添加一个前缀，代码如下</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件名: ServerSetting.java</span></span><br><span class="line"><span class="comment"> * 描述：</span></span><br><span class="line"><span class="comment"> * Create by Google on 2018/9/10 23:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器配置</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource</span>(&#123;<span class="string">"classpath:application.properties"</span>&#125;)</span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ServerSetting &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> name;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> domain;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> setName(<span class="built_in">String</span> name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">String</span> getDomain() &#123;</span><br><span class="line">        <span class="keyword">return</span> domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> setDomain(<span class="built_in">String</span> domain) &#123;</span><br><span class="line">        <span class="keyword">this</span>.domain = domain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>常见问题：            1、配置文件注入失败，Could not resolve placeholder                解决：根据springboot启动流程，会有自动扫描包没有扫描到相关注解,                 默认Spring框架实现会从声明@ComponentScan所在的类的package进行扫描，来自动注入，                因此启动类最好放在根路径下面，或者指定扫描包范围                spring-boot扫描启动类对应的目录和子目录            2、注入bean的方式，属性名称和配置文件里面的key一一对应，就不用加@Value 这个注解                如果不一样，就要加@value(&quot;${XXX}&quot;)</code></pre><p>小结：</p><pre><code>1、添加 @Component或者Configuration 注解，后者标记为配置文件；    2、使用 @PropertySource 注解指定配置文件位置；(属性名称规范: 大模块.子模块.属性名)3、必须 通过注入IOC对象Resource 进来 ， 才能在类中使用获取的配置文件值。    @Autowired    private WeChatConfig weChatConfig;    例子：        @Configuration@PropertySource(value=&quot;classpath:application.properties&quot;)        public class WeChatConfig {            @Value(&quot;${wxpay.appid}&quot;)            private String appId;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、springboot-配置文件分类&quot;&gt;&lt;a href=&quot;#一、springboot-配置文件分类&quot; class=&quot;headerlink&quot; title=&quot;一、springboot 配置文件分类&quot;&gt;&lt;/a&gt;一、springboot 配置文件分类&lt;/h3&gt;&lt;p&gt;•a
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Jackson快速入门——转载</title>
    <link href="http://yoursite.com/2018/10/06/springboot/Jackson%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E8%BD%AC%E8%BD%BD/"/>
    <id>http://yoursite.com/2018/10/06/springboot/Jackson快速入门——转载/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-05T16:31:09.296Z</updated>
    
    <content type="html"><![CDATA[<p>Java生态圈中有很多处理JSON和XML格式化的类库，Jackson是其中比较著名的一个。虽然JDK自带了XML处理类库，但是相对来说比较低级，使用本文介绍的Jackson等高级类库处理起来会方便很多。</p><h3 id="引入类库"><a href="#引入类库" class="headerlink" title="引入类库"></a>引入类库</h3><p>由于Jackson相关类库按照功能分为几个相对独立的，所以需要同时引入多个类库，为了方便我将版本号单独提取出来设置，相关Gradle配置如下。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    jacksonVersion = <span class="string">'2.9.5'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.core'</span>, <span class="string">name:</span> <span class="string">'jackson-core'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.core'</span>, <span class="string">name:</span> <span class="string">'jackson-databind'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.core'</span>, <span class="string">name:</span> <span class="string">'jackson-annotations'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    <span class="comment">// 引入XML功能</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.dataformat'</span>, <span class="string">name:</span> <span class="string">'jackson-dataformat-xml'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    <span class="comment">// 比JDK自带XML实现更高效的类库</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.woodstox'</span>, <span class="string">name:</span> <span class="string">'woodstox-core'</span>, <span class="string">version:</span> <span class="string">'5.1.0'</span></span><br><span class="line">    <span class="comment">// Java 8 新功能</span></span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.datatype'</span>, <span class="string">name:</span> <span class="string">'jackson-datatype-jsr310'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.module'</span>, <span class="string">name:</span> <span class="string">'jackson-module-parameter-names'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line">    compile <span class="string">group:</span> <span class="string">'com.fasterxml.jackson.datatype'</span>, <span class="string">name:</span> <span class="string">'jackson-datatype-jdk8'</span>, <span class="string">version:</span> jacksonVersion</span><br><span class="line"></span><br><span class="line">    compileOnly <span class="string">group:</span> <span class="string">'org.projectlombok'</span>, <span class="string">name:</span> <span class="string">'lombok'</span>, <span class="string">version:</span> <span class="string">'1.16.22'</span></span><br><span class="line">&#125;<span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure></p><p>Maven配置请去mvnrepository搜索。</p><h3 id="Jackson注解"><a href="#Jackson注解" class="headerlink" title="Jackson注解"></a>Jackson注解</h3><p>Jackson类库包含了很多注解，可以让我们快速建立Java类与JSON之间的关系。详细文档可以参考<a href="https://github.com/FasterXML/jackson-annotations/wiki/Jackson-Annotations" target="_blank" rel="noopener">Jackson-Annotations</a>。下面介绍一下常用的。</p><h4 id="属性命名"><a href="#属性命名" class="headerlink" title="属性命名"></a>属性命名</h4><p><code>@JsonProperty</code>注解指定一个属性用于JSON映射，默认情况下映射的JSON属性与注解的属性名称相同，不过可以使用该注解的value值修改JSON属性名，该注解还有一个index属性指定生成JSON属性的顺序，如果有必要的话。</p><h4 id="属性包含"><a href="#属性包含" class="headerlink" title="属性包含"></a>属性包含</h4><p>还有一些注解可以管理在映射JSON的时候包含或排除某些属性，下面介绍一下常用的几个。</p><p><code>@JsonIgnore</code>注解用于排除某个属性，这样该属性就不会被Jackson序列化和反序列化。</p><p><code>@JsonIgnoreProperties</code>注解是类注解。在序列化为JSON的时候，<code>@JsonIgnoreProperties({&quot;prop1&quot;, &quot;prop2&quot;})</code>会忽略pro1和pro2两个属性。在从JSON反序列化为Java类的时候，<code>@JsonIgnoreProperties(ignoreUnknown=true)</code>会忽略所有没有Getter和Setter的属性。该注解在Java类和JSON不完全匹配的时候很有用。</p><p><code>@JsonIgnoreType</code>也是类注解，会排除所有指定类型的属性。</p><h4 id="序列化相关"><a href="#序列化相关" class="headerlink" title="序列化相关"></a>序列化相关</h4><p><code>@JsonPropertyOrder</code>和<code>@JsonProperty</code>的index属性类似，指定属性序列化时的顺序。</p><p><code>@JsonRootName</code>注解用于指定JSON根属性的名称。</p><h3 id="处理JSON"><a href="#处理JSON" class="headerlink" title="处理JSON"></a>处理JSON</h3><p>简单映射<br>我们用Lombok设置一个简单的Java类。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line"><span class="variable">@AllArgsConstructor</span></span><br><span class="line"><span class="variable">@NoArgsConstructor</span></span><br><span class="line">public class Friend &#123;</span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">nickname</span>;</span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">int</span> <span class="selector-tag">age</span>;</span><br><span class="line">&#125;<span class="selector-tag">1234567</span></span><br></pre></td></tr></table></figure></p><p>然后就可以处理JSON数据了。首先需要一个ObjectMapper对象，序列化和反序列化都需要它。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">Friend <span class="keyword">friend</span> = <span class="keyword">new</span> Friend(<span class="string">"yitian"</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写为字符串</span></span><br><span class="line"><span class="keyword">String</span> <span class="built_in">text</span> = mapper.writeValueAsString(<span class="keyword">friend</span>);</span><br><span class="line"><span class="comment">// 写为文件</span></span><br><span class="line">mapper.writeValue(<span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"friend.json"</span>), <span class="keyword">friend</span>);</span><br><span class="line"><span class="comment">// 写为字节流</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = mapper.writeValueAsBytes(<span class="keyword">friend</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">text</span>);</span><br><span class="line"><span class="comment">// 从字符串中读取</span></span><br><span class="line">Friend newFriend = mapper.readValue(<span class="built_in">text</span>, Friend.class);</span><br><span class="line"><span class="comment">// 从字节流中读取</span></span><br><span class="line">newFriend = mapper.readValue(bytes, Friend.class);</span><br><span class="line"><span class="comment">// 从文件中读取</span></span><br><span class="line">newFriend = mapper.readValue(<span class="keyword">new</span> <span class="built_in">File</span>(<span class="string">"friend.json"</span>), Friend.class);</span><br><span class="line">System.out.<span class="built_in">println</span>(newFriend);<span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure></p><p>程序结果如下。可以看到生成的JSON属性和Java类中定义的一致。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"nickname"</span>:<span class="string">"yitian"</span>,<span class="string">"age"</span>:25&#125;</span><br><span class="line">Friend(<span class="attribute">nickname</span>=yitian, <span class="attribute">age</span>=25)12</span><br></pre></td></tr></table></figure></p><h3 id="集合的映射"><a href="#集合的映射" class="headerlink" title="集合的映射"></a>集合的映射</h3><p>除了使用Java类进行映射之外，我们还可以直接使用Map和List等Java集合组织JSON数据，在需要的时候可以使用readTree方法直接读取JSON中的某个属性值。需要注意的是从JSON转换为Map对象的时候，由于Java的类型擦除，所以类型需要我们手动用new TypeReference<t>给出。</t></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="built_in">map</span>.put(<span class="string">"age"</span>, <span class="number">25</span>);</span><br><span class="line"><span class="built_in">map</span>.put(<span class="string">"name"</span>, <span class="string">"yitian"</span>);</span><br><span class="line"><span class="built_in">map</span>.put(<span class="string">"interests"</span>, <span class="keyword">new</span> <span class="keyword">String</span>[]&#123;<span class="string">"pc games"</span>, <span class="string">"music"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">String</span> <span class="built_in">text</span> = mapper.writeValueAsString(<span class="built_in">map</span>);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; map2 = mapper.readValue(<span class="built_in">text</span>, <span class="keyword">new</span> TypeReference&lt;Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt;&gt;() &#123;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.<span class="built_in">println</span>(map2);</span><br><span class="line"></span><br><span class="line">JsonNode root = mapper.readTree(<span class="built_in">text</span>);</span><br><span class="line"><span class="keyword">String</span> name = root.<span class="built_in">get</span>(<span class="string">"name"</span>).asText();</span><br><span class="line"><span class="built_in">int</span> age = root.<span class="built_in">get</span>(<span class="string">"age"</span>).asInt();</span><br><span class="line"></span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"name:"</span> + name + <span class="string">" age:"</span> + age);<span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure><p>程序结果如下。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"name"</span>:<span class="string">"yitian"</span>,<span class="string">"interests"</span>:[<span class="string">"pc games"</span>,<span class="string">"music"</span>],<span class="string">"age"</span>:25&#125;</span><br><span class="line">&#123;<span class="attribute">name</span>=yitian, interests=[pc games, music], <span class="attribute">age</span>=25&#125;</span><br><span class="line">name:yitian age:25123</span><br></pre></td></tr></table></figure></p><h3 id="Jackson配置"><a href="#Jackson配置" class="headerlink" title="Jackson配置"></a>Jackson配置</h3><p>Jackson预定义了一些配置，我们通过启用和禁用某些属性可以修改Jackson运行的某些行为。详细文档参考<a href="https://github.com/FasterXML/jackson-databind/wiki/JacksonFeatures" target="_blank" rel="noopener">JacksonFeatures。</a>下面我简单翻译一下Jackson README上列出的一些属性。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 美化输出</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.enable</span>(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line"><span class="comment">// 允许序列化空的POJO类</span></span><br><span class="line"><span class="comment">// （否则会抛出异常）</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.disable</span>(SerializationFeature.FAIL_ON_EMPTY_BEANS);</span><br><span class="line"><span class="comment">// 把java.util.Date, Calendar输出为数字（时间戳）</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.disable</span>(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在遇到未知属性的时候不抛出异常</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.disable</span>(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line"><span class="comment">// 强制JSON 空字符串("")转换为null对象值:</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.enable</span>(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JSON中允许C/C++ 样式的注释(非标准，默认禁用)</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.configure</span>(JsonParser.Feature.ALLOW_COMMENTS, true);</span><br><span class="line"><span class="comment">// 允许没有引号的字段名（非标准）</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.configure</span>(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);</span><br><span class="line"><span class="comment">// 允许单引号（非标准）</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.configure</span>(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);</span><br><span class="line"><span class="comment">// 强制转义非ASCII字符</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.configure</span>(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);</span><br><span class="line"><span class="comment">// 将内容包裹为一个JSON属性，属性名由@JsonRootName注解指定</span></span><br><span class="line"><span class="selector-tag">mapper</span><span class="selector-class">.configure</span>(SerializationFeature.WRAP_ROOT_VALUE, true);<span class="selector-tag">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure></p><p>这里有三个方法，configure方法接受配置名和要设置的值，Jackson 2.5版本新加的enable和disable方法则直接启用和禁用相应属性，我推荐使用后面两个方法。</p><h3 id="用注解管理映射"><a href="#用注解管理映射" class="headerlink" title="用注解管理映射"></a>用注解管理映射</h3><p>前面介绍了一些Jackson注解，下面来应用一下这些注解。首先来看看使用了注解的Java类。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line"><span class="variable">@NoArgsConstructor</span></span><br><span class="line"><span class="variable">@AllArgsConstructor</span></span><br><span class="line"><span class="variable">@JsonRootName</span>(<span class="string">"FriendDetail"</span>)</span><br><span class="line"><span class="variable">@JsonIgnoreProperties</span>(&#123;<span class="string">"uselessProp1"</span>, <span class="string">"uselessProp3"</span>&#125;)</span><br><span class="line">public class FriendDetail &#123;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"NickName"</span>)</span><br><span class="line">    private String name;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Age"</span>)</span><br><span class="line">    private int age;</span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">uselessProp1</span>;</span><br><span class="line">    @<span class="selector-tag">JsonIgnore</span></span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">int</span> <span class="selector-tag">uselessProp2</span>;</span><br><span class="line">    <span class="selector-tag">private</span> <span class="selector-tag">String</span> <span class="selector-tag">uselessProp3</span>;</span><br><span class="line">&#125;<span class="selector-tag">123456789101112131415</span></span><br></pre></td></tr></table></figure></p><p>然后看看代码。需要注意的是，由于设置了排除的属性，所以生成的JSON和Java类并不是完全对应关系，所以禁用<code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code>是必要的。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="comment">//mapper.enable(SerializationFeature.WRAP_ROOT_VALUE);</span></span><br><span class="line">mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);</span><br><span class="line">FriendDetail fd = <span class="keyword">new</span> FriendDetail(<span class="string">"yitian"</span>, <span class="number">25</span>, <span class="string">""</span>, <span class="number">0</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">text</span> = mapper.writeValueAsString(fd);</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">FriendDetail fd2 = mapper.readValue(<span class="built_in">text</span>, FriendDetail.class);</span><br><span class="line">System.out.<span class="built_in">println</span>(fd2);<span class="number">123456789</span></span><br></pre></td></tr></table></figure><p>运行结果如下。可以看到生成JSON的时候忽略了我们制定的值，而且在转换为Java类的时候对应的属性为空。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"NickName"</span>:<span class="string">"yitian"</span>,<span class="string">"Age"</span>:25&#125;</span><br><span class="line">FriendDetail(<span class="attribute">name</span>=yitian, <span class="attribute">age</span>=25, <span class="attribute">uselessProp1</span>=<span class="literal">null</span>, <span class="attribute">uselessProp2</span>=0, <span class="attribute">uselessProp3</span>=<span class="literal">null</span>)12</span><br></pre></td></tr></table></figure><p>然后取消注释代码中的那行，也就是启用<code>WRAP_ROOT_VALUE</code>功能，再运行一下程序，运行结果如下。可以看到生成的JSON结果发生了变化，而且由于JSON结果变化，所以Java类转换失败（所有字段值全为空）。<code>WRAP_ROOT_VALUE</code>这个功能在有些时候比较有用，因为有些JSON文件需要这种结构。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"FriendDetail"</span>:&#123;<span class="string">"NickName"</span>:<span class="string">"yitian"</span>,<span class="string">"Age"</span>:25&#125;&#125;</span><br><span class="line">FriendDetail(<span class="attribute">name</span>=<span class="literal">null</span>, <span class="attribute">age</span>=0, <span class="attribute">uselessProp1</span>=<span class="literal">null</span>, <span class="attribute">uselessProp2</span>=0, <span class="attribute">uselessProp3</span>=<span class="literal">null</span>)12</span><br></pre></td></tr></table></figure></p><h3 id="Java8日期时间类支持"><a href="#Java8日期时间类支持" class="headerlink" title="Java8日期时间类支持"></a>Java8日期时间类支持</h3><p>Java8增加了一套全新的日期时间类，Jackson对此也有支持。这些支持是以Jackson模块形式提供的，所以首先就是注册这些模块。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper mapper = <span class="keyword">new</span> <span class="type">ObjectMapper</span>()</span><br><span class="line">        .registerModule(<span class="keyword">new</span> <span class="type">JavaTimeModule</span>())</span><br><span class="line">        .registerModule(<span class="keyword">new</span> <span class="type">ParameterNamesModule</span>())</span><br><span class="line">        .registerModule(<span class="keyword">new</span> <span class="type">Jdk8Module</span>());<span class="number">1234</span></span><br></pre></td></tr></table></figure></p><p>导入类库之后，Jackson也可以自动搜索所有模块，不需要我们手动注册。<br> <code>mapper.findAndRegisterModules();1</code></p><p>我们新建一个带有LocalDate字段的Java类。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line"><span class="variable">@NoArgsConstructor</span></span><br><span class="line"><span class="variable">@AllArgsConstructor</span></span><br><span class="line"><span class="variable">@JsonRootName</span>(<span class="string">"Person"</span>)</span><br><span class="line">public class Person &#123;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Name"</span>)</span><br><span class="line">    private String name;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"NickName"</span>)</span><br><span class="line">    private String nickname;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Age"</span>)</span><br><span class="line">    private int age;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"IdentityCode"</span>)</span><br><span class="line">    private String identityCode;</span><br><span class="line">    <span class="variable">@JsonProperty</span></span><br><span class="line">    <span class="variable">@JsonFormat</span>(pattern = <span class="string">"yyyy-MM-DD"</span>)</span><br><span class="line">    private LocalDate birthday;</span><br><span class="line"></span><br><span class="line">&#125;<span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure></p><p>然后来看看代码。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> java8DateTime() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">"yitian"</span>, <span class="string">"易天"</span>, <span class="number">25</span>, <span class="string">"10000"</span>, LocalDate.of(<span class="number">1994</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper()</span><br><span class="line">            .registerModule(<span class="keyword">new</span> JavaTimeModule());</span><br><span class="line">    <span class="comment">//mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span></span><br><span class="line">    <span class="keyword">String</span> <span class="built_in">text</span> = mapper.writeValueAsString(p1);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="built_in">text</span>);</span><br><span class="line"></span><br><span class="line">    Person p2 = mapper.readValue(<span class="built_in">text</span>, Person.class);</span><br><span class="line">    System.out.<span class="built_in">println</span>(p2);</span><br><span class="line">&#125;<span class="number">1234567891011</span></span><br></pre></td></tr></table></figure></p><p>运行结果如下。可以看到，生成的JSON日期变成了[1994,1,1]这样的时间戳形式，一般情况下不符合我们的要求。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"birthday"</span>:[1994,1,1],<span class="string">"Name"</span>:<span class="string">"yitian"</span>,<span class="string">"NickName"</span>:<span class="string">"易天"</span>,<span class="string">"Age"</span>:25,<span class="string">"IdentityCode"</span>:<span class="string">"10000"</span>&#125;</span><br><span class="line">Person(<span class="attribute">name</span>=yitian, <span class="attribute">nickname</span>=易天, <span class="attribute">age</span>=25, <span class="attribute">identityCode</span>=10000, <span class="attribute">birthday</span>=1994-01-01)12</span><br></pre></td></tr></table></figure></p><p>取消注释那行代码，程序运行结果如下。这样一来就变成了我们一般使用的形式了。如果有格式需要的话，可以使用<code>@JsonFormat(pattern = &quot;yyyy-MM-DD&quot;)</code>注解格式化日期显示。<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">"birthday"</span>:<span class="string">"1994-01-01"</span>,<span class="string">"Name"</span>:<span class="string">"yitian"</span>,<span class="string">"NickName"</span>:<span class="string">"易天"</span>,<span class="string">"Age"</span>:25,<span class="string">"IdentityCode"</span>:<span class="string">"10000"</span>&#125;</span><br><span class="line">Person(<span class="attribute">name</span>=yitian, <span class="attribute">nickname</span>=易天, <span class="attribute">age</span>=25, <span class="attribute">identityCode</span>=10000, <span class="attribute">birthday</span>=1994-01-01)12</span><br></pre></td></tr></table></figure></p><p>处理XML</p><p>Jackson是一个处理JSON的类库，不过它也通过<code>jackson-dataformat-xml</code>包提供了处理XML的功能。Jackson建议我们在处理XML的时候使用<code>woodstox-core</code>包，它是一个XML的实现，比JDK自带XML实现更加高效，也更加安全。</p><p>这里有个注意事项，如果你正在使用Java 9以上的JDK，可能会出现<code>java.lang.NoClassDefFoundError: javax/xml/bind/JAXBException</code>异常，这是因为Java 9实现了JDK的模块化，将原本和JDK打包在一起的JAXB实现分隔出来。所以这时候需要我们手动添加JAXB的实现。在Gradle中添加下面的代码即可。</p><p><code>compile group: &#39;javax.xml.bind&#39;, name: &#39;jaxb-api&#39;, version: &#39;2.3.0&#39;1</code></p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Jackson XML除了使用Jackson JSON和JDK JAXB的一些注解之外，自己也定义了一些注解。下面简单介绍一下几个常用注解。</p><p><code>@JacksonXmlProperty</code>注解有三个属性，<code>namespace</code>和<code>localname</code>属性用于指定XML命名空间的名称，<code>isAttribute</code>指定该属性作为XML的属性（）还是作为子标签（）.</p><p><code>@JacksonXmlRootElement</code>注解有两个属性，<code>namespace</code>和<code>localname</code>属性用于指定XML根元素命名空间的名称。</p><p><code>@JacksonXmlText</code>注解将属性直接作为未被标签包裹的普通文本表现。</p><p><code>@JacksonXmlCData</code>将属性包裹在CDATA标签中。</p><h3 id="XML映射"><a href="#XML映射" class="headerlink" title="XML映射"></a>XML映射</h3><p>新建如下一个Java类。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Data</span></span><br><span class="line"><span class="variable">@NoArgsConstructor</span></span><br><span class="line"><span class="variable">@AllArgsConstructor</span></span><br><span class="line"><span class="variable">@JsonRootName</span>(<span class="string">"Person"</span>)</span><br><span class="line">public class Person &#123;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Name"</span>)</span><br><span class="line">    private String name;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"NickName"</span>)</span><br><span class="line">    <span class="comment">//@JacksonXmlText</span></span><br><span class="line">    private String nickname;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Age"</span>)</span><br><span class="line">    private int age;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"IdentityCode"</span>)</span><br><span class="line">    <span class="variable">@JacksonXmlCData</span></span><br><span class="line">    private String identityCode;</span><br><span class="line">    <span class="variable">@JsonProperty</span>(<span class="string">"Birthday"</span>)</span><br><span class="line">    <span class="comment">//@JacksonXmlProperty(isAttribute = true)</span></span><br><span class="line">    <span class="variable">@JsonFormat</span>(pattern = <span class="string">"yyyy/MM/DD"</span>)</span><br><span class="line">    private LocalDate birthday;</span><br><span class="line"></span><br><span class="line">&#125;<span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure></p><p>下面是代码示例，基本上和JSON的API非常相似，XmlMapper实际上就是ObjectMapper的子类。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = new Person(<span class="string">"yitian"</span>, <span class="string">"易天"</span>, <span class="number">25</span>, <span class="string">"10000"</span>, LocalDate.of(<span class="number">1994</span>, <span class="number">1</span>, <span class="number">1</span>))<span class="comment">;</span></span><br><span class="line">XmlMapper mapper = new XmlMapper()<span class="comment">;</span></span><br><span class="line">mapper.findAndRegisterModules()<span class="comment">;</span></span><br><span class="line">mapper.<span class="keyword">disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span></span><br><span class="line"><span class="keyword">mapper.enable(SerializationFeature.INDENT_OUTPUT);</span></span><br><span class="line"><span class="keyword">String </span>text = mapper.writeValueAsString(p1)<span class="comment">;</span></span><br><span class="line">System.out.println(text)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">Person p2 = mapper.readValue(text, Person.class)<span class="comment">;</span></span><br><span class="line">System.out.println(p2)<span class="comment">;12345678910</span></span><br></pre></td></tr></table></figure></p><p>运行结果如下。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>yitian<span class="tag">&lt;/<span class="name">Name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">NickName</span>&gt;</span>易天<span class="tag">&lt;/<span class="name">NickName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Age</span>&gt;</span>25<span class="tag">&lt;/<span class="name">Age</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">IdentityCode</span>&gt;</span>&lt;![CDATA[10000]]&gt;<span class="tag">&lt;/<span class="name">IdentityCode</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Birthday</span>&gt;</span>1994/01/01<span class="tag">&lt;/<span class="name">Birthday</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Person(name=yitian, nickname=易天, age=25, identityCode=10000, birthday=1994-01-01)123456789</span><br></pre></td></tr></table></figure><p>如果取消那两行注释，那么运行结果如下。可以看到Jackson XML注解对生成的XML的控制效果。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">birthday</span>=<span class="string">"1994/01/01"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Name</span>&gt;</span>yitian<span class="tag">&lt;/<span class="name">Name</span>&gt;</span>易天</span><br><span class="line">  <span class="tag">&lt;<span class="name">Age</span>&gt;</span>25<span class="tag">&lt;/<span class="name">Age</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">IdentityCode</span>&gt;</span>&lt;![CDATA[10000]]&gt;<span class="tag">&lt;/<span class="name">IdentityCode</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Person</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Person(name=yitian, nickname=null, age=25, identityCode=10000, birthday=1994-01-01)1234567</span><br></pre></td></tr></table></figure></p><h3 id="Spring-Boot集成"><a href="#Spring-Boot集成" class="headerlink" title="Spring Boot集成"></a>Spring Boot集成</h3><p>自动配置</p><p>Spring Boot对Jackson的支持非常完善，只要我们引入相应类库，Spring Boot就可以自动配置开箱即用的Bean。Spring自动配置的ObjectMapper（或者XmlMapper）作了如下配置，基本上可以适应大部分情况。</p><p>禁用了<code>MapperFeature.DEFAULT_VIEW_INCLUSION</code><br>禁用了<code>DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES</code><br>禁用了<code>SerializationFeature.WRITE_DATES_AS_TIMESTAMPS</code></p><p>如果需要修改自动配置的ObjectMapper属性也非常简单，Spring Boot提供了一组环境变量，直接在application.properties文件中修改即可。</p><table><thead><tr><th>Jackson枚举</th><th>Spring环境变量</th></tr></thead><tbody><tr><td></td></tr></tbody></table><p>com.fasterxml.jackson.databind.DeserializationFeature|spring.jackson.deserialization.=true|false<br>com.fasterxml.jackson.core.JsonGenerator.Feature|spring.jackson.generator.=true|false<br>com.fasterxml.jackson.databind.MapperFeature|spring.jackson.mapper.=true|false<br>com.fasterxml.jackson.core.JsonParser.Feature|spring.jackson.parser.=true|false<br>com.fasterxml.jackson.databind.SerializationFeature|spring.jackson.serialization.=true|false<br>com.fasterxml.jackson.annotation.JsonInclude.Include|spring.jackson.default-property-inclusion=always|non_null|non_absent|non_default|non_empty</p><p>由于Spring会同时配置相应的<code>HttpMessageConverters</code>，所以我们其实要做的很简单，用Jackson注解标注好要映射的Java类，然后直接让控制器返回对象即可！下面是一个Java类。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonRootName(<span class="meta-string">"person"</span>)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@JsonProperty</span></span><br><span class="line">    <span class="keyword">private</span> int id;</span><br><span class="line">    <span class="meta">@JsonFormat(pattern = <span class="meta-string">"yyyy-MM-DD"</span>)</span></span><br><span class="line">    <span class="keyword">private</span> LocalDate birthday;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Person(String name, int id, LocalDate birthday) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure></p><p>然后是控制器代码。在整个过程中我们只需要引入Jackson类库，然后编写业务代码就好了。关于如何配置Jackson类库，我们完全不需要管，这就是Spring Boot的方便之处。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person person = new Person(<span class="string">"yitian"</span>, <span class="number">10000</span>, LocalDate.of(<span class="number">1994</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(<span class="meta-string">"/"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> String index() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"index"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = <span class="meta-string">"/json"</span>, produces = <span class="meta-string">"application/json"</span>)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> Person json() &#123;</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure><p>进入localhost:8080/xml就可以看到对应结果了。 </p><h4 id="手动配置"><a href="#手动配置" class="headerlink" title="手动配置"></a>手动配置</h4><p>Spring Boot自动配置非常方便，但不是万能的。在必要的时候，我们需要手动配置Bean来替代自动配置的Bean。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Qualifier(<span class="meta-string">"xml"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> XmlMapper xmlMapper(Jackson2ObjectMapperBuilder builder) &#123;</span><br><span class="line">        XmlMapper mapper = builder.createXmlMapper(<span class="literal">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">        mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Qualifier(<span class="meta-string">"json"</span>)</span></span><br><span class="line">    <span class="keyword">public</span> ObjectMapper jsonMapper(Jackson2ObjectMapperBuilder builder) &#123;</span><br><span class="line">        ObjectMapper mapper = builder.createXmlMapper(<span class="literal">false</span>)</span><br><span class="line">                .build();</span><br><span class="line">        mapper.enable(SerializationFeature.INDENT_OUTPUT);</span><br><span class="line">        mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);</span><br><span class="line">        <span class="keyword">return</span> mapper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure><p>然后在需要的地方进行依赖注入。需要注意为了区分ObjectMapper和XmlMapper，需要使用@Qualifier注解进行标记。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainController</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ObjectMapper jsonMapper;</span><br><span class="line">    <span class="keyword">private</span> XmlMapper xmlMapper;</span><br><span class="line">    <span class="keyword">private</span> Person person = new Person(<span class="string">"yitian"</span>, <span class="number">10000</span>, LocalDate.of(<span class="number">1994</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> MainController(<span class="meta">@Autowired</span> <span class="meta">@Qualifier(<span class="meta-string">"json"</span>)</span> ObjectMapper jsonMapper, <span class="meta">@Autowired</span> <span class="meta">@Qualifier(<span class="meta-string">"xml"</span>)</span> XmlMapper xmlMapper) &#123;</span><br><span class="line">        <span class="keyword">this</span>.jsonMapper = jsonMapper;</span><br><span class="line">        <span class="keyword">this</span>.xmlMapper = xmlMapper;</span><br><span class="line">    &#125;<span class="number">12345678910</span></span><br></pre></td></tr></table></figure><p>以上就是Jackson类库的一些介绍，希望对大家有所帮助。</p><hr><p>本文来自 过了即是客 的CSDN 博客 ，全文地址请点击：<a href="https://blog.csdn.net/u011054333/article/details/80504154?utm_source=copy" target="_blank" rel="noopener">https://blog.csdn.net/u011054333/article/details/80504154?utm_source=copy</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java生态圈中有很多处理JSON和XML格式化的类库，Jackson是其中比较著名的一个。虽然JDK自带了XML处理类库，但是相对来说比较低级，使用本文介绍的Jackson等高级类库处理起来会方便很多。&lt;/p&gt;
&lt;h3 id=&quot;引入类库&quot;&gt;&lt;a href=&quot;#引入类库&quot; 
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>集成React-Native到现有项目采坑记录</title>
    <link href="http://yoursite.com/2018/07/30/android/Android%20Studio3.1.3%E5%8D%87%E7%BA%A7%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95%E4%BB%A5%E5%8F%8A%E8%AE%B0%E5%BD%95%E5%87%A0%E4%B8%AA%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2018/07/30/android/Android Studio3.1.3升级踩坑记录以及记录几个好用的插件/</id>
    <published>2018-07-30T07:47:55.000Z</published>
    <updated>2018-10-05T16:36:45.280Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看到AS每天提醒更新，所以没忍住还是从3.0更新到了3.1.3,于是乎项目就跑不起来了。另外由于之前把android studio 的配置文件改了，更新完又变成了默认的配置路径，所以还要把配置文件改一下。以下是踩坑记录</p></blockquote><p>###1、Gradle 编译问题的修改</p><p>（1）gradle 编译版本对应的build gradle插件版本详情 官网<br><a href="https://developer.android.google.cn/studio/releases/gradle-plugin#updating-plugin" target="_blank" rel="noopener">https://developer.android.google.cn/studio/releases/gradle-plugin#updating-plugin</a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:3.1.3'</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        maven &#123; url <span class="string">"https://jitpack.io"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>buildscript定义了全局的相关属性<br>repositories定义仓库：一个仓库代表着依赖包的来源，例如jcenter仓库dependencies用来定义构建过程：仅仅需要定义默认的Android插件，该插件可以让你执行相关Android的tasks，注意：不应该在该方法体内定义子模块的依赖包。<br>allprojects用来定义各个模块的默认属性：不仅仅局限于默认的配置，也可以自己创造tasks在allprojects方法体内，这些tasks将会在所有模块中可见。<br>我升级完android studio 使用的是 Gradle 4.4  以及插件  <strong>classpath ‘com.android.tools.build:gradle:3.1.3’</strong></p></blockquote><p>(2) compile   2018年底要废弃，使用implementtabion 和api 替换<br>官网<br><a href="http://d.android.com/r/tools/update-dependency-configurations.html" target="_blank" rel="noopener">http://d.android.com/r/tools/update-dependency-configurations.html</a><br><a href="https://developer.android.com/studio/build/dependencies" target="_blank" rel="noopener">https://developer.android.com/studio/build/dependencies</a></p><p>依赖库中所有的compile全部替换为 api，主程序的compile 替换为implementation</p><p>###2、 compile和 implementation 和api 有什么区别<br>（1）implementation:<br>Gradle将依赖项添加到编译类路径，并将依赖项打包到构建输出。但是，当您的模块配置implementation依赖项时，它让Gradle知道您不希望模块在编译时将依赖项泄漏给其他模块。也就是说，依赖性仅在运行时可用于其他模块。<br>使用这种依赖性配置，而不是 api或compile（不建议使用）可导致 显著编译时间的改进，因为它减少了构建系统需要重新编译的模块的数量。例如，如果implementation依赖项更改其API，则Gradle仅重新编译该依赖项以及直接依赖于它的模块。大多数应用和测试模块都应使用此配置。<br>（2）api<br>Gradle将依赖项添加到编译类路径并构建输出。当一个模块包含一个api依赖项时，它让Gradle知道该模块想要将该依赖项传递给其他模块，以便它们在运行时和编译时都可用。<br>此配置的行为就像compile （现在已弃用），但您应谨慎使用它，并且只能将您需要的依赖项可传递地导出到其他上游使用者。这是因为，如果api依赖项更改其外部API，Gradle将重新编译在编译时有权访问该依赖项的所有模块。因此，拥有大量api依赖项可以显着增加构建时间。除非您希望将依赖项的API公开给单独的模块，否则库模块应该使用implementation 依赖项。<br><strong>小结：</strong><br>api 等同于 compile ，并且是可以引用传递，比如A  Library 依赖了B  Library，而B Library 依赖了 C Library，使用 api或compile(已废弃)的话，A Library 就可以调用 C Library 的代码。实现了一层层的依赖，这种方式耦合度高一点，并且编译的话都需要编译一遍。</p><p>implementation  就是只管当前 moudle， 比如A  Library 依赖了B  Library，而B Library 依赖了 C Library，使用implementation的话，A Library 就不可以调用 C Library 的代码。implementation 依赖的库，其他moudle是访问不到的。<br><strong>建议：在Google IO 中提到了一个建议，依赖首先应该设置为implementation的，如果没有错，那就用implementation，如果有错，那么使用api指令。<code>使用implementation会使编译速度有所增快。</code></strong></p><p>3、解决 升级完 使用java 8  LifecycleObserver 时出现错误，<br>依赖  implementation “android.arch.lifecycle:common-java8:$lifecycle_version” 时的错误</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Default<span class="built_in"> interface </span>methods are only supported starting with Android N (--min-api 24):</span><br><span class="line"> void ndroid.arch.lifecycle.DefaultLifecycleObserver.onCreate(android.arch.lifecycle.LifecycleOwner)</span><br><span class="line">Message&#123;<span class="attribute">kind</span>=ERROR, <span class="attribute">text</span>=Default<span class="built_in"> interface </span>methods are only supported starting with Android N </span><br><span class="line">(--min-api 24): void android.arch.lifecycle.DefaultLifecycleObserver.onCreate</span><br><span class="line">(android.arch.lifecycle.LifecycleOwner), sources=[Unknown source file],<span class="built_in"> tool </span><span class="attribute">name</span>=Optional.of(D8)&#125;</span><br></pre></td></tr></table></figure><p>如果依赖这个库，那么只能使用最小24 版本，这就太坑了。解决办法如下<br>在 build.gradle  的 android{} 闭包下 添加如下代码，重新编译就好了</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">       sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">       targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>###3、顺便更新几个好用的插件<br><strong>（1）Android Parcelable code generator</strong><br>​         JavaBean序列化，快速实现Parcelable接口。<br><strong>（2）CodeGlance</strong><br>在右边快速浏览代码缩略，快速定位代码，特别好用<br><strong>（3）findBugs-IDEA</strong><br>一款查找bug的插件<br><strong>（4）JsonOnlineViewer</strong><br>在android studio 内部打开api接口测试的窗口，进行接口调试<br><strong>（5）ECTranslation</strong><br>一款翻译插件<br><strong>（6）AndroidWiFiADB</strong><br>通过WiFi 无线调试手机的 插件<br> <strong>（7）Alibaba Java Coding Guidelines</strong><br>阿里巴巴的 java开发约束扫描插件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;看到AS每天提醒更新，所以没忍住还是从3.0更新到了3.1.3,于是乎项目就跑不起来了。另外由于之前把android studio 的配置文件改了，更新完又变成了默认的配置路径，所以还要把配置文件改一下。以下是踩坑记录&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>集成React-Native到现有项目采坑记录</title>
    <link href="http://yoursite.com/2018/07/30/android/%E9%9B%86%E6%88%90React-Native%E5%88%B0%E7%8E%B0%E6%9C%89%E9%A1%B9%E7%9B%AE%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2018/07/30/android/集成React-Native到现有项目采坑记录/</id>
    <published>2018-07-30T07:47:53.000Z</published>
    <updated>2018-10-05T16:37:31.488Z</updated>
    
    <content type="html"><![CDATA[<p>###集成步骤<br>官方文档：<a href="https://facebook.github.io/react-native/docs/0.54/integration-with-existing-apps" target="_blank" rel="noopener">https://facebook.github.io/react-native/docs/0.54/integration-with-existing-apps</a><br>借鉴博客：<a href="https://blog.csdn.net/u012455070/article/details/78926526" target="_blank" rel="noopener">https://blog.csdn.net/u012455070/article/details/78926526</a></p><blockquote><p>（1）配置react-native的开发环境<br>（2）创建一个react-native 的项目<br>（3）把项目中的android目录里面的东西换成现有的项目<br>（4）配置android项目的build.gradle文件以及各种依赖<br>（5）运行项目，运行服务，设置ip端口调试。<br>（6）各种踩坑问题，比如不支持64位手机的so库问题，找不到服务，由于react native 版本问题导致的各种错误等等</p></blockquote><p>官方文档的集成步骤；<br>1、安装 node.js  python2   jdk 8<br>这个安装过程就不说了。网上一大堆<br>2、下载更新React Native CLI<br>命令：<code>npm install -g react-native-cli</code><br>执行这行命令就可以使用react-native 命令了。比如 使用命令运行<br>3、android 环境配置和模拟器或者手机连接<br>由于我是做android的，所以这些就跳过了，不清楚的看官方文档或者上网查<br>4、<strong>创建新的应用程序</strong><br>重点来了，创建应用的时候执行命令：<code>react-native init AwesomeProject</code>  这里的AwesomeProject是项目名称可以随便换，但是必须以字母开头。 由于下载是在国外所以特别慢，所以我们要添加以下国内镜像。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> registry https:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line">npm config <span class="keyword">set</span> disturl https:<span class="comment">//npm.taobao.org/dist</span></span><br></pre></td></tr></table></figure><p>这两个都可以，会显著提高下载速度。设置了镜像，然后再执行创建的命令。<br><strong>5、运行新应用的采坑记录</strong><br>指定react  和react-native 的版本。<br>项目目录下的 node_modules 文件夹是 reactnative 所依赖的js的一些东西。<br>如果没有，我们可以再项目跟目录执行 <code>npm install</code> 命令下载<br>这个时候我们要注意一下版本号，因为这里遇到坑了。目前最新的react–native可能是0.56 会出现一个bug<br>比如最新版本</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">react-native-cli</span>: 2<span class="selector-class">.0</span><span class="selector-class">.1</span></span><br><span class="line"><span class="selector-tag">react-native</span>: 0<span class="selector-class">.56</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure><p>但是运行的时候出现 <strong>Unable to resolve module ‘AccessibilityInfo’</strong> 这个错误，所以建议还是版本低一点，这里使用稳定版<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180730/fDJcG823jc.png?imageslim" alt="mark"></p><p><strong>切换步骤：</strong><br>（1）先将旧版卸载</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> uninstall -g react-<span class="keyword">native</span>-cli</span><br><span class="line"><span class="built_in">npm</span> uninstall -g react-<span class="keyword">native</span></span><br></pre></td></tr></table></figure><p>（2）再安装指定版本</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g react-<span class="keyword">native</span>@<span class="number">0.55</span>.<span class="number">4</span></span><br><span class="line"><span class="built_in">npm</span> install -g react-<span class="keyword">native</span>-cli@<span class="number">1.2</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以再项目初始化的时候指定下，不指定的话，只要版本对也没问题，自己查看下</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-<span class="keyword">native</span> init --version=<span class="string">"0.55.4"</span> myFirstApp</span><br></pre></td></tr></table></figure><p>6、解决红屏错误：<strong>Module build failed: Error: Plugin 0 specified in “base” … provided an invalid property of “default”</strong><br>如果出现上面错误执行下面命令</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">npm</span> <span class="selector-tag">install</span> <span class="selector-tag">--save-dev</span> <span class="selector-tag">babel-preset-react-native</span>@<span class="keyword">2</span>.<span class="keyword">1</span>.<span class="keyword">0</span></span><br></pre></td></tr></table></figure><p>7、解决 React_Native 无法运行再64位机器上<br>“/data/data/com.xxx.xxx/lib-main/libgnustl_shared.so” is 32-bit instead of 64-bit  这个错误<br>参考文章：<a href="https://blog.csdn.net/u013531824/article/details/53931307" target="_blank" rel="noopener">https://blog.csdn.net/u013531824/article/details/53931307</a><br>Android不能同时加载32和64位本机库。 如果您至少有一个依赖库使用ARM64支持编译的扩展，而另外一些依赖库仅支持ARM32，就会出现问题。 系统将检测ARM64依赖关系，加载它，然后拒绝加载仅ARM32的so库，就可能导致应用程序崩溃。<br>所以，要再项目中excute  64位的几个so库，使用32位的。<br>这个根据不同项目设置，查一下自己项目用到了哪些64位的so库，都设置一遍<br>我的项目需要移除这些，然后就不报错了。Native Libs Monitor 这个软件很好用<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ndk</span> &#123;</span><br><span class="line">       //设置支持的SO库架构</span><br><span class="line">       abiFilters <span class="string">'armeabi'</span>, <span class="string">'x86'</span>, <span class="string">'armeabi-v7a'</span>, <span class="string">'x86_64'</span>, <span class="string">'arm64-v8a'</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">packagingOptions</span> &#123;</span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/libgnustl_shared.so"</span></span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/libijkffmpeg.so"</span></span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/libijkplayer.so"</span></span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/libijksdl.so"</span></span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/libimagepipeline.so"</span></span><br><span class="line">       <span class="literal">exclude</span> <span class="string">"lib/arm64-v8a/librtmp-jni.so"</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>8、把android 原生项目拷贝到reactnative 项目的android 目录下<br>上面步骤可以运行一个react-native 的简单项目，接下来时怎么集成到现有的Android 项目<br> react-native  项目结构如下：<br> <img src="http://oima95jt3.bkt.clouddn.com/blog/180730/K3g273KLmD.png?imageslim" alt="mark"><br> 我们做android的话，是用Android studio 打开 android 这个目录的。<br> 6、修改gradle 的依赖配置<br> dependencies {}闭包下 所有的compile 替换位implementation 或者api因为我的Android studio是3.1.3，老报错说compile 2018年底要删除已废弃。另外我的gradle是4.4  build gradle 工具 是3.1.3<br> （1）Android 项目根目录的 build.gradle文件修改<br> 如下：如果还是不行，建议跟我一样，加上google(). .可能如果是最新版 jencter有问题，用的时候调整下顺序试一试。尽量不要用最新版本的react-native<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">allprojects </span>&#123;</span><br><span class="line">    <span class="class">repositories </span>&#123;</span><br><span class="line">        google()</span><br><span class="line">        jcenter()</span><br><span class="line">        <span class="class">maven </span>&#123; url <span class="string">"https://jitpack.io"</span> &#125;</span><br><span class="line">        <span class="comment">//添加这个maven地址，不然无法下载 react-native库</span></span><br><span class="line">        <span class="class">maven </span>&#123;</span><br><span class="line">            <span class="comment">// All of React Native (JS, Android binaries) is installed from npm</span></span><br><span class="line">            url <span class="string">"$rootDir/../node_modules/react-native/android"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再app 的build.gradle 中添加依赖<br>使用api 或者implementation 都可以， 这里我也制定了版本。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">.........</span><br><span class="line">api <span class="string">"com.facebook.react:react-native:0.55.4"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>7、配置权限</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.INTERNET"</span> /&gt;</span><br><span class="line"><span class="comment">//我还要添加一个权限，建议也添加了</span></span><br><span class="line">&lt;uses-permission <span class="string">android:</span>name=<span class="string">"android.permission.SYSTEM_ALERT_WINDOW"</span>/&gt;</span><br></pre></td></tr></table></figure><p>再调试的时候我们一般需要访问DevSettingsActivity，所以也需要添加到AndroidManifest.xml：<br>手机摇一摇，或者菜单，设置 电脑服务的ip地址和端口要用到</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:<span class="built_in">name</span>=<span class="string">"com.facebook.react.devsupport.DevSettingsActivity"</span> /&gt;</span><br></pre></td></tr></table></figure><p>8、代码集成<br>刚刚创建的最简单的react-native 已经有了。我们就再我们Android 项目中加载这个最简单的页面</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReactActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">DefaultHardwareBackBtnHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> OVERLAY_PERMISSION_REQ_CODE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> ReactRootView mReactRootView;</span><br><span class="line">    <span class="keyword">private</span> ReactInstanceManager mReactInstanceManager;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="comment">//这里不加权限判断 6.0或以上机型会闪退</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!Settings.canDrawOverlays(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION,</span><br><span class="line">                        Uri.parse(<span class="string">"package:"</span> + getPackageName()));</span><br><span class="line">                startActivityForResult(intent, OVERLAY_PERMISSION_REQ_CODE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mReactRootView = <span class="keyword">new</span> ReactRootView(<span class="keyword">this</span>);</span><br><span class="line">        mReactInstanceManager = ReactInstanceManager.builder()</span><br><span class="line">                .setApplication(getApplication())</span><br><span class="line">                <span class="comment">//这是设置assets目录下的打包过的js文件名 这个文件可用命令生成 但调试期间我们使用npm server动态注入 发布时才将它打进assets</span></span><br><span class="line">                .setBundleAssetName(<span class="string">"index.android.bundle"</span>)</span><br><span class="line">                <span class="comment">//这里设置js入口文件 旧一点的api可能是setJSMainModuleName 但我的版本是0.51.0 取而代之的是setJSMainModulePath方法</span></span><br><span class="line">                .setJSMainModulePath(<span class="string">"index"</span>)</span><br><span class="line">                .addPackage(<span class="keyword">new</span> MainReactPackage())</span><br><span class="line">                .setUseDeveloperSupport(BuildConfig.DEBUG)</span><br><span class="line">                .setInitialLifecycleState(LifecycleState.RESUMED)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的“FirstApp”必须</span></span><br><span class="line">        <span class="comment">// 对应index.js”中的“AppRegistry.registerComponent()”的第一个参数值</span></span><br><span class="line">        <span class="comment">// 对应“package.json”中的“name”属性值</span></span><br><span class="line">        <span class="comment">// 最好也将“app.json”中的“name”和“displayName”改成它</span></span><br><span class="line">        mReactRootView.startReactApplication(mReactInstanceManager, <span class="string">"FirstApp"</span>, <span class="keyword">null</span>);</span><br><span class="line">        setContentView(mReactRootView);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == OVERLAY_PERMISSION_REQ_CODE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!Settings.canDrawOverlays(<span class="keyword">this</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">invokeDefaultOnBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onHostPause(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onHostResume(<span class="keyword">this</span>, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onHostDestroy(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mReactRootView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactRootView.unmountReactApplication();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.onBackPressed();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">onKeyUp</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; mReactInstanceManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mReactInstanceManager.showDevOptionsDialog();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="keyword">super</span>.<span class="title">onKeyUp</span><span class="params">(keyCode, event)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是我的activity，大概意思和官网一样。。代码直接复制就行，需要注意的是：<br>代码制定的文件名一定要和 配置文件中的一致，要检查<br>app.json中的name和displayName属性值<br>ndex.js中registerComponent的第一个参数值<br>package.json中的name属性值<br>这几个值要保持一致</p><p>9、在真机上运行项目<br>直接在 reat-native  项目根目录运行命令  react-native run-android , 跳转到上面activity<br>然后运行起来如果是红屏，说是连不上服务，就摇一摇手机，选择 Debug server host 啥的，设置电脑的ip:8081 这样就能打开了。<br>或者，直接用Android studio 运行自己的Android 项目， 跳转到上面react  的activity ，也可以是fragment的。<br>如果出现错误，继续百度谷歌解决。。。有坑是肯定的嘛。先记录这些</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;###集成步骤&lt;br&gt;官方文档：&lt;a href=&quot;https://facebook.github.io/react-native/docs/0.54/integration-with-existing-apps&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件官方文档03——ViewModel</title>
    <link href="http://yoursite.com/2018/07/02/android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A303%E2%80%94%E2%80%94ViewModel/"/>
    <id>http://yoursite.com/2018/07/02/android/Android架构组件官方文档03——ViewModel/</id>
    <published>2018-07-02T09:58:17.000Z</published>
    <updated>2018-07-02T09:59:05.188Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ViewModel概述"><a href="#ViewModel概述" class="headerlink" title="ViewModel概述"></a>ViewModel概述</h3><p><a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>类旨在以一种有生命周期意识的方式存储和管理与UI相关的数据。<br><a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>类允许数据在配置变化（例如屏幕旋转）后存活。<br><strong>注意：要将ViewModel导入到Android项目中，请参阅<a href="https://developer.android.google.cn/topic/libraries/architecture/adding-components.html#lifecycle" target="_blank" rel="noopener">向项目添加组件</a></strong></p><p>Android framework管理UI控制器的生命周期，例如Activity和Fragment。<br>framework可能会决定销毁或重新创建UI控制器，以响应完全不受您控制的特定用户操作或设备事件。</p><p>如果系统销毁或重新创建UI控制器，则存储在其中的任何临时UI相关的数据都将丢失。例如，您的应用可能包含其中一项活动中的用户列表。当为配置更改重新创建活动时，新活动必须重新获取用户列表。<br>对于简单的数据，Activity可以使用<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onSaveInstanceState%28android.os.Bundle%29" target="_blank" rel="noopener">onSaveInstanceState()</a>方法并从<a href="https://developer.android.google.cn/reference/android/app/Activity.html#onCreate%28android.os.Bundle%29" target="_blank" rel="noopener">onCreate()</a>中的bundle中恢复其数据，但此方法仅适用于可以序列化然后反序列化的少量数据，可能不适合像用户或位图的列表这样的大量数据。</p><p>另一个问题是UI控制器经常需要进行异步调用，这可能需要一些时间才能返回。UI控制器需要管理这些调用，并确保系统在销毁后清理它们以避免潜在的内存泄漏。这种管理需要大量的维护，并且在为配置更改而重新创建对象的情况下，由于对象可能不得不重新发出已经做出的请求，所以浪费资源。</p><p>UI控制器（如Activity和Fragment）主要用于显示UI数据，对用户操作做出反应或处理操作系统通信（如权限请求）。如果要求UI控制器也负责从数据库或网络加载数据，就会使改类变得臃肿。为UI控制器分配过多的责任可能会导致一个类尝试单独处理应用程序的所有工作，而不是将工作委托给其他类。通过这种方式给UI控制器分配过多的责任也使测试变得更加困难。</p><p>将视图数据所有权从UI控制器逻辑中分离出来更简单，更高效。</p><h3 id="实现一个ViewModel"><a href="#实现一个ViewModel" class="headerlink" title="实现一个ViewModel"></a>实现一个ViewModel</h3><p>架构组件为UI控制器提供<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>助手类。<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>对象在配置更改期间会自动保留，以便它们保存的数据立即可用于下一个Activity或fragment实例。例如，如果您需要在应用中显示用户列表，请明确分配职责来获取数据并将用户列表保存到ViewModel，而不是Activity或fragment，如以下示例代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MutableLiveData</span>&lt;<span class="type">List</span>&lt;<span class="type">User</span>&gt;&gt; users;</span><br><span class="line">    public <span class="type">LiveData</span>&lt;<span class="type">List</span>&lt;<span class="type">User</span>&gt;&gt; getUsers() &#123;</span><br><span class="line">        <span class="keyword">if</span> (users == <span class="literal">null</span>) &#123;</span><br><span class="line">            users = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="type">List</span>&lt;<span class="type">User</span>&gt;&gt;();</span><br><span class="line">            loadUsers();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void loadUsers() &#123;</span><br><span class="line">        <span class="comment">// Do an asynchronous operation to fetch users.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以从一个Activity中访问列表，如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="comment">// Create a ViewModel the first time the system calls an activity's onCreate() method.</span></span><br><span class="line">        <span class="comment">// Re-created activities receive the same MyViewModel instance created by the first activity.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">MyViewModel</span> model = <span class="type">ViewModelProviders</span>.of(<span class="keyword">this</span>).get(<span class="type">MyViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line">        model.getUsers().observe(<span class="keyword">this</span>, users -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果Activity重新创建，它将接收由第一个Activity创建的相同的MyViewModel实例。当持有ViewModel的Activity finish后，框架将调用ViewModel对象的onCleared()方法，以便它可以清理资源。</p><p><strong>警告：ViewModel绝不能引用视图，生命周期或可能持有对活动上下文的引用的任何类。</strong></p><p><a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>对象被设计为脱离视图或LifecycleOwners的特定实例。这种设计还意味着您可以更轻松地编写测试来覆盖ViewModel，因为它不知道视图和生命周期对象。ViewModel对象可以包含LifecycleObservers，例如LiveData对象。但是，ViewModel对象绝不能观察对生命周期感知的可观察对象（如LiveData对象）的更改。如果ViewModel需要应用程序上下文（例如查找系统服务），那么它可以扩展AndroidViewModel类并具有构造函数，该构造函数在构造函数中接收Application，因为Application类扩展了Context。</p><h3 id="ViewMode的生命周期"><a href="#ViewMode的生命周期" class="headerlink" title="ViewMode的生命周期"></a>ViewMode的生命周期</h3><p>ViewModel对象的范围是在获取ViewModel时传递给<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModelProvider.html" target="_blank" rel="noopener">ViewModelProvider</a>的生命周期。ViewModel保留在内存中，直到生命周期的范围永久消失：在一个Activity的情况下，finish()时，在一个Fragment的情况下，当它被detached(分离)时。</p><p>图1说明了一个Activity在进行一次旋转然后finish后的各种生命周期状态。该图还显示了相关Activity生命周期旁边ViewModel的生命周期。这个特定的图表说明了一个Activity的状态。这些相同的基本状态同样适用于Fragment的生命周期。<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180702/KjKH5m6E8m.png?imageslim" alt="mark"></p><p>系统首次调用Activity对象的onCreate()方法时，通常会请求<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>。系统可能会在整个Activity的生命周期中多次调用onCreate()，例如当设备屏幕旋转时。<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>从第一次请求<a href="https://developer.android.google.cn/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>直到Activity finished 和销毁时一直存在。</p><h3 id="在片段之间共享数据"><a href="#在片段之间共享数据" class="headerlink" title="在片段之间共享数据"></a>在片段之间共享数据</h3><p>Activity中的两个或更多fragment需要彼此进行通信是很常见的。想象一下，主-从关系的F让给met的一种常见情况，其中有一个Fragment，用户从列表中选择一个项目，另一个fragment显示所选项目的内容。这种情况有些麻烦，因为这两个片段都需要定义一些接口描述，并且所有者Activity必须将两者绑定在一起。此外，这两个fragment必须处理其他fragment尚未创建或可见的场景。</p><p>可以使用ViewModel对象解决这个常见的痛点。这些fragment可以使用其Activity范围共享ViewModel来处理此通信，如以下示例代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">SharedViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">MutableLiveData</span>&lt;<span class="type">Item</span>&gt; selected = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="type">Item</span>&gt;();</span><br><span class="line"></span><br><span class="line">    public void select(<span class="type">Item</span> item) &#123;</span><br><span class="line">        selected.setValue(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public <span class="type">LiveData</span>&lt;<span class="type">Item</span>&gt; getSelected() &#123;</span><br><span class="line">        <span class="keyword">return</span> selected;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MasterFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SharedViewModel</span> model;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        model = <span class="type">ViewModelProviders</span>.of(getActivity()).get(<span class="type">SharedViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line">        itemSelector.setOnClickListener(item -&gt; &#123;</span><br><span class="line">            model.select(item);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DetailFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    public void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        <span class="type">SharedViewModel</span> model = <span class="type">ViewModelProviders</span>.of(getActivity()).get(<span class="type">SharedViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line">        model.getSelected().observe(<span class="keyword">this</span>, item -&gt; &#123;</span><br><span class="line">           <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，在获取ViewModelProvider时，这两个Fragment都使用getActivity()。因此，两个Fragment 都接收相同的SharedViewModel实例，该实例的范围限定为Activity。<br>这种方法具有以下优点：</p><ul><li><p>Activity不需要做任何事情，也不需要了解这种沟通。</p></li><li><p>除了SharedViewModel约定之外，fragment不需要彼此了解。如果其中一个fragment消失，另一个fragment继续照常工作。</p></li><li><p>每个片fragment都有其自己的生命周期，并且不受其他生命周期的影响。如果一个fragment替换另一个fragment，UI将继续工作而不会出现任何问题。</p></li></ul><h3 id="用ViewModel替换Loaders"><a href="#用ViewModel替换Loaders" class="headerlink" title="用ViewModel替换Loaders"></a>用ViewModel替换Loaders</h3><p>像<a href="https://developer.android.google.cn/reference/android/content/CursorLoader.html" target="_blank" rel="noopener">CursorLoader</a>这样的Loader类经常用于保持应用程序UI中的数据与数据库同步。您可以使用ViewModel和其他几个类来替换Loaders。使用ViewModel将您的UI控制器与数据加载操作分开，这意味着您在类之间的强引用减少了。</p><p>在使用loaders的一种常见方法中，应用程序可能使用CursorLoader来观察数据库的内容。当数据库中的值发生更改时，加载程序会自动触发重新加载数据并更新UI：<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180702/akE7BEdHC6.png?imageslim" alt="mark"><br><strong>图2.使用加载器加载数据</strong></p><p>ViewModel与Room和LiveData一起使用来替换Loaders。ViewModel可确保数据在设备配置更改后仍然存在。当数据库发生更改时，Room会通知您的LiveData，而LiveData则会用修改的数据更新您的UI。<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180702/aIAdcEJ71B.png?imageslim" alt="mark"><br><strong>图3.使用ViewModel加载数据</strong></p><p><a href="https://medium.com/google-developers/lifecycle-aware-data-loading-with-android-architecture-components-f95484159de4" target="_blank" rel="noopener">此博客文章</a>描述了如何将ViewModel与LiveData一起使用来替换<a href="https://developer.android.google.cn/reference/android/content/AsyncTaskLoader.html" target="_blank" rel="noopener">AsyncTaskLoader</a>。</p><p>随着你的数据变得越来越复杂，你可能会选择一个单独的类来加载数据。ViewModel的目的是封装UI控制器的数据，以使数据不受配置更改的影响。有关如何跨配置更改加载，保留和管理数据的信息，请参阅<a href="https://developer.android.google.cn/topic/libraries/architecture/saving-states.html" target="_blank" rel="noopener">保存UI状态</a>。</p><p><a href="https://developer.android.google.cn/topic/libraries/architecture/guide.html#fetching_data" target="_blank" rel="noopener">Android App Architecture指南</a>建议构建一个存储库类来处理这些功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ViewModel概述&quot;&gt;&lt;a href=&quot;#ViewModel概述&quot; class=&quot;headerlink&quot; title=&quot;ViewModel概述&quot;&gt;&lt;/a&gt;ViewModel概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>架构组件——Lifecycle详解</title>
    <link href="http://yoursite.com/2018/06/27/android/%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94Lifecycle%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/06/27/android/架构组件——Lifecycle详解/</id>
    <published>2018-06-27T08:58:43.000Z</published>
    <updated>2018-10-05T16:36:34.537Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1、Lifecycle介绍"><a href="#1、Lifecycle介绍" class="headerlink" title="1、Lifecycle介绍"></a>1、Lifecycle介绍</h4><p>lifecycle官方文档地址：<br><a href="https://developer.android.com/topic/libraries/architecture/lifecycle" target="_blank" rel="noopener">https://developer.android.com/topic/libraries/architecture/lifecycle</a></p><h5 id="为什么要使用lifecycle？"><a href="#为什么要使用lifecycle？" class="headerlink" title="为什么要使用lifecycle？"></a>为什么要使用lifecycle？</h5><blockquote><p>activity 和fragment 是有声明周期的，有时候，我们的很多操作需要写在声明周期的方法中，比如，下载，文件操作等，这样很多情况下回导致，我们在activity中的声明周期方法中写越来越多的代码，activity或者fragment 越来越臃肿，代码维护越来越困难。 使用lifecycle就可以很好的解决这类问题。<br>lifecycle代码简洁，我们可以通过实现LifecycleObserver 接口，来监听声明周期，然后我们在activity和fragment中去注册监听。</p></blockquote><h4 id="2、几个重要的类和接口"><a href="#2、几个重要的类和接口" class="headerlink" title="2、几个重要的类和接口"></a>2、几个重要的类和接口</h4><ul><li><p><strong>Lifecycle</strong><br> Lifecycle是一个持有组件生命周期状态（如Activity或Fragment）的信息的类，并允许其他对象观察此状态。</p></li><li><p><strong>Event</strong> ：从框架和Lifecycle类派发的生命周期事件。这些事件映射到活动和片段中的回调事件。</p></li><li><p><strong>State</strong> ：由Lifecycle对象跟踪的组件的当前状态。</p></li><li><strong>LifecycleOwner</strong> （重要）Lifecycle持有者</li><li><p>实现该接口的类持有生命周期(Lifecycle对象)，该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</p></li><li><p><strong>LifecycleObserver</strong>（重要）Lifecycle观察者</p></li><li>实现该接口的类，通过注解的方式，可以通过被LifecycleOwner类的addObserver(LifecycleObserver o)方法注册,被注册后，LifecycleObserver便可以观察到LifecycleOwner的生命周期事件。</li></ul><h4 id="3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver-的使用"><a href="#3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver-的使用" class="headerlink" title="3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver 的使用"></a>3、LifeCycle中两个重要的接口LifeCycleOwner和LifecycleObserver 的使用</h4><h5 id="（1）LifecycleOwner（生命周期持有者接口）"><a href="#（1）LifecycleOwner（生命周期持有者接口）" class="headerlink" title="（1）LifecycleOwner（生命周期持有者接口）"></a>（1）LifecycleOwner（生命周期持有者接口）</h5><blockquote><p>官网介绍：<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>是一个单一的方法接口，表示该类有一个 <a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>。它有一个方法，<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner#getLifecycle%28%29" target="_blank" rel="noopener">getLifecycle()</a>这个方法 必须由这个类来实现。如果您试图管理整个应用程序进程的生命周期，请参阅 <a href="https://developer.android.com/reference/android/arch/lifecycle/ProcessLifecycleOwner" target="_blank" rel="noopener">ProcessLifecycleOwner</a>。该接口从各个类（如Fragment和AppCompatActivity）抽象生命周期的所有权，并允许编写与它们一起工作的组件。<br>任何自定义应用程序类都可以实现LifecycleOwner接口<br>实现LifecycleObserver的组件与实现LifecycleOwner的组件无缝协作，因为所有者可以提供生命周期，观察者可以注册以观看</p></blockquote><p>简单来说，LifecycleOwner就是一个接口，谁继承了它，就持有了lifecycle对象。然后就可以调用getLifecycle()方法获取继承了抽象类Lifecycle的LifecycleRegistry，然后调用 addObserver(@NonNull LifecycleObserver observer) 方法来注册监听。<br>这样，<strong>该接口的生命周期(Lifecycle对象)的改变会被其注册的观察者LifecycleObserver观察到并触发其对应的事件。</strong></p><p><strong>注意：Support Library 26.1.0 及其以后的版本，Activity 和Fragment 已经实现了LifecycleOwner 接口，所以，我们可以直接在Activity 和Fragment中使用getLifecycle()方法来获取lifecycle对象，来添加观察者监听。</strong></p><h5 id="（2）LifecycleObserver（生命周期观察者接口）"><a href="#（2）LifecycleObserver（生命周期观察者接口）" class="headerlink" title="（2）LifecycleObserver（生命周期观察者接口）"></a>（2）LifecycleObserver（生命周期观察者接口）</h5><blockquote><p>LifecycleObserver 是一个观察者接口，实现了它，可以通过注解或者继承的方式，来管理声明周期的监听。只要在持有lifecycle的类中注册了它，当声明周期发生变化时，它就能收到，进行我们自定义的操作。</p></blockquote><p>两种实现方式：</p><pre><code>1. 实现DefultLifecyceObserver接口，然后重写里面生命周期方法；2. 直接实现LifecycleObserver接口，然后通过注解的方式来接收生命周期的变化；</code></pre><p><strong>Lifecycle.java文档中是建议使用第一种方式，因为文档中说明了，随着Java8成为主流，注解的方式会被弃用。DefaultLifecycleObserver是需要另外声明的java8 比如下面</strong><br>GenericLifecycleObserver，FullLifecycleObserver，DefaultLifecycleObserver 这三个接口都是直接或者间接继承的LifecycleObserver</p><figure class="highlight flix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 如果使用的是java 8要显示声明如下的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lifecycle_version</span> </span>= <span class="string">"1.1.1"</span></span><br><span class="line">implementation <span class="string">"android.arch.lifecycle:common-java8:$lifecycle_version"</span></span><br></pre></td></tr></table></figure><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180626/DJk2i4fhm9.png" alt="mark"> </p><h4 id="3、开始使用Lifecycle"><a href="#3、开始使用Lifecycle" class="headerlink" title="3、开始使用Lifecycle"></a>3、开始使用Lifecycle</h4><p>我们写个测试代码，首先，我们要测试一下，到底LifecycleObserver到底能不能监听到声明周期的变化。并且实验下上图中的声明周期状态<br>先写两个简单的Activity，FirstActivity 和SecondActivity, 单纯的一个跳转。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Button</span> firstBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> <span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.first_activity_layout);</span><br><span class="line">        initView();</span><br><span class="line">        initListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initView() &#123;</span><br><span class="line">        firstBtn = findViewById(<span class="type">R</span>.id.first_btn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initListener() &#123;</span><br><span class="line">        firstBtn.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onClick(<span class="type">View</span> v) &#123;</span><br><span class="line">                <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="type">FirstActivity</span>.<span class="keyword">this</span>, <span class="type">SecondActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们要做的是要写一个需要拥有声明周期的类，正常我们自定义控件啊，或者做其他逻辑的类，是没有声明周期的，现在有了LifecycleObserver,我们可以让一个普通的类拥有感知声明周期变化的能力。比如，现在自定义一个，MyObserver类。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class MyObserver implements DefaultLifecycleObserver&#123;</span><br><span class="line">   <span class="keyword">private</span> static final <span class="built_in">String</span> <span class="built_in">TAG</span> = <span class="string">"MyListener"</span>;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onCreate(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onCreate()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onStart(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onStart()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onResume(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onResume()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onPause(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onPause()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onStop(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onStop()"</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="literal">void</span> onDestroy(@NonNull LifecycleOwner owner) &#123;</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"onDestroy() "</span>);</span><br><span class="line">        <span class="keyword">Log</span>.d(<span class="built_in">TAG</span>,<span class="string">"当前生命周期状态="</span>+lifecycle.getCurrentState().name());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们采取的是，直接继承DefaultLifecycleObserver接口，来实现它所有的方法。我们在里面做了log,来查看，是否这个类，收到了activity声明周期的变化。<br>然后，要做的就是<strong>注册监听</strong><br>在Activity 的OnCreate方法中，调用getLifecycle();</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Button</span> firstBtn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="meta">@Nullable</span> <span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(<span class="type">R</span>.layout.first_activity_layout);</span><br><span class="line">        initView();</span><br><span class="line">        initListener();</span><br><span class="line">        <span class="comment">//添加了这一行代码</span></span><br><span class="line">        getLifecycle().addObserver(<span class="keyword">new</span> <span class="type">MyObserver</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initView() &#123;</span><br><span class="line">        firstBtn = findViewById(<span class="type">R</span>.id.first_btn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> void initListener() &#123;</span><br><span class="line">        firstBtn.setOnClickListener(<span class="keyword">new</span> <span class="type">View</span>.<span class="type">OnClickListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onClick(<span class="type">View</span> v) &#123;</span><br><span class="line">                <span class="type">Intent</span> intent = <span class="keyword">new</span> <span class="type">Intent</span>(<span class="type">FirstActivity</span>.<span class="keyword">this</span>, <span class="type">SecondActivity</span>.<span class="keyword">class</span>);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，api26,.1以后，Activity中可以直接 getLifecycle().addObserver(new MyObserver()); 这样，就已经注册了声明周期观察者的监听。运行查看log<br>启动FirstActivity后，MyObserver类已经监听到了Activity的声明周期方法<br>并且，和图中表示一致，各个声明周期方法对应相应的节点。一定要清楚，后面会用到。比如，onResume()方法执行后，Activity处于RESUME状态，我们可以通过判断这个状态来做一些事情<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/cD74jCJ522.png?imageslim" alt="mark"><br>点击跳转到SecondActivity<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/7A8Ia38Kb2.png?imageslim" alt="mark"><br>可以看到，FirstActivity声明周期走了onPause  onStop，MyObserver也成功监听到了，继续返回FirstActivity<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/dB5fkImjbE.png?imageslim" alt="mark"><br>最后，点击返回键，退出FirstActivity，<br><img src="http://oima95jt3.bkt.clouddn.com/blog/180627/8lIlKAejLF.png?imageslim" alt="mark"></p><p>通过这个简单的小例子，我们看到了 我们的类，只要实现了 LifecycleObserver接口，然后，在Activity 或者Fragment中 通过getLifecycle().addObserver()方法，把这个类的对象传入，就可以实现声明周期的感应监听。</p><p>当然，我们可以再初始化这个类的时候，把Lifecycle对象传入，那我们自定义的类就可以自己去管理声明周期，而不依赖activity或者fragment。 这样，activity在使用此类的时候就不必关系声明周期的问题，因为，在这个类里面我们已经处理了。比如： 给MyObserver类 添加一个构造方法，传入一个Lifecycle对象。</p><p><strong>要注意的是：</strong><br>生命周期状态为<strong>RESUMED</strong>时表示，当前activity 是在前台，并且可交互也就是onResume()执行后</p><p>生命周期状态为<strong>STARTED</strong>时，表示当前activity处于可见但是不可交互，也就是onStart()方法刚执行完或者onPause()方法刚执行完的状态</p><p>生命周期状态为<strong>CREATED</strong>,表示onCreate()方法刚刚执行完或者onStop()方法刚刚执行完，也就是当前activity不在前台，但是也没有处于销毁状态。</p><p>生命周期状态为<strong>DESTORYED</strong>,表示当前Activity还不存在，没有被创建或者已经销毁，我们通常考虑比较多的就是，onDestory()方法执行后，当前Activity已经销毁。</p><p>所以，如果我们要保证在Activity或者Fragment的有效生命周期内进行的操作，必须判断，<strong>当前lifecycle的状态是否至少是CREATED状态</strong>，避免Activity或者fragment销毁了以后，回调或者网络请求才回来，此时做一些操作会导致异常。</p><p>添加以下代码，就是我们把lifecycle对象传给观察者，让它自己去判断回调后的代码，保证至少是CREATED状态<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> Lifecycle lifecycle;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyObserver</span><span class="params">(Lifecycle lifecycle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lifecycle = lifecycle;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//然后再相应的回调方法中使用下面代码判断，保证数据回调回来，当前activity是存在的</span></span><br><span class="line">    <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(CREATED)) &#123;</span><br><span class="line">            <span class="comment">//这里只是示例，不一定是CREATED</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里用到了Lifecycle类的方法，下面我们看一下Lifecycle的源码</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> &#123;</span></span><br><span class="line">    <span class="meta">@MainThread</span>  <span class="comment">//添加将在LifecycleOwner更改状态时通知的LifecycleObserver。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> addObserver(<span class="meta">@NonNull</span> LifecycleObserver observer);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span> <span class="comment">//从观察者列表中删除给定的观察者。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> removeObserver(<span class="meta">@NonNull</span> LifecycleObserver observer);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span> <span class="comment">//返回生命周期的当前状态。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> State getCurrentState();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Event</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        ON_CREATE,<span class="comment">//用于onCreate事件的常量LifecycleOwner。</span></span><br><span class="line"></span><br><span class="line">        ON_START,</span><br><span class="line"></span><br><span class="line">        ON_RESUME,</span><br><span class="line"></span><br><span class="line">        ON_PAUSE,</span><br><span class="line"></span><br><span class="line">        ON_STOP,</span><br><span class="line"></span><br><span class="line">        ON_DESTROY,</span><br><span class="line"></span><br><span class="line">        ON_ANY <span class="comment">//一个Event可以用来匹配所有事件的常数。 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        DESTROYED,</span><br><span class="line">        INITIALIZED, <span class="comment">//LifecycleOwner的初始化状态。 </span></span><br><span class="line">        CREATED, </span><br><span class="line">        STARTED,</span><br><span class="line">        RESUMED;</span><br><span class="line"><span class="comment">//比较此状态是否大于或等于给定值state。</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isAtLeast(<span class="meta">@NonNull</span> State state) &#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marks a class as a LifecycleObserver. It does not have any methods, instead, relies on</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> OnLifecycleEvent&#125; annotated methods.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Lifecycle Lifecycle - for samples and usage patterns.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleObserver</span> &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是一个抽象类，注释已经很详细了，应该不用解释了</p><p>最后借用下官网的-生命周期感知组件的最佳实战</p><pre><code>1. 尽可能保持您的UI控制器（活动和片段）尽可能精简。他们不应该试图获取他们自己的数据;相反，使用[ViewModel](https://developer.android.com/reference/android/arch/lifecycle/ViewModel)来做到这一点，并观察一个LiveData对象来反映更改回视图。2. 尝试编写数据驱动的用户界面，其中您的用户界面控制器的职责是在数据更改时更新视图，或将用户操作通知给ViewModel。3. 把你的数据逻辑放在[ViewModel](https://developer.android.com/reference/android/arch/lifecycle/ViewModel)类中。ViewModel应作为您的UI控制器和其他应用程序之间的连接器。但要小心，ViewModel不负责提取数据（例如，来自网络）。相反，ViewModel应调用相应的组件来获取数据，然后将结果提供给UI控制器。4. 使用[dataBinding](https://developer.android.com/topic/libraries/data-binding/)在视图和UI控制器之间保持干净的界面。这使您可以使您的视图更具说明性，并最大限度地减少需要在活动和片段中编写的更新代码。   如果你喜欢用Java编程语言来做到这一点，可以使用像Butter Knife这样的库来避免样板代码并且有更好的抽象。5. 如果您的UI很复杂，请考虑创建一个演示者类（[presenter](http://www.gwtproject.org/articles/mvp-architecture.html#presenter)）来处理UI修改。这可能是一项艰巨的任务，但它可以使您的UI组件更易于测试。6. 避免在ViewModel中引用View或Activity上下文。   如果ViewModel超出活动（在配置更改的情况下），则活动会泄漏并且垃圾收集器无法正确处理。</code></pre><p>借用下<a href="https://blog.csdn.net/zhuzp_blog/article/details/78871374" target="_blank" rel="noopener">https://blog.csdn.net/zhuzp_blog/article/details/78871374</a>  作者的两张图，更清晰，对于相信信息，可到作者博客去查看相关讲解<br><img src="https://img-blog.csdn.net/20180531152720780?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p><img src="https://img-blog.csdn.net/20180531152910152?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTExMzgxOTA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1、Lifecycle介绍&quot;&gt;&lt;a href=&quot;#1、Lifecycle介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Lifecycle介绍&quot;&gt;&lt;/a&gt;1、Lifecycle介绍&lt;/h4&gt;&lt;p&gt;lifecycle官方文档地址：&lt;br&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件官方文档02——LiveData</title>
    <link href="http://yoursite.com/2018/06/27/android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A302%E2%80%94%E2%80%94LiveData/"/>
    <id>http://yoursite.com/2018/06/27/android/Android架构组件官方文档02——LiveData/</id>
    <published>2018-06-27T03:33:09.000Z</published>
    <updated>2018-10-05T15:38:01.656Z</updated>
    
    <content type="html"><![CDATA[<h3 id="LiveData概述"><a href="#LiveData概述" class="headerlink" title="LiveData概述"></a>LiveData概述</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>是一个可观察的数据持有者类。<br>与常规可观察性不同，LiveData具有生命周期感知能力，这意味着它尊重其他应用程序组件（例如活动，片段或服务）的生命周期。<br>这种感知确保LiveData只更新处于活动生命周期状态的应用程序组件观察者。<br>注意：要将LiveData组件导入到Android项目中，请参阅向项目<a href="https://developer.android.com/topic/libraries/architecture/adding-components.html#lifecycle" target="_blank" rel="noopener">添加组件</a>。<br>如果观察者的生命周期处于<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#STARTED" target="_blank" rel="noopener">STARTED</a>或<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#RESUMED" target="_blank" rel="noopener">RESUMED</a>状态，则LiveData会将<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html" target="_blank" rel="noopener">Observer</a>类表示的观察者视为活动状态。<br><a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>仅通知处于活跃状态的观察者更新。<br>未注册观看<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>对象的非活跃期的观察者不会收到有关更改的通知。</p><p>您可以注册与实现LifecycleOwner接口的对象配对的观察者。此关系允许在相应生命周期对象的状态更改为DESTROYED时删除观察者。<br>这对于活动和片段尤其有用，因为它们可以安全地观察LiveData对象，而不必担心泄漏 - 在其生命周期被破坏时，活动和片段会立即取消订阅。</p><p>有关如何使用LiveData的更多信息，请参阅使用LiveData对象</p><h3 id="使用LiveData的优点"><a href="#使用LiveData的优点" class="headerlink" title="使用LiveData的优点"></a>使用LiveData的优点</h3><p>使用LiveData提供以下优点：<br><strong>确保您的UI界面符合您UI数据状态</strong></p><blockquote><p>LiveData遵循观察者模式。<br>当生命周期状态改变时，LiveData会通知Observer对象。<br>您可以合并代码以更新这些Observer对象中的UI。<br>每次应用程序数据更改时，您的观察者都可以在每次更改时更新UI，而不是每次更新UI。<br><strong>没有内存泄漏</strong><br>观察者绑定到<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.html" target="_blank" rel="noopener">Lifecycle</a>对象，并在其相关生命周期被破坏后自行清理。</p></blockquote><p><strong>不会因为活动停止而崩溃</strong></p><blockquote><p>如果观察者的生命周期处于非活动状态，例如在后退堆栈中的活动，则它不会收到任何LiveData事件。</p></blockquote><p><strong>没有更多的手动声明周期处理</strong><br>UI组件只是观察相关数据，不停止或恢复观察。<br>LiveData自动管理所有这些，因为它在观察时意识到相关的生命周期状态更改。<br><strong>始终保持最新的数据</strong><br>如果生命周期变为非活动状态，它将在再次变为活动状态时收到最新数据。例如，后台活动在返回到前台后立即收到最新数据。<br><strong>正确的配置更改</strong><br>如果由于配置更改（如设备旋转）而重新创建活动或片段，它会立即收到最新的可用数据。<br><strong>共享资源</strong><br>您可以使用单例模式扩展LiveData对象以包装系统服务，以便它们可以在应用程序中共享。<br>LiveData对象连接到系统服务一次，然后任何需要该资源的观察者都可以观看LiveData对象。<br>有关更多信息，请参阅扩展LiveData。</p><h3 id="使用LiveData对象"><a href="#使用LiveData对象" class="headerlink" title="使用LiveData对象"></a>使用LiveData对象</h3><p>按照以下步骤操作LiveData对象：</p><ol><li>创建一个LiveData实例来保存某种类型的数据。这通常在您的<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel.html" target="_blank" rel="noopener">ViewModel</a>类中完成。</li><li>创建一个<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html" target="_blank" rel="noopener">Observer</a>对象，该对象定义<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html#onChanged%28T%29" target="_blank" rel="noopener">onChanged</a>()方法，该方法控制LiveData对象保存的数据更改时发生的情况。您通常在UI控制器中创建Observer对象，如活动或片段。</li><li>使用observe()方法将Observer对象附加到LiveData对象。observe()方法使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner.html" target="_blank" rel="noopener">LifecycleOwner</a>对象。这将Observer对象订阅到LiveData对象，以便通知其更改。您通常将Observer对象附加到UI控制器中，例如Activity或Fragment。</li></ol><blockquote><p><strong>注意：您可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#observeForever%28android.arch.lifecycle.Observer%3CT%3E%29" target="_blank" rel="noopener">observeForever（Observer）</a>方法注册一个没有关联的LifecycleOwner对象的观察器。在这种情况下，观察者被认为始终处于活动状态，因此总是通知修改。您可以删除这些观察者调用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#removeObserver%28android.arch.lifecycle.Observer%3CT%3E%29" target="_blank" rel="noopener">removeObserver（Observer）</a>方法。</strong></p></blockquote><p>当您更新存储在LiveData对象中的值时，只要附加的LifecycleOwner处于活动状态，它就会触发所有已注册的观察者。<br>LiveData允许UI控制器观察者订阅更新。当LiveData对象持有的数据更改时，UI会自动更新以作为响应。</p><h4 id="创建LiveData对象"><a href="#创建LiveData对象" class="headerlink" title="创建LiveData对象"></a>创建LiveData对象</h4><p>LiveData是一个可用于任何数据的包装器，包括实现集合的对象（如List）。LiveData对象通常存储在ViewModel对象中，并通过getter方法访问，如以下示例所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NameViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a LiveData with a String</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">MutableLiveData</span>&lt;<span class="type">String</span>&gt; mCurrentName;</span><br><span class="line"></span><br><span class="line">    public <span class="type">MutableLiveData</span>&lt;<span class="type">String</span>&gt; getCurrentName() &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurrentName == <span class="literal">null</span>) &#123;</span><br><span class="line">            mCurrentName = <span class="keyword">new</span> <span class="type">MutableLiveData</span>&lt;<span class="type">String</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mCurrentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rest of the ViewModel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初，LiveData对象中的数据未设置。</p><blockquote><p>注意：由于以下原因，请确保存储更新<strong>ViewModel</strong>对象中的UI的<strong>LiveData</strong>对象，而不是活动或片段：</p><ul><li>避免臃肿的活动和碎片。现在这些UI控制器负责显示数据但不保存数据状态。</li><li>将<strong>LiveData</strong>实例与特定活动或片段实例分离，并允许<strong>LiveData</strong>对象保留配置更改。</li></ul></blockquote><p>您可以在<strong><a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html" target="_blank" rel="noopener">ViewModel指南</a></strong>中了解更多关于ViewModel类的好处和用法。</p><h4 id="观察LiveData对象"><a href="#观察LiveData对象" class="headerlink" title="观察LiveData对象"></a>观察LiveData对象</h4><p>在大多数情况下，出于以下原因，应用程序组件的onCreate()方法是开始观察LiveData对象的正确位置：</p><ol><li>确保系统不会从Activity或fragment的onResume（）方法进行多余的调用。</li><li>确保Activity或Fragment<strong>具有</strong>一旦它变为活动状态即可显示的<strong>数据</strong>。只要应用程序组件处于<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#STARTED" target="_blank" rel="noopener">STARTED</a>状态，它就会从它所观察的LiveData对象中接收最新的值。这只会在设置要观察的LiveData对象时才会发生。</li></ol><p>通常，LiveData仅在数据更改时传递更新，并且仅传递给活动观察者。此行为的一个例外是，观察者在从非活动状态变为活动状态时也会收到更新。此外，如果观察者第二次从非激活状态变为激活状态，则只有在自上一次变为活动状态以来该值发生变化时才会收到更新。</p><p>以下示例代码说明了如何开始观察LiveData对象：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">NameActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">NameViewModel</span> mModel;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> void onCreate(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Other code to setup the activity...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the ViewModel.</span></span><br><span class="line">        mModel = <span class="type">ViewModelProviders</span>.of(<span class="keyword">this</span>).get(<span class="type">NameViewModel</span>.<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create the observer which updates the UI.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Observer</span>&lt;<span class="type">String</span>&gt; nameObserver = <span class="keyword">new</span> <span class="type">Observer</span>&lt;<span class="type">String</span>&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            public void onChanged(<span class="meta">@Nullable</span> <span class="keyword">final</span> <span class="type">String</span> newName) &#123;</span><br><span class="line">                <span class="comment">// Update the UI, in this case, a TextView.</span></span><br><span class="line">                mNameTextView.setText(newName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Observe the LiveData, passing in this activity as the LifecycleOwner and the observer.</span></span><br><span class="line">        mModel.getCurrentName().observe(<span class="keyword">this</span>, nameObserver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用nameObserver作为参数传递<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#observe%28android.arch.lifecycle.LifecycleOwner,android.arch.lifecycle.Observer%3CT%3E%29" target="_blank" rel="noopener">observe()</a>后，立即调用<a href="https://developer.android.com/reference/android/arch/lifecycle/Observer.html#onChanged%28T%29" target="_blank" rel="noopener">onChanged()</a>，以提供存储在mCurrentName中的最新值。如果LiveData对象未在mCurrentName中设置值，则不调用onChanged()。</p><h4 id="更新LiveData对象"><a href="#更新LiveData对象" class="headerlink" title="更新LiveData对象"></a>更新LiveData对象</h4><p>LiveData没有公开可用的方法来更新存储的数据。<a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html" target="_blank" rel="noopener">MutableLiveData</a>类公开公开<a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#setValue%28T%29" target="_blank" rel="noopener">setValue(T)</a>和<a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#postValue%28T%29" target="_blank" rel="noopener">postValue(T)</a>方法，如果需要编辑存储在LiveData对象中的值，则必须使用这些方法。通常在ViewModel中使用MutableLiveData，然后ViewModel只向观察者公开不可变的LiveData对象。<br>在建立观察者关系后，可以更新LiveData对象的值，如以下示例所示，当用户点击按钮时触发所有观察者：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        String anotherName = <span class="string">"John Doe"</span>;</span><br><span class="line">        mModel.getCurrentName().setValue(anotherName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在示例中调用setValue（T）会导致观察者用值John Doe调用它们的onChanged（）方法。该示例显示按钮按下，但setValue（）或postValue（）可能因多种原因被调用来更新mName，包括响应网络请求或数据库加载完成;在所有情况下，调用setValue（）或postValue（）都会触发观察者并更新UI。</p><blockquote><p>注意：您必须调用setValue（T）方法来更新主线程中的LiveData对象。如果代码在工作线程中执行，则可以使用postValue（T）方法更新LiveData对象。</p></blockquote><h4 id="与Room一起使用LiveData"><a href="#与Room一起使用LiveData" class="headerlink" title="与Room一起使用LiveData"></a>与Room一起使用LiveData</h4><p><a href="https://developer.android.com/training/data-storage/room/index.html" target="_blank" rel="noopener">Room</a>持久性库支持返回<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>对象的可观察查询。可观察查询是作为数据库访问对象（DAO）的一部分写入的。</p><p>当更新数据库时，会生成所有必要的代码以更新LiveData对象。生成的代码在需要时在后台线程上异步运行查询。这种模式对于保持UI中显示的数据与存储在数据库中的数据保持同步很有用。您可以在<a href="https://developer.android.com/topic/libraries/architecture/room.html" target="_blank" rel="noopener">Room持久库指南</a>中阅读关于Room和DAO的更多信息。</p><h3 id="扩展LiveData"><a href="#扩展LiveData" class="headerlink" title="扩展LiveData"></a>扩展LiveData</h3><p>如果观察者的生命周期处于<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#STARTED" target="_blank" rel="noopener">STARTED</a>或<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State.html#RESUMED" target="_blank" rel="noopener">RESUMED</a>状态，则<strong>LiveData</strong>将认为观察者处于活动状态。以下示例代码说明了如何扩展<strong>LiveData</strong>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StockManager mStockManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePriceListener mListener = <span class="keyword">new</span> SimplePriceListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPriceChanged</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">            setValue(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockLiveData</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        mStockManager = <span class="keyword">new</span> StockManager(symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.requestPriceUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.removeUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本示例中的价格监听器的实现包括以下重要方法：</p><ul><li><p>当LiveData对象具有处于活跃期的观察者时，将调用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#onActive%28%29" target="_blank" rel="noopener">onActive（）</a>方法。这意味着您需要开始观察此方法的价格更新。</p></li><li><p>当LiveData对象没有任何active期间的观察者时，将调用<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html#onInactive%28%29" target="_blank" rel="noopener">onInactive（）</a>方法。由于没有观察员在监听，因此没有理由保持连接到StockManager服务。</p></li><li><a href="https://developer.android.com/reference/android/arch/lifecycle/MutableLiveData.html#setValue%28T%29" target="_blank" rel="noopener">setValue（T）</a>方法更新LiveData实例的值并通知任何活跃的观察者有关更改。</li></ul><p>您可以使用StockLiveData类如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void onActivityCreated(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        <span class="type">LiveData</span>&lt;<span class="type">BigDecimal</span>&gt; myPriceListener = ...;</span><br><span class="line">        myPriceListener.observe(<span class="keyword">this</span>, price -&gt; &#123;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>observe（）方法将把实现了LifecycleOwner实例的Fragment作为第一个参数传递。这样做表示此观察者被绑定到与所有者关联的生命周期对象，这意味着：</p><ul><li>如果生命周期对象不处于活跃状态，则即使值发生更改，也不会调用观察者。</li><li>生命周期对象被销毁后，观察者被自动删除。t<br> LiveData对象支持生命周期意味着您可以在多个Activity，Fragment和Service之间共享它们。为了保持示例简单，您可以按如下方式将LiveData类实现为单例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockLiveData</span> <span class="keyword">extends</span> <span class="title">LiveData</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> StockLiveData sInstance;</span><br><span class="line">    <span class="keyword">private</span> StockManager mStockManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SimplePriceListener mListener = <span class="keyword">new</span> SimplePriceListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPriceChanged</span><span class="params">(BigDecimal price)</span> </span>&#123;</span><br><span class="line">            setValue(price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StockLiveData <span class="title">get</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> StockLiveData(symbol);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StockLiveData</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        mStockManager = <span class="keyword">new</span> StockManager(symbol);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.requestPriceUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onInactive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mStockManager.removeUpdates(mListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>您可以再Fragment中使用它，如下所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void onActivityCreated(<span class="type">Bundle</span> savedInstanceState) &#123;</span><br><span class="line">        <span class="type">StockLiveData</span>.get(getActivity()).observe(<span class="keyword">this</span>, price -&gt; &#123;</span><br><span class="line">            <span class="comment">// Update the UI.</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个Fragment和Activity可以观察MyPriceListener实例。如果LiveData只有一个或多个可见并处于活动状态，则LiveData仅连接到系统服务。</p><h3 id="转换LiveData"><a href="#转换LiveData" class="headerlink" title="转换LiveData"></a>转换LiveData</h3><p>您可能希望在LiveData更改为观察者之前更改存储在LiveData对象中的，或者您可能需要基于另一个LiveData实例的值返回不同的LiveData实例。Lifecycle软件包提供Transformations类，其中包括支持这些场景的帮助方法。<br><strong><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html#map%28android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20Y%3E%29" target="_blank" rel="noopener">Transformations.map()</a></strong><br>在存储在LiveData对象中的值上使用函数，并向下游传播结果。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LiveData&lt;User&gt; userLiveData = <span class="built_in">..</span>.;</span><br><span class="line">LiveData&lt;String&gt; userName = Transformations.map(userLiveData,<span class="built_in"> user </span>-&gt; &#123;</span><br><span class="line">    user.name + <span class="string">" "</span> + user.lastName</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong><a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations#switchMap%28android.arch.lifecycle.LiveData%3CX%3E,%20android.arch.core.util.Function%3CX,%20android.arch.lifecycle.LiveData%3CY%3E%3E%29" target="_blank" rel="noopener">Transformations.switchMap()</a></strong></p><p>与map（）类似，将函数应用于存储在LiveData对象中的值，并展开并向下游分派结果。传递给switchMap（）的函数必须返回一个LiveData对象，如下例所示：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private LiveData&lt;User&gt; getUser(String id) &#123;</span><br><span class="line">  <span class="built_in">..</span>.;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LiveData&lt;String&gt; userId = <span class="built_in">..</span>.;</span><br><span class="line">LiveData&lt;User&gt;<span class="built_in"> user </span>= Transformations.switchMap(userId, id -&gt; getUser(id) );</span><br></pre></td></tr></table></figure><p>您可以使用转换方法在观察者的生命周期中传递信息。除非观察者正在观察返回的LiveData对象，否则不会计算转换。由于转换是懒加载的，因此与生命周期相关的行为会隐式传递，而不需要额外的显式调用或依赖关系。</p><p>如果您认为您需要ViewModel对象中的Lifecycle对象，则转换可能是更好的解决方案。例如，假设您有一个接受地址并返回该地址的邮政编码的UI组件。您可以为此组件实现native的ViewModel，如以下示例代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">PostalCodeRepository</span> repository;</span><br><span class="line">    public <span class="type">MyViewModel</span>(<span class="type">PostalCodeRepository</span> repository) &#123;</span><br><span class="line">       <span class="keyword">this</span>.repository = repository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">LiveData</span>&lt;<span class="type">String</span>&gt; getPostalCode(<span class="type">String</span> address) &#123;</span><br><span class="line">       <span class="comment">// DON'T DO THIS</span></span><br><span class="line">       <span class="keyword">return</span> repository.getPostCode(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，postalCode是public的和fina的，因为该字段永远不会改变。postalCode字段定义为addressInput的转换，这意味着addressInput发生更改时将调用repository.getPostCode（）方法。如果存在活动观察者，那么这是真实的，如果在repository.getPostCode（）被调用时没有活跃的观察者，则在添加观察者之前不进行计算。</p><p>该机制允许版本较低的应用程序创建按需延迟计算的LiveData对象。ViewModel对象可以轻松获得对LiveData对象的引用，然后在其上定义转换规则。</p><h4 id="创建新的转换"><a href="#创建新的转换" class="headerlink" title="创建新的转换"></a>创建新的转换</h4><p>有十几种不同的特定转换可能在您的应用中很有用，但它们不是默认提供的。要实现自己的转换，您可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData.html" target="_blank" rel="noopener">MediatorLiveData</a>类，它监听其他<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData.html" target="_blank" rel="noopener">LiveData</a>对象并处理它们发出的事件。<strong>MediatorLiveData</strong>将其状态正确传播到源<strong>LiveData</strong>对象。要了解有关此模式的更多信息，请参阅<a href="https://developer.android.com/reference/android/arch/lifecycle/Transformations.html" target="_blank" rel="noopener">Transformations</a>类的参考文档。</p><h3 id="合并多个LiveData源"><a href="#合并多个LiveData源" class="headerlink" title="合并多个LiveData源"></a>合并多个LiveData源</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/MediatorLiveData.html" target="_blank" rel="noopener">MediatorLiveData</a>是<strong>LiveData</strong>的一个子类，允许您合并多个LiveData源。<strong>MediatorLiveData</strong>对象的观察者随后会在任何原始<strong>LiveData</strong>源对象更改时触发。</p><p>例如，如果您的UI中有一个可从本地数据库或网络更新的LiveData对象，则可以将以下资源添加到MediatorLiveData对象：</p><ul><li>与存储在数据库中的数据关联的LiveData对象。</li><li>与从网络访问的数据关联的LiveData对象。<br> 您的活动只需观察<strong>MediatorLiveData</strong>对象即可从两个来源接收更新。有关详细示例，请参阅<a href="https://developer.android.com/topic/libraries/architecture/guide.html" target="_blank" rel="noopener">应用程序体系结构指南</a>的附录：<a href="https://developer.android.com/topic/libraries/architecture/guide.html#addendum" target="_blank" rel="noopener">展示网络状态部分</a>。<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3>有关在<a href="https://developer.android.com/training/snackbar" target="_blank" rel="noopener">Snackbar</a>消息，导航事件和其他事件中使用LiveData的其他信息，请<a href="https://medium.com/google-developers/livedata-with-snackbar-navigation-and-other-events-the-singleliveevent-case-ac2622673150" target="_blank" rel="noopener">阅读此文章</a>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;LiveData概述&quot;&gt;&lt;a href=&quot;#LiveData概述&quot; class=&quot;headerlink&quot; title=&quot;LiveData概述&quot;&gt;&lt;/a&gt;LiveData概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://developer.android.com
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android架构组件官方文档01——Lifecycle</title>
    <link href="http://yoursite.com/2018/06/26/android/Android%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A301%E2%80%94%E2%80%94Lifecycle/"/>
    <id>http://yoursite.com/2018/06/26/android/Android架构组件官方文档01——Lifecycle/</id>
    <published>2018-06-26T09:14:34.000Z</published>
    <updated>2018-06-27T03:37:55.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用生命周期感知组件处理生命周期"><a href="#使用生命周期感知组件处理生命周期" class="headerlink" title="使用生命周期感知组件处理生命周期"></a>使用生命周期感知组件处理生命周期</h2><blockquote><p>支持生命周期的组件执行操作以响应另一个组件（例如Activity和fragment）的生命周期状态更改。这些组件可帮助您生成组织性更好，并且通常更轻量的代码，这些代码更易于维护。</p></blockquote><blockquote><p>常见的模式是在Activity和fragment的生命周期方法中实现依赖组件的操作。<br>但是，这种模式导致代码的组织不良以及错误泛滥。通过使用生命周期感知组件，您可以将相关组件的代码从生命周期方法中移出并移入组件本身。</p></blockquote><blockquote><p>android.arch.lifecycle包提供了类和接口，可让您构建支持生命周期的组件，这些组件可根据活动或片段的当前生命周期状态自动调整其行为<br><strong> 注意：要将<a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener">android.arch.lifecycle</a>导入到Android项目中，请参阅<a href="https://developer.android.com/topic/libraries/architecture/adding-components#lifecycle" target="_blank" rel="noopener">向项目添加组件</a>。 </strong></p></blockquote><blockquote><p>Android框架中定义的大多数应用程序组件都附带有生命周期。生命周期由操作系统或您的流程中运行的框架代码管理。它们是Android如何工作和应用程序必须尊重它们的核心。不这样做可能会触发内存泄漏甚至应用程序崩溃。</p></blockquote><p>想象一下，我们有一个在屏幕上显示设备位置的Activity。<br>常见的实现可能如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Callback callback)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// connect to system location service</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect from system location service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, (location) -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        myLocationListener.start();</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">        <span class="comment">// manage other components that need to respond</span></span><br><span class="line">        <span class="comment">// to the activity lifecycle</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   尽管这个示例看起来很好，但在实际的应用程序中，您最终会有太多的调用来管理UI和其他组件，以响应当前的生命周期状态。<br>管理多个组件会在生命周期方法中放置大量代码，例如onStart（）和onStop（），这使得它们很难维护。</p><p>此外，无法保证组件在活动或片段停止之前启动。<br>如果我们需要执行一个长时间运行的操作，比如onStart（）中的一些配置检查，情况尤其如此。<br>这可能会导致onStop（）方法在onStart（）之前完成的争用条件，从而使组件的存活时间超过所需的时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyLocationListener myLocationListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> MyLocationListener(<span class="keyword">this</span>, location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Util.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="comment">// what if this callback is invoked AFTER activity is stopped?</span></span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        myLocationListener.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://developer.android.com/reference/android/arch/lifecycle/package-summary" target="_blank" rel="noopener">android.arch.lifecycle</a>包提供的类和接口可帮助您以弹性和独立的方式解决这些问题。</p><h3 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>是一个持有组件生命周期状态（如Activity或Fragment）的信息的类，并允许其他对象观察此状态。<br><a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>使用两个主要枚举来跟踪其关联组件的生命周期状态：</p><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>&emsp;&emsp;从框架和Lifecycle类派发的生命周期事件。<br>&emsp;&emsp;这些事件映射到Activities和fragments中的回调事件。</p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><p>&emsp;&emsp;由Lifecycle对象跟踪的组件的当前状态。</p><p><img src="http://oima95jt3.bkt.clouddn.com/blog/180626/DJk2i4fhm9.png?imageslim" alt="mark"></p><p>将状态视为图中的节点，将事件视为这些节点之间的边界。</p><p>一个类可以通过向其方法添加注解来监视组件的生命周期状态。<br>然后，您可以通过调用Lifecycle类的<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle#addObserver%28android.arch.lifecycle.LifecycleObserver%29" target="_blank" rel="noopener">addObserver（）</a>方法并传递观察者的实例来添加观察者，如下例所示：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">MyObserver</span> <span class="selector-tag">implements</span> <span class="selector-tag">LifecycleObserver</span> &#123;</span><br><span class="line">    <span class="variable">@OnLifecycleEvent</span>(Lifecycle.Event.ON_RESUME)</span><br><span class="line">    public void connectListener() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@OnLifecycleEvent</span>(Lifecycle.Event.ON_PAUSE)</span><br><span class="line">    public void disconnectListener() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">myLifecycleOwner</span><span class="selector-class">.getLifecycle</span>()<span class="selector-class">.addObserver</span>(new MyObserver());</span><br></pre></td></tr></table></figure><p>在上面的例子中，myLifecycleOwner对象实现了<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>接口，这将在下一节中介绍。</p><h3 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h3><p><a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>是一个单一的方法接口，表示该类有一个<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle" target="_blank" rel="noopener">Lifecycle</a>。<br>它有一个方法<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner#getLifecycle%28%29" target="_blank" rel="noopener">getLifecycle（）</a>，它必须由class实现。<br>如果您试图管理整个应用程序进程的生命周期，请参阅<a href="https://developer.android.com/reference/android/arch/lifecycle/ProcessLifecycleOwner" target="_blank" rel="noopener">ProcessLifecycleOwner</a>。</p><p>该接口从各个类（如Fragment和AppCompatActivity）抽象生命周期的所有权，并允许编写与它们一起工作的组件。<br>任何自定义应用程序类都可以实现LifecycleOwner接口</p><p>实现<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleObserver" target="_blank" rel="noopener">LifecycleObserver</a>的组件可以与实现<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleOwner" target="_blank" rel="noopener">LifecycleOwner</a>的组件无缝协作，因为所有者可以提供生命周期，观察者可以注册观察。</p><p>对于位置跟踪示例，我们可以使MyLocationListener类实现LifecycleObserver，然后使用onCreate()方法中的活动生命周期对其进行初始化。<br>这允许MyLocationListener类是自给自足的，这意味着对生命周期状态变化作出反应的逻辑在MyLocationListener中声明，而不是在活动中声明。<br>让各个组件存储自己的逻辑使得活动和片段逻辑更容易管理。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">MyLocationListener</span> myLocationListener;</span><br><span class="line"></span><br><span class="line">    public void onCreate(...) &#123;</span><br><span class="line">        myLocationListener = <span class="keyword">new</span> <span class="type">MyLocationListener</span>(<span class="keyword">this</span>, getLifecycle(), location -&gt; &#123;</span><br><span class="line">            <span class="comment">// update UI</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Util</span>.checkUserStatus(result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                myLocationListener.enable();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个常见的用例就是避免在生命周期状处于不好的状态时调用某些回调。<br>例如，如果回调在保存活动状态后运行fragment事务，则会触发崩溃，因此我们绝不希望调用该回调。</p><p>为了简化这个用例，生命周期类允许其他对象查询当前状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyLocationListener</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyLocationListener</span><span class="params">(Context context, Lifecycle lifecycle, Callback callback)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_START)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">           <span class="comment">// connect</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        enabled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (lifecycle.getCurrentState().isAtLeast(STARTED)) &#123;</span><br><span class="line">            <span class="comment">// connect if not connected</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnLifecycleEvent</span>(Lifecycle.Event.ON_STOP)</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// disconnect if connected</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这个实现，我们的LocationListener类完全是生命周期感知的。<br>如果我们需要使用来自其他Activity或Fragment的LocationListener，我们只需要初始化它。<br>所有的启动和销毁操作都由该类本身进行管理。</p><p>如果Library提供需要与Android生命周期配合使用的类，我们建议您使用支持生命周期的组件。<br>您的Library客户端可以在客户端无需手动生命周期管理即可轻松集成这些组件。</p><h4 id="实施自定义LifecycleOwner"><a href="#实施自定义LifecycleOwner" class="headerlink" title="实施自定义LifecycleOwner"></a>实施自定义LifecycleOwner</h4><p><strong>Support Library 26.1.0中的Fragment和Activity以及更高版本已经实现LifecycleOwner接口。</strong></p><p>如果您想要创建LifecycleOwner的自定义类，则可以使用<a href="https://developer.android.com/reference/android/arch/lifecycle/LifecycleRegistry" target="_blank" rel="noopener">LifecycleRegistry</a>类，但需要将事件转发到该类中，如以下代码示例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LifecycleRegistry mLifecycleRegistry;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        mLifecycleRegistry = <span class="keyword">new</span> LifecycleRegistry(<span class="keyword">this</span>);</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.CREATED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        mLifecycleRegistry.markState(Lifecycle.State.STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生命周期感知组件的最佳实践"><a href="#生命周期感知组件的最佳实践" class="headerlink" title="生命周期感知组件的最佳实践"></a>生命周期感知组件的最佳实践</h3><ul><li>尽可能保持您的UI控制器（Activities和Fragments）尽可能精简。他们不应该试图获取他们自己的数据;相反，使用<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>来做到这一点，并观察一个<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" target="_blank" rel="noopener">LiveData</a>对象来反映更改回视图。</li><li>尝试编写数据驱动UI的界面，其中您的UI控制器的职责是在数据更改时更新视图，或将用户操作通知给<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>。</li><li>把你的数据逻辑放在<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>类中。<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>应作为您的UI控制器和其他应用程序之间的连接器。但要小心，<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>不负责提取数据（例如，来自网络）。相反，<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>应调用相应的组件来获取数据，然后将结果提供给UI控制器。</li><li>使用<a href="https://developer.android.com/topic/libraries/data-binding/" target="_blank" rel="noopener">Data Binding</a>在视图和UI控制器之间保持干净的界面。这使您可以使您的视图更具说明性，并最大限度地减少需要在活动和片段中编写的更新代码。如果你喜欢用Java编程语言来做到这一点，可以使用像Butter Knife这样的库来避免样板代码并且有更好的抽象</li><li>如果您的UI很复杂，请考虑创建一个presenter类来处理UI修改。这可能是一项艰巨的任务，但它可以使您的UI组件更易于测试。</li><li>避免在<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>中引用View或Activity上下文。如果<a href="https://developer.android.com/reference/android/arch/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a>超出活动（在配置更改的情况下），则活动会泄漏并且垃圾收集器无法正确处理。</li></ul><h3 id="支持生命周期感知组件的用例"><a href="#支持生命周期感知组件的用例" class="headerlink" title="支持生命周期感知组件的用例"></a>支持生命周期感知组件的用例</h3><p>支持生命周期的组件可以让您在各种情况下更容易地管理生命周期。<br>一些例子是：</p><ul><li>在粗粒度和细粒度 位置更新之间切换。使用生命周期感知组件在位置应用可见时启用细粒度位置更新，并在应用处于后台时切换到粗粒度更新。LiveData是一种生命周期感知型组件，允许您的应用在用户更改位置时自动更新用户界面。</li><li>停止并开始视频缓冲。尽可能使用支持生命周期的组件来启动视频缓冲，但延迟播放直到应用程序完全启动。您还可以使用生命周期感知组件在应用程序销毁时终止缓冲。</li><li>启动和停止网络连接。使用支持生命周期的组件可以在应用程序处于前台时实时更新（流式传输）网络数据，并在应用程序进入后台时自动暂停。</li><li>暂停和恢复动画可绘制。使用生命周期感知组件处理在应用程序处于后台时暂停动画的可绘制画面，并在应用程序处于前景时恢复可绘制画面。</li></ul><h3 id="处理停止事件"><a href="#处理停止事件" class="headerlink" title="处理停止事件"></a>处理停止事件</h3><p>当Lifecycle属于AppCompatActivity或Fragment时，Lifecycle的状态将更改为<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#CREATED" target="_blank" rel="noopener">CREATED</a>，并在调用AppCompatActivity或Fragment的onSaveInstanceState()时调度<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.Event#ON_STOP" target="_blank" rel="noopener">ON_STOP</a>事件。</p><p>当Fragment或AppCompatActivity的状态通过onSaveInstanceState（）保存时，UI被认为是不可变的，直到<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.Event#ON_START" target="_blank" rel="noopener">ON_START</a>被调用。尝试在保存状态后修改UI界面可能会导致应用程序的导航状态不一致，这就是为什么如果应用程序在状态保存后运行FragmentTransaction时FragmentManager会抛出异常。<br>有关详细信息，详情请参阅 <a href="https://developer.android.com/reference/android/support/v4/app/FragmentTransaction#commit%28%29" target="_blank" rel="noopener">commit()</a>。</p><p>如果观察者的关联Lifecycle在<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#STARTED" target="_blank" rel="noopener">STARTED</a>之前，则<a href="https://developer.android.com/reference/android/arch/lifecycle/LiveData" target="_blank" rel="noopener">LiveData</a>通过避免调用其观察者来防止这种边缘情况出现。<br>在幕后，它决定调用观察者之前调用<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#isAtLeast%28android.arch.lifecycle.Lifecycle.State%29" target="_blank" rel="noopener">isAtLeast()</a>。</p><p>不幸的是，AppCompatActivity的onStop()方法会在onSaveInstanceState()之后调用，这会在不允许UI状态更改但生命周期尚未移至<a href="https://developer.android.com/reference/android/arch/lifecycle/Lifecycle.State#CREATED" target="_blank" rel="noopener">CREATED</a>状态的情况下留下空隙。</p><p>为了防止出现这个问题，beta2版本中的Lifecycle类将lower状态标记为CREATED而不分派事件，即使事件直到<a href="https://developer.android.com/reference/android/support/v7/app/AppCompatActivity.html#onStop%28%29" target="_blank" rel="noopener">onStop()</a>被调用也未被分派，任何检查当前状态的代码也都会获得真实值。</p><p>不幸的是，这个解决方案有两个主要问题：</p><ul><li>在API等级23或更低的情况下，Android系统实际上保存活动的状态，即使它被另一活动部分覆盖。换句话说，Android系统调用onSaveInstanceState()，但不一定调用onStop()。这会创建一个潜在的长时间间隔，即使其UI状态无​​法修改，观察者仍认为生命周期处于活动状态。</li><li>任何想要向LiveData类公开类似行为的类都必须实现Lifecycle beta2和更低版本提供的解决方法</li></ul><p><strong>注意：为了使此流程更简单，并提供与旧版本的更好兼容性，从版本1.0.0-rc1开始，在调用onSaveInstanceState()而无需等待对onStop()的调用时，将Lifecycle对象标记为CREATED，并调度onStop()方法。这不太可能影响您的代码，但您需要注意这一点，因为它与API级别26及更低级别的Activity类中的调用顺序不匹配。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用生命周期感知组件处理生命周期&quot;&gt;&lt;a href=&quot;#使用生命周期感知组件处理生命周期&quot; class=&quot;headerlink&quot; title=&quot;使用生命周期感知组件处理生命周期&quot;&gt;&lt;/a&gt;使用生命周期感知组件处理生命周期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;支
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
